

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>http://localhost:4000/</id>
  <title>Yoon-Min</title>
  <subtitle>부족한 개발 실력을 키우고 다른 사람들에게 도움이 되고 싶습니다.</subtitle>
  <updated>2023-10-30T22:38:42+09:00</updated>
  <author>
    <name>SeungMinYoon</name>
    <uri>http://localhost:4000/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="http://localhost:4000/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="http://localhost:4000/"/>
  <generator uri="https://jekyllrb.com/" version="4.3.1">Jekyll</generator>
  <rights> © 2023 SeungMinYoon </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>Android 구글 로그인 구현하기</title>
    <link href="http://localhost:4000/posts/Android-Google-Login/" rel="alternate" type="text/html" title="Android 구글 로그인 구현하기" />
    <published>2023-10-30T20:00:00+09:00</published>
  
    <updated>2023-10-30T20:00:00+09:00</updated>
  
    <id>http://localhost:4000/posts/Android-Google-Login/</id>
    <content src="http://localhost:4000/posts/Android-Google-Login/" />
    <author>
      <name>yoonmin</name>
    </author>

  
    
    <category term="Android" />
    
    <category term="라이브러리" />
    
  

  
    <summary>
      





      사전 준비

안드로이드에서 구글 로그인을 구현하기 위해서는 준비해야 될 게 몇 가지가 있습니다. 구글 클라우드에 들어가서 OAuth 클라이언트 아이디를 만들고 그 과정에서 본인의 앱을 등록해야 합니다. 그러므로 구체적으로 무엇을 먼저 준비해야 하는지 알아보겠습니다.

구글 클라우드에서 클라이언트 아이디 생성


  
    구글 클라우드에 들어가서 오른쪽 상단의 콘솔 을 클릭합니다.
  
  
    API 및 서비스로 들어갑니다. (만약 프로젝트가 없다면 새 프로젝트부터 만들고 시작)
  
  
    왼쪽에 메뉴가 다섯 가지가 존재하는데 거기서 사용자 인증 정보를 클릭합니다.
  
  
    + 사용자 인증 정보 만들기 를 눌러서 OAuth 클라이언트 ID 를 클릭해서 아이디를 생성합니다. 여기서...
    </summary>
  

  </entry>

  
  <entry>
    <title>(프로그래머스 | Kotlin) - 카드 짝 맞추기</title>
    <link href="http://localhost:4000/posts/KotlinAlgorithm5/" rel="alternate" type="text/html" title="(프로그래머스 | Kotlin) - 카드 짝 맞추기" />
    <published>2023-10-28T22:00:00+09:00</published>
  
    <updated>2023-10-29T21:23:47+09:00</updated>
  
    <id>http://localhost:4000/posts/KotlinAlgorithm5/</id>
    <content src="http://localhost:4000/posts/KotlinAlgorithm5/" />
    <author>
      <name>yoonmin</name>
    </author>

  
    
    <category term="CS" />
    
    <category term="알고리즘 문제" />
    
  

  
    <summary>
      





      해결 방법

이 문제의 핵심은 그냥 구현, 또 구현, 그리고 또 구현이다. 막 엄청 수준이 높은 알고리즘을 요구하는 것이 아닌 기본적인 알고리즘 여러 개를 가지고 복잡한 구현을 요구한다. 그래서 이 문제를 풀면서 굉장한 피로감을 느꼈다… 나같은 경우에는 백트래킹, 너비 우선 탐색, 그리디 이 세 가지를 중심으로 구현을 진행했다. 해당 알고리즘을 사용한 이유는 다음과 같다.

1. 최소 탐색을 위해서는 가능한 뒤집는 순서 조합을 모두 구해서 계산해야 한다.

만약 보드판 위에 1 2 3 이렇게 세 종류의 카드가 존재한다면 가능한 뒤집는 순서의 갯수는 6가지다. 이 6가지 순서쌍에서 최소 탐색을 할 수 있는 순서쌍이 존재하기 때문에 모든 순서쌍을 계산해서 최소값을 찾는 방식으로 진행한다.


  1 -&amp;g...
    </summary>
  

  </entry>

  
  <entry>
    <title>(프로그래머스 | C++) - 숫자 블록</title>
    <link href="http://localhost:4000/posts/KotlinAlgorithm4/" rel="alternate" type="text/html" title="(프로그래머스 | C++) - 숫자 블록" />
    <published>2023-10-16T20:00:00+09:00</published>
  
    <updated>2023-10-23T23:33:20+09:00</updated>
  
    <id>http://localhost:4000/posts/KotlinAlgorithm4/</id>
    <content src="http://localhost:4000/posts/KotlinAlgorithm4/" />
    <author>
      <name>yoonmin</name>
    </author>

  
    
    <category term="CS" />
    
    <category term="알고리즘 문제" />
    
  

  
    <summary>
      





      해결 방법

이 문제의 핵심은 가장 큰 약수를 구하는 데 있다.  문제에서 블록의 번호가 n 이고 해당 블록은 n*2 n*3 … 이렇게 설치를 한다. 이것은 곧 약수가 됨을 의미한다. 예를 들어서 구간 10 에 설치될 블록의 번호 무엇일까? 바로  5 다. 왜 이렇게 나오는 것일까? 구간이 가지고 있는 약수들 중에서 본인을 제외한 가장 큰 숫자가 설치될 블록 번호이기 때문이다.

10 의 약수는 1, 2, 5, 10 인데 약수 1 부터 살펴보면 1*10 = 10 인 것을 알 수 있고 n=1 로 표현이 가능하다. 그래서 처음에는 구간 10 에 1 블록이 설치된다.  그 다음 블록 번호는 2 다. 마찬가지로 2*5=10 인 것을 알 수 있고 n=2 로 표현이 가능하다. 따라서 이미 설치된 1 블록에 2 블...
    </summary>
  

  </entry>

  
  <entry>
    <title>(프로그래머스 | Kotlin) - 이모티콘 할인행사</title>
    <link href="http://localhost:4000/posts/KotlinAlgorithm3/" rel="alternate" type="text/html" title="(프로그래머스 | Kotlin) - 이모티콘 할인행사" />
    <published>2023-10-11T20:00:00+09:00</published>
  
    <updated>2023-10-11T20:00:00+09:00</updated>
  
    <id>http://localhost:4000/posts/KotlinAlgorithm3/</id>
    <content src="http://localhost:4000/posts/KotlinAlgorithm3/" />
    <author>
      <name>yoonmin</name>
    </author>

  
    
    <category term="CS" />
    
    <category term="알고리즘 문제" />
    
  

  
    <summary>
      





      해결방법

이 문제의 핵심은 emoticons 배열에 담겨 있는 이모티콘들의 할인율을 배정하는 것이다. 각 이모티콘은 각각 10, 20, 30, 40 퍼센트로 네 가지 할인율을 가질 수 있다. 따라서 각 이모티콘은 네 가지 중에서 하나의 할인율을 가진다. emoticons 의 최대 길이가 7 이므로 나올 수 있는 이모티콘들의 할인율의 경우의 수는 최대 4^7 개다.

나올 수 있는 최대 경우의 수가 4의 7승이라면 모든 경우를 탐색해도 지장이 없는 크기다. 따라서 완전 탐색을 통해 문제에서 요구하는 최대 효율을 가진 경우의 수(최대 효율을 내는 할인율 조합)를 찾을 수 있다. 완전 탐색을 위해서 모든 경우의 수를 구해야 하므로 백트래킹을 이용하여 나올 수 있는 모든 할인율 조합을 배열에 저장한다.

모...
    </summary>
  

  </entry>

  
  <entry>
    <title>(프로그래머스 | Kotlin) - 억억단을 외우자</title>
    <link href="http://localhost:4000/posts/KotlinAlgorithm2/" rel="alternate" type="text/html" title="(프로그래머스 | Kotlin) - 억억단을 외우자" />
    <published>2023-10-10T16:00:00+09:00</published>
  
    <updated>2023-10-11T20:18:32+09:00</updated>
  
    <id>http://localhost:4000/posts/KotlinAlgorithm2/</id>
    <content src="http://localhost:4000/posts/KotlinAlgorithm2/" />
    <author>
      <name>yoonmin</name>
    </author>

  
    
    <category term="CS" />
    
    <category term="알고리즘 문제" />
    
  

  
    <summary>
      





      해결 방법

이 문제의 핵심은 약수의 개수를 구하는 데 있다.  특정 숫자의 약수 개수를 알아야 등장 빈도를 알 수 있기 때문이다. 예를 들어서 숫자 4 를 예시로 들어보겠다. 억억단 예시 사진을 보면 해당 숫자가 세 번 등장하는데 그 이유가 구구단, 1단부터 e 단까지를 행렬로 표현해서 1X4 4X1 2X2 이렇게 나오기 때문이다.

그럼 여기서 대충 약수와 관련이 있다는 것을 눈치챌 수 있다. 4 의 약수는 총 세 개, 1, 2, 4 이다. 가운데를 기준으로 특정 위치에 있는 숫자는 자신의 반대쪽에 있는 숫자와 곱을 하면 4 가 된다. 그래서 원래는 4 가 두 개가 나오는 것이 맞지만 억억단은 행과 열 둘 다 구구단이 존재하기 때문에 동일 숫자 곱(2X2)을 제외하고 각각 2배를 해줘야 한다. 따라...
    </summary>
  

  </entry>

</feed>


