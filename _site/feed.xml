

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>http://localhost:4000/</id>
  <title>Yoon-Min</title>
  <subtitle>모르는 게 많으니까 기록하는 공간</subtitle>
  <updated>2024-08-29T22:20:55+09:00</updated>
  <author>
    <name>SeungMinYoon</name>
    <uri>http://localhost:4000/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="http://localhost:4000/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="http://localhost:4000/"/>
  <generator uri="https://jekyllrb.com/" version="4.3.1">Jekyll</generator>
  <rights> © 2024 SeungMinYoon </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>Android Compose Navigation 01 - 컴포즈 네비게이션 소개</title>
    <link href="http://localhost:4000/posts/ComposeNavigationInro/" rel="alternate" type="text/html" title="Android Compose Navigation 01 - 컴포즈 네비게이션 소개" />
    <published>2024-08-29T00:00:00+09:00</published>
  
    <updated>2024-08-29T00:00:00+09:00</updated>
  
    <id>http://localhost:4000/posts/ComposeNavigationInro/</id>
    <content src="http://localhost:4000/posts/ComposeNavigationInro/" />
    <author>
      <name>yoonmin</name>
    </author>

  
    
    <category term="Android" />
    
    <category term="라이브러리" />
    
  

  
    <summary>
      





      Unsplash의Katie Drazdauskaite

​

Compose Navigation 포스팅 현황


  Android Compose Navigation 01 - 컴포즈 네비게이션 소개
  Android Compose Navigation 02 - NavGraph 생성과정 (예정)
  Android Compose Navigation 03 - Navigator (예정)


​

Intro

화면 이동은 모바일 애플리케이션에서 중요한 요소입니다. 당장 우리가 일상에서 사용하는 앱을 살펴봐도 단순히 하나의 화면만 있는 것이 아닌 여러 화면을 통해 사용자에게 다양한 서비스를 제공하는 것을 볼 수 있습니다. 모바일 운영체제중 하나인 Android도 마찬가지입니다.

그래서 Android는 이러한 화면 이동...
    </summary>
  

  </entry>

  
  <entry>
    <title>GitHub Blog 간편하고 빠르게 꾸며보자 - 깃허브 블로그 커스터마이징 팁</title>
    <link href="http://localhost:4000/posts/GitHubBlogCustom/" rel="alternate" type="text/html" title="GitHub Blog 간편하고 빠르게 꾸며보자 - 깃허브 블로그 커스터마이징 팁" />
    <published>2024-08-23T00:00:00+09:00</published>
  
    <updated>2024-08-23T21:44:05+09:00</updated>
  
    <id>http://localhost:4000/posts/GitHubBlogCustom/</id>
    <content src="http://localhost:4000/posts/GitHubBlogCustom/" />
    <author>
      <name>yoonmin</name>
    </author>

  
    
    <category term="블로그" />
    
    <category term="Github 블로그 만들기" />
    
  

  
    <summary>
      





      Unsplash의Krishdiphong Prayoonwongkasem

Intro

깃허브 블로그의 장점중 하나는 블로그 테마를 본인 입맛대로 커스터마이징할 수 있다는 것입니다. 깃허브 블로그를 제작하는 과정은 본인이 마음에 드는 템플릿(테마) 파일을 받아서 초기화를 진행한 후에 깃허브를 통해 배포하는 것이 일반적이라 봅니다.

블로그를 오픈하는 과정하는 설명대로 따라가면 수월하게 할 수 있습니다만 이후의 블로그 관리는 조금 어려울 수 있습니다. 아이러니하게도 제가 블로그 관리에서 가장 어려움을 느꼈던 부분은 깃허브 블로그의 최고 장점이라 할 수 있는 커스터마이징 부분이었습니다.

아무래도 모바일 개발을 주력으로 하다 보니 웹 개발과 관련된 개념에 무지했고 이 때문에 깃허브 블로그 테마 폴더 구조 파악...
    </summary>
  

  </entry>

  
  <entry>
    <title>Android - 내부 동작으로 살펴보는 LiveData 값 설정부터 전달까지 과정</title>
    <link href="http://localhost:4000/posts/AndroidLiveDataSetValue/" rel="alternate" type="text/html" title="Android - 내부 동작으로 살펴보는 LiveData 값 설정부터 전달까지 과정" />
    <published>2024-08-18T00:00:00+09:00</published>
  
    <updated>2024-08-18T17:05:16+09:00</updated>
  
    <id>http://localhost:4000/posts/AndroidLiveDataSetValue/</id>
    <content src="http://localhost:4000/posts/AndroidLiveDataSetValue/" />
    <author>
      <name>yoonmin</name>
    </author>

  
    
    <category term="Android" />
    
    <category term="라이브러리" />
    
  

  
    <summary>
      





      사진: Unsplash의Jr Korpa

Intro

안드로이드의 LiveData 라이브러리를 사용하다 보면 라이브 데이터를 구독하고 있는 컴포넌트가 어떻게 값 변경에 대한 알림을 받는지 궁금할 수 있습니다. 저도 해당 라이브러리를 사용하면서 이 부분이 궁금했습니다. 그래서 라이브 데이터의 내부 코드를 분석하여 이를 정리하고자 합니다.

​

Observe



라이브 데이터는 보통 ViewModel 에서 생성 및 업데이트를 관리합니다. 그리고 이러한 변경사항을 라이브 데이터의 구독자인 액티비티 혹은 프래그먼트가 전달받습니다. 이러한 알림 수신이 가능한 이유는 라이브 데이터가 가지고 있는 observe 함수 덕분입니다.



라이브 데이터를 구독할 수 있는 observe 메서드는 라이브 데이터 클래스 ...
    </summary>
  

  </entry>

  
  <entry>
    <title>Android - 내부 동작으로 살펴보는 LiveData의 생명주기(Lifecycle) 인식 원리</title>
    <link href="http://localhost:4000/posts/AndroidLiveDataLifecycle/" rel="alternate" type="text/html" title="Android - 내부 동작으로 살펴보는 LiveData의 생명주기(Lifecycle) 인식 원리" />
    <published>2024-08-02T00:00:00+09:00</published>
  
    <updated>2024-08-02T00:00:00+09:00</updated>
  
    <id>http://localhost:4000/posts/AndroidLiveDataLifecycle/</id>
    <content src="http://localhost:4000/posts/AndroidLiveDataLifecycle/" />
    <author>
      <name>yoonmin</name>
    </author>

  
    
    <category term="Android" />
    
    <category term="라이브러리" />
    
  

  
    <summary>
      





      Unsplash의Nitish Meena

Intro

LiveData 는 관찰 가능한 UI 데이터 홀더 클래스입니다. 라이브 데이터는 안드로이드의 수명주기를 인식하여 수명주기에 맞춰 동작한다는 특징을 가지고 있어서 UI Layer에서 UI 데이터를 보유하는 역할을 수행합니다.

그런데 여기서 한 가지 궁금증이 생깁니다. 라이브 데이터가 안드로이드의 생명주기에 맞춰서 동작한다는 것은 알겠는데 어떻게 인식을 하는 걸까요? 이번 포스팅은 그 원리를 알아보는 시간을 가지고자 합니다.

​

Lifecycle

라이브 데이터를 분석하기 전에 먼저 생명주기에 대해서 알 필요가 있습니다. 보통 안드로이드에서 생명주기라 하면 액티비티 혹은 프래그먼트의 생명주기를 떠올릴 것입니다.

그 생명주기의 근간이 되는 클래스가...
    </summary>
  

  </entry>

  
  <entry>
    <title>Android - 화면 구성 변환에도 ViewModel 데이터가 보존될 수 있는 이유</title>
    <link href="http://localhost:4000/posts/ViewModelClear/" rel="alternate" type="text/html" title="Android - 화면 구성 변환에도 ViewModel 데이터가 보존될 수 있는 이유" />
    <published>2024-07-23T00:00:00+09:00</published>
  
    <updated>2024-07-23T00:00:00+09:00</updated>
  
    <id>http://localhost:4000/posts/ViewModelClear/</id>
    <content src="http://localhost:4000/posts/ViewModelClear/" />
    <author>
      <name>yoonmin</name>
    </author>

  
    
    <category term="Android" />
    
    <category term="라이브러리" />
    
  

  
    <summary>
      





      

Intro

뷰모델은 ViewModelStoreOwner 가 사라질 때까지 메모리에 남아 있습니다. 덕분에 액티비티의 화면 구성 변경 후에도 뷰모델을 유지할 수 있습니다. 뷰모델이 파괴되는 조건은 다음과 같이 세 가지가 있습니다.


  액티비티가 완료될 때 -&amp;gt; onDestroy
  프래그먼트가 분리될 때
  네비게이션 백 스택에서 삭제될 때




그런데 여기서 궁금한 점이 생겼습니다. 대표적인 구성 변경인 화면 전환이 발생하면 분명 액티비티는 onDestroy 후에 onCreate 으로 재생성을 하는 과정을 거치는데 뷰모델의 파괴 조건에 따르면 이때 뷰모델도 파괴되어야 합니다. 하지만 구성 변경이 발생하면 뷰모델은  Clear 되지 않습니다.

안드로이드는 구성 변경과 같이 액티비티가 잠...
    </summary>
  

  </entry>

</feed>


