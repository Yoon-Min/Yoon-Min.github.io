

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>http://localhost:4000/</id>
  <title>Yoon-Min</title>
  <subtitle>모르는 게 많으니까 기록하는 공간</subtitle>
  <updated>2024-08-23T21:43:38+09:00</updated>
  <author>
    <name>SeungMinYoon</name>
    <uri>http://localhost:4000/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="http://localhost:4000/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="http://localhost:4000/"/>
  <generator uri="https://jekyllrb.com/" version="4.3.1">Jekyll</generator>
  <rights> © 2024 SeungMinYoon </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>GitHub Blog 간편하고 빠르게 꾸며보자 - 깃허브 블로그 커스터마이징 팁</title>
    <link href="http://localhost:4000/posts/GitHubBlogCustom/" rel="alternate" type="text/html" title="GitHub Blog 간편하고 빠르게 꾸며보자 - 깃허브 블로그 커스터마이징 팁" />
    <published>2024-08-23T00:00:00+09:00</published>
  
    <updated>2024-08-23T20:25:12+09:00</updated>
  
    <id>http://localhost:4000/posts/GitHubBlogCustom/</id>
    <content src="http://localhost:4000/posts/GitHubBlogCustom/" />
    <author>
      <name>yoonmin</name>
    </author>

  
    
    <category term="블로그" />
    
    <category term="Github 블로그 만들기" />
    
  

  
    <summary>
      





      Unsplash의Krishdiphong Prayoonwongkasem

Intro

깃허브 블로그의 장점중 하나는 블로그 테마를 본인 입맛대로 커스터마이징할 수 있다는 것입니다. 깃허브 블로그를 제작하는 과정은 본인이 마음에 드는 템플릿(테마) 파일을 받아서 초기화를 진행한 후에 깃허브를 통해 배포하는 것이 일반적이라 봅니다.

블로그를 오픈하는 과정하는 설명대로 따라가면 수월하게 할 수 있습니다만 이후의 블로그 관리는 조금 어려울 수 있습니다. 아이러니하게도 제가 블로그 관리에서 가장 어려움을 느꼈던 부분은 깃허브 블로그의 최고 장점이라 할 수 있는 커스터마이징 부분이었습니다.

아무래도 모바일 개발을 주력으로 하다 보니 웹 개발과 관련된 개념에 무지했고 이 때문에 깃허브 블로그 테마 폴더 구조 파악...
    </summary>
  

  </entry>

  
  <entry>
    <title>Android - 내부 동작으로 살펴보는 LiveData 값 설정부터 전달까지 과정</title>
    <link href="http://localhost:4000/posts/AndroidLiveDataSetValue/" rel="alternate" type="text/html" title="Android - 내부 동작으로 살펴보는 LiveData 값 설정부터 전달까지 과정" />
    <published>2024-08-18T00:00:00+09:00</published>
  
    <updated>2024-08-18T17:05:16+09:00</updated>
  
    <id>http://localhost:4000/posts/AndroidLiveDataSetValue/</id>
    <content src="http://localhost:4000/posts/AndroidLiveDataSetValue/" />
    <author>
      <name>yoonmin</name>
    </author>

  
    
    <category term="Android" />
    
    <category term="라이브러리" />
    
  

  
    <summary>
      





      사진: Unsplash의Jr Korpa

Intro

안드로이드의 LiveData 라이브러리를 사용하다 보면 라이브 데이터를 구독하고 있는 컴포넌트가 어떻게 값 변경에 대한 알림을 받는지 궁금할 수 있습니다. 저도 해당 라이브러리를 사용하면서 이 부분이 궁금했습니다. 그래서 라이브 데이터의 내부 코드를 분석하여 이를 정리하고자 합니다.

​

Observe



라이브 데이터는 보통 ViewModel 에서 생성 및 업데이트를 관리합니다. 그리고 이러한 변경사항을 라이브 데이터의 구독자인 액티비티 혹은 프래그먼트가 전달받습니다. 이러한 알림 수신이 가능한 이유는 라이브 데이터가 가지고 있는 observe 함수 덕분입니다.



라이브 데이터를 구독할 수 있는 observe 메서드는 라이브 데이터 클래스 ...
    </summary>
  

  </entry>

  
  <entry>
    <title>Android - 내부 동작으로 살펴보는 LiveData의 생명주기(Lifecycle) 인식 원리</title>
    <link href="http://localhost:4000/posts/AndroidLiveDataLifecycle/" rel="alternate" type="text/html" title="Android - 내부 동작으로 살펴보는 LiveData의 생명주기(Lifecycle) 인식 원리" />
    <published>2024-08-02T00:00:00+09:00</published>
  
    <updated>2024-08-02T00:00:00+09:00</updated>
  
    <id>http://localhost:4000/posts/AndroidLiveDataLifecycle/</id>
    <content src="http://localhost:4000/posts/AndroidLiveDataLifecycle/" />
    <author>
      <name>yoonmin</name>
    </author>

  
    
    <category term="Android" />
    
    <category term="라이브러리" />
    
  

  
    <summary>
      





      Unsplash의Nitish Meena

Intro

LiveData 는 관찰 가능한 UI 데이터 홀더 클래스입니다. 라이브 데이터는 안드로이드의 수명주기를 인식하여 수명주기에 맞춰 동작한다는 특징을 가지고 있어서 UI Layer에서 UI 데이터를 보유하는 역할을 수행합니다.

그런데 여기서 한 가지 궁금증이 생깁니다. 라이브 데이터가 안드로이드의 생명주기에 맞춰서 동작한다는 것은 알겠는데 어떻게 인식을 하는 걸까요? 이번 포스팅은 그 원리를 알아보는 시간을 가지고자 합니다.

​

Lifecycle

라이브 데이터를 분석하기 전에 먼저 생명주기에 대해서 알 필요가 있습니다. 보통 안드로이드에서 생명주기라 하면 액티비티 혹은 프래그먼트의 생명주기를 떠올릴 것입니다.

그 생명주기의 근간이 되는 클래스가...
    </summary>
  

  </entry>

  
  <entry>
    <title>Android - 화면 구성 변환에도 ViewModel 데이터가 보존될 수 있는 이유</title>
    <link href="http://localhost:4000/posts/ViewModelClear/" rel="alternate" type="text/html" title="Android - 화면 구성 변환에도 ViewModel 데이터가 보존될 수 있는 이유" />
    <published>2024-07-23T00:00:00+09:00</published>
  
    <updated>2024-07-23T00:00:00+09:00</updated>
  
    <id>http://localhost:4000/posts/ViewModelClear/</id>
    <content src="http://localhost:4000/posts/ViewModelClear/" />
    <author>
      <name>yoonmin</name>
    </author>

  
    
    <category term="Android" />
    
    <category term="라이브러리" />
    
  

  
    <summary>
      





      

Intro

뷰모델은 ViewModelStoreOwner 가 사라질 때까지 메모리에 남아 있습니다. 덕분에 액티비티의 화면 구성 변경 후에도 뷰모델을 유지할 수 있습니다. 뷰모델이 파괴되는 조건은 다음과 같이 세 가지가 있습니다.


  액티비티가 완료될 때 -&amp;gt; onDestroy
  프래그먼트가 분리될 때
  네비게이션 백 스택에서 삭제될 때




그런데 여기서 궁금한 점이 생겼습니다. 대표적인 구성 변경인 화면 전환이 발생하면 분명 액티비티는 onDestroy 후에 onCreate 으로 재생성을 하는 과정을 거치는데 뷰모델의 파괴 조건에 따르면 이때 뷰모델도 파괴되어야 합니다. 하지만 구성 변경이 발생하면 뷰모델은  Clear 되지 않습니다.

안드로이드는 구성 변경과 같이 액티비티가 잠...
    </summary>
  

  </entry>

  
  <entry>
    <title>Google I/O Android Korea 2024 후기</title>
    <link href="http://localhost:4000/posts/GoogleIOAndroid/" rel="alternate" type="text/html" title="Google I/O Android Korea 2024 후기" />
    <published>2024-07-23T00:00:00+09:00</published>
  
    <updated>2024-07-23T00:00:00+09:00</updated>
  
    <id>http://localhost:4000/posts/GoogleIOAndroid/</id>
    <content src="http://localhost:4000/posts/GoogleIOAndroid/" />
    <author>
      <name>yoonmin</name>
    </author>

  
    
    <category term="블로그" />
    
    <category term="회고록" />
    
  

  
    <summary>
      





      

처음 가보는 Android 행사

여태까지 Android를 다루는 행사에 참여해본 적이 없었는데 Google I/O를 통해 새로운 경험을 하게 되어서 매우 즐거웠다. 안드로이드 공부를 오랜만에 다시 시작한 탓에 내외부로 바뀐 것들에 대한 파악이 필요했었는데 마침 GDG에서 이를 알려주는 행사를 열어서 바로 찾아가게 된 것이 이번 행사의 참가 계기가 되겠다.

Android 행사 참여는 처음이지만 행사를 진행하는 구글 스타트업 캠퍼스는 너무나 익숙했다. 예전에 GDSC 활동을 할 때 잡페어 행사에 참가한 적이 있는데 그 행사를 구글 스타트업 캠퍼스에서 진행했었다. 그래서 한 번 가본 장소기 때문에 행사장은 문제 없이 잘 찾아갈 수 있었다.

분위기는 굉장히 자유롭고 편했다. 중간마다 간단한 마실 것과...
    </summary>
  

  </entry>

</feed>


