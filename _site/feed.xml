

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>http://localhost:4000/</id>
  <title>Yoon-Min</title>
  <subtitle>부족한 개발 실력을 키우고 다른 사람들에게 도움이 되고 싶습니다.</subtitle>
  <updated>2023-11-22T19:27:22+09:00</updated>
  <author>
    <name>SeungMinYoon</name>
    <uri>http://localhost:4000/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="http://localhost:4000/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="http://localhost:4000/"/>
  <generator uri="https://jekyllrb.com/" version="4.3.1">Jekyll</generator>
  <rights> © 2023 SeungMinYoon </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>(프로그래머스 | Kotlin) - 전력망을 둘로 나누기</title>
    <link href="http://localhost:4000/posts/KotlinAlgorithm9/" rel="alternate" type="text/html" title="(프로그래머스 | Kotlin) - 전력망을 둘로 나누기" />
    <published>2023-11-21T12:00:00+09:00</published>
  
    <updated>2023-11-21T12:00:00+09:00</updated>
  
    <id>http://localhost:4000/posts/KotlinAlgorithm9/</id>
    <content src="http://localhost:4000/posts/KotlinAlgorithm9/" />
    <author>
      <name>yoonmin</name>
    </author>

  
    
    <category term="CS" />
    
    <category term="알고리즘 문제" />
    
  

  
    <summary>
      





      해결 방법

특정 전선이 끊어지면 하나의 트리는 두 개의 그룹으로 나뉘게 된다. 따라서 두 개의 그룹 각각, DFS 혹은 BFS 를 이용해서 그룹 내 노드의 개수를 카운트한다. 나는 BFS 를 이용해서 노드의 개수를 구했다.

그리고 탐색 시작점은 제거한 전선과 연결된 노드로 지정했다. 첫 번째 입출력 예제 그림에서 4 와  7 이 연결된 전선을 끊은 경우를 보여주는데 이때 생긴 두 개의 그룹에서 탐색 시작점은 4,  7 이 된다. 4 에서 탐색을 시작하면 6개, 7 에서 탐색을 시작하면 3개가 카운드된다.

따라서 모든 전선에 대해서 위 방법을 적용시켜 비교해야 한다. 예제에서 전선 정보가 담긴 wires 을 줬기 때문에 이 배열의 각 원소(전선)에 대해서 트리를 두 개로 나누고 각 트리마다 송전탑 ...
    </summary>
  

  </entry>

  
  <entry>
    <title>(프로그래머스 | Kotlin) - 호텔 대실</title>
    <link href="http://localhost:4000/posts/KotlinAlgorithm8/" rel="alternate" type="text/html" title="(프로그래머스 | Kotlin) - 호텔 대실" />
    <published>2023-11-21T12:00:00+09:00</published>
  
    <updated>2023-11-21T12:00:00+09:00</updated>
  
    <id>http://localhost:4000/posts/KotlinAlgorithm8/</id>
    <content src="http://localhost:4000/posts/KotlinAlgorithm8/" />
    <author>
      <name>yoonmin</name>
    </author>

  
    
    <category term="CS" />
    
    <category term="알고리즘 문제" />
    
  

  
    <summary>
      





      해결 방법

이 문제의 핵심은 그리디 알고리즘을 이용하는 것이다. 우선 문제에서 예약 시작 시간과 종료 시간이 여러 개 담긴 배열을 줬으므로 해당 예약 시작 시간을 기준으로 배열을 정렬시킨다. 그리고 정렬된 배열을 가지고 반복문을 돌려서 현재 원소의 예약 시작 시간보다 10분 더 적은 종료 시간이 있는 방 번호를 찾는다.

예를 들어서 현재 예약이 잡힌 방의 갯수를 n 개라고 가정하자. 그럼 방의 번호는 현재 1 번부터 n 번까지 존재한다. 정렬된 배열의 반복문을 돌렸을 때 가장 좋은 예약 방법은 기존에 존재하는 방에 예약을 거는 것이다. 그렇게 하기 위해선 현존하는 방들 중에서 마지막으로 예약된 시간대의 종료 시간이 현재 원소의 시작 시간보다 10분 더 적어야 한다.

그래서 모든 방을 탐색해서 예약...
    </summary>
  

  </entry>

  
  <entry>
    <title>(프로그래머스 | Kotlin) - 매칭 점수</title>
    <link href="http://localhost:4000/posts/KotlinAlgorithm7/" rel="alternate" type="text/html" title="(프로그래머스 | Kotlin) - 매칭 점수" />
    <published>2023-11-19T21:00:00+09:00</published>
  
    <updated>2023-11-19T21:00:00+09:00</updated>
  
    <id>http://localhost:4000/posts/KotlinAlgorithm7/</id>
    <content src="http://localhost:4000/posts/KotlinAlgorithm7/" />
    <author>
      <name>yoonmin</name>
    </author>

  
    
    <category term="CS" />
    
    <category term="알고리즘 문제" />
    
  

  
    <summary>
      





      해결 방법

정말 보자마자 머리가 지끈거리는 문제였다. 카카오 코테 문제를 풀어보면서 문자열 처리 로직을 많이 작성했었는데 설마 html 형식을 통째로 주는 건 상상도 못했다. 필요한 건 크게 url, 키워드, 외부 링크, 이렇게 세 가지다.

여기서 문제는 해당 세 가지를 구하기 위해서 정규식을 사용해야 하는데 나는 정규식을 사용할 때 항상 검색해서 복붙한 게 전부여서 식을 어떻게 작성해야 하는지 몰랐다. 그래서 검색을 해서 몇몇 정규식을 참고했다.

1. 현재 페이지의 URL

"(&amp;lt;meta property=\"og:url\" content=\"(\\S*)//(\\S*)\"/&amp;gt;)"


페이지의 url 을 구할 때 중요한 점은 문제에서 준 양식과 정확히 일치해야 한다는 것이다. 보니까 ur...
    </summary>
  

  </entry>

  
  <entry>
    <title>(프로그래머스 | Kotlin) - 수식 최대화</title>
    <link href="http://localhost:4000/posts/KotlinAlgorithm6/" rel="alternate" type="text/html" title="(프로그래머스 | Kotlin) - 수식 최대화" />
    <published>2023-11-15T12:00:00+09:00</published>
  
    <updated>2023-11-15T12:00:00+09:00</updated>
  
    <id>http://localhost:4000/posts/KotlinAlgorithm6/</id>
    <content src="http://localhost:4000/posts/KotlinAlgorithm6/" />
    <author>
      <name>yoonmin</name>
    </author>

  
    
    <category term="CS" />
    
    <category term="알고리즘 문제" />
    
  

  
    <summary>
      





      해결 방법

뭔가 풀이 방법이 다양할 것 같은 문제인데 나는 재귀를 이용해서 해결했다. 연산 기호가 최대 세 개인데 연산 우선순위를 리스트로 표현했다. 예를 들어서 표현식에서 사용된 연산 기호가 * - , 2개라면 만들 수 있는 우선순위 조합은 2개, [[*, -], [-, *]]  이렇게 리스트로 표현이 가능하다. 인덱스가 클수록 연산 우선순위가 높다는 뜻이다.

이런 식으로 만들 수 있는 연산 우선순위를 모두 만들고 모든 경우에 대해 식을 계산하고 결과값을 비교해서 가장 큰 값을 리턴하면 문제 해결이 가능하다. 그런데 문제는 식을 계산하는 방법이다. 여기서 풀이 방법이 다양하게 갈릴 것 같은데 내가 푼 방법은 다음과 같다.

​

1. 나올 수 있는 연산 우선순위 조합 모두 구하기

"100-200...
    </summary>
  

  </entry>

  
  <entry>
    <title>Kotlin Generic (1) 제네릭 클래스와 함수, 그리고 변성</title>
    <link href="http://localhost:4000/posts/Kotlin-Generic/" rel="alternate" type="text/html" title="Kotlin Generic (1) 제네릭 클래스와 함수, 그리고 변성" />
    <published>2023-11-09T12:00:00+09:00</published>
  
    <updated>2023-11-09T16:18:22+09:00</updated>
  
    <id>http://localhost:4000/posts/Kotlin-Generic/</id>
    <content src="http://localhost:4000/posts/Kotlin-Generic/" />
    <author>
      <name>yoonmin</name>
    </author>

  
    
    <category term="CS" />
    
    <category term="프로그래밍 언어" />
    
  

  
    <summary>
      





      Kotlin도 Java의 제네릭 기능을 제공한다.


  “Classes in Kotlin can have type parameters, just like in Java:” - Kotlin 공식 문서


코틀린의 클래스는 자바와 마찬가지로 타입 파라미터를 가질 수 있습니다. 제네릭을 사용함으로써 컴파일 타임에 타입 안전성을 관리할 수 있고 여러 타입에 대응하여 코드를 재사용하는 이점을 얻을 수 있습니다.

코틀린 역시  &amp;lt;&amp;gt; 기호를 이용한 제네릭 기능을 제공합니다. 다음 Box 클래스는 제네릭을 사용하여 만들어졌기 때문에  Int , String, Float 등의 다양한 타입을 가질 수 있습니다.

class Box&amp;lt;T&amp;gt;(t: T) {
    var value = t
}


val...
    </summary>
  

  </entry>

</feed>


