

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>http://localhost:4000/</id>
  <title>Yoon-Min</title>
  <subtitle>부족한 개발 실력을 키우고 다른 사람들에게 도움이 되고 싶습니다.</subtitle>
  <updated>2023-10-10T16:44:01+09:00</updated>
  <author>
    <name>SeungMinYoon</name>
    <uri>http://localhost:4000/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="http://localhost:4000/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="http://localhost:4000/"/>
  <generator uri="https://jekyllrb.com/" version="4.3.1">Jekyll</generator>
  <rights> © 2023 SeungMinYoon </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>(프로그래머스 | Kotlin) - 억억단을 외우자</title>
    <link href="http://localhost:4000/posts/KotlinAlgorithm2/" rel="alternate" type="text/html" title="(프로그래머스 | Kotlin) - 억억단을 외우자" />
    <published>2023-10-10T16:00:00+09:00</published>
  
    <updated>2023-10-10T16:00:00+09:00</updated>
  
    <id>http://localhost:4000/posts/KotlinAlgorithm2/</id>
    <content src="http://localhost:4000/posts/KotlinAlgorithm2/" />
    <author>
      <name>yoonmin</name>
    </author>

  
    
    <category term="CS" />
    
    <category term="알고리즘 문제" />
    
  

  
    <summary>
      





      해결 방법

이 문제의 핵심은 약수의 개수를 구하는 데 있다.  특정 숫자의 약수 개수를 알아야 등장 빈도를 알 수 있기 때문이다. 예를 들어서 숫자 4 를 예시로 들어보겠다. 억억단 예시 사진을 보면 해당 숫자가 세 번 등장하는데 그 이유가 구구단, 1단부터 e 단까지를 행렬로 표현해서 1X4 4X1 2X2 이렇게 나오기 때문이다.

그럼 여기서 대충 약수와 관련이 있다는 것을 눈치챌 수 있다. 4 의 약수는 총 세 개, 1, 2, 4 이다. 가운데를 기준으로 특정 위치에 있는 숫자는 자신의 반대쪽에 있는 숫자와 곱을 하면 4 가 된다. 그래서 원래는 4 가 두 개가 나오는 것이 맞지만 억억단은 행과 열 둘 다 구구단이 존재하기 때문에 동일 숫자 곱(2X2)을 제외하고 각각 2배를 해줘야 한다. 따라...
    </summary>
  

  </entry>

  
  <entry>
    <title>(프로그래머스 | Kotlin) - 요격 시스템</title>
    <link href="http://localhost:4000/posts/KotlinAlgorithm1/" rel="alternate" type="text/html" title="(프로그래머스 | Kotlin) - 요격 시스템" />
    <published>2023-10-09T22:00:00+09:00</published>
  
    <updated>2023-10-09T22:00:00+09:00</updated>
  
    <id>http://localhost:4000/posts/KotlinAlgorithm1/</id>
    <content src="http://localhost:4000/posts/KotlinAlgorithm1/" />
    <author>
      <name>yoonmin</name>
    </author>

  
    
    <category term="CS" />
    
    <category term="알고리즘 문제" />
    
  

  
    <summary>
      





      해결 방법

문제를 해석하면 특정 구간이 여러 개 주어지고 그 구간들을 전부 관통할 수 있는 최소의 폭격 미사일 수를 구해야 한다. 문제에서 그리디 알고리즘 문제를 좀 풀어봤다면 예시로 던져준 사진을 보자마자 그리디 문제임을 알아챘을 것이다. 따라서 이 문제는 그리디 알고리즘을 이용해서 해결하면 된다. 해결 순서는 다음과 같다.


  
    targets 내 특정 구간 i 에 대해서 targets[i][1] 을 기준으로 정렬한다.
  
  
    첫 폭격 미사일 설치 위치를 targets[0][1] 로 설정한다.

    var lastSpot = targets[0][1]
    
  
  
    반복문을 통해 정렬된 targets 내의 모든 원소들을 차례로 돌면서 현재 원소의 시작 위치가 la...
    </summary>
  

  </entry>

  
  <entry>
    <title>Android Navigation에 대해서 알아보자</title>
    <link href="http://localhost:4000/posts/Android-Navigation/" rel="alternate" type="text/html" title="Android Navigation에 대해서 알아보자" />
    <published>2023-05-05T00:00:00+09:00</published>
  
    <updated>2023-05-05T04:19:42+09:00</updated>
  
    <id>http://localhost:4000/posts/Android-Navigation/</id>
    <content src="http://localhost:4000/posts/Android-Navigation/" />
    <author>
      <name>yoonmin</name>
    </author>

  
    
    <category term="Android" />
    
    <category term="라이브러리" />
    
  

  
    <summary>
      





      Jetpack에서 제공하는 Navigation

내비게이션(Navigation)은 안드로이드 Jetpack에서 제공하는 라이브러리 중 하나입니다. 내비게이션은 말 그대로 탐색을 지원하는 라이브러리며 기존의 방식보다 화면 전환을 쉽고 빠르고 유연하게 도와줍니다. 아마 안드로이드 앱 개발을 시작한 지 얼마 안 됐다면 꼭 알아야 하는 라이브러리 중 하나이지 않을까 싶습니다. 그래서 이번 포스팅은 내비게이션 라이브러리가 무엇이고 왜 사용하며 어떻게 사용하는지 알아보겠습니다.

​

기존의 화면 전환 방식

안드로이드에서 UI를 제공할 수 있는 창은 Activity 와 이에 종속되어서 부분 UI를 나타내는 Fragment 입니다. 그래서 안드로이드 앱 내에서 화면 전환이라 하면 보통 다음과 같이 세 가지가 있습...
    </summary>
  

  </entry>

  
  <entry>
    <title>Android의 UI, 뷰(View) 그리고 레이아웃(ViewGroup)</title>
    <link href="http://localhost:4000/posts/Android-UI/" rel="alternate" type="text/html" title="Android의 UI, 뷰(View) 그리고 레이아웃(ViewGroup)" />
    <published>2023-04-06T12:00:00+09:00</published>
  
    <updated>2023-04-08T01:20:43+09:00</updated>
  
    <id>http://localhost:4000/posts/Android-UI/</id>
    <content src="http://localhost:4000/posts/Android-UI/" />
    <author>
      <name>yoonmin</name>
    </author>

  
    
    <category term="Android" />
    
    <category term="기본" />
    
  

  
    <summary>
      





      모바일 UI는 어떻게 구성되어 있는가?

예시로 우리가 스마트폰을 이용해서 배달의민족 앱을 이용할 때를 생각해 봅시다. 해당 앱에 접속을 해보면 여러 카테고리 버튼이 있고 밑으로 스크롤을 하면 여러 음식점들의 간략한 정보가 리스트 형식, 혹은 카드 형태로 제공됩니다.

특정 음식점을 클릭하면 해당 음식점에 대한 상세 페이지로 이동하게 되고 여기서는 가게에 대한 텍스트 정보, 음식 사진에 대한 이미지 정보, 메뉴들을 선택할 수 있는 체크박스, 해당 가게 정보를 저장할 수 있는 찜 버튼과 같은 다양한 상호작용 요소들을 볼 수 있습니다.


  이렇듯 모바일 UI는 하나의 화면 안에 사용자와 상호작용이 가능한 다양한 요소들이 존재합니다.


​

Android는 UI를 어떻게 제작하는가?

그렇다면 Andr...
    </summary>
  

  </entry>

  
  <entry>
    <title>Union-Find 유니온 파인드</title>
    <link href="http://localhost:4000/posts/Uinon-Find/" rel="alternate" type="text/html" title="Union-Find 유니온 파인드" />
    <published>2023-02-21T12:00:00+09:00</published>
  
    <updated>2023-02-21T16:45:22+09:00</updated>
  
    <id>http://localhost:4000/posts/Uinon-Find/</id>
    <content src="http://localhost:4000/posts/Uinon-Find/" />
    <author>
      <name>yoonmin</name>
    </author>

  
    
    <category term="CS" />
    
    <category term="알고리즘" />
    
  

  
    <summary>
      





      서로소 집합(disjoint-set)을 관리하는 자료 구조

다양한 원소들이 서로소 집합을 이루는 경우가 있습니다. 필요에 따라서 이 집합들을 이용하여 서로 합치거나 특정 원소를 통해 특정 집합을 탐색할 수도 있습니다. 유니온 파인드(union-find)는 그래프 알고리즘으로 서로소 집합을 관리하며 서로 다른 두 노드가 동일한 집합에 있는지 판별합니다.

유니온 파인드는 서로 다른 두 노드가 같은 집합에 있는지 판별하기 위해서 각 집합의 대표 원소를 참고합니다. 여기서 대표 원소라 함은 연결 리스트에서는 헤드가 되며 트리에서는 루트 노드가 해당됩니다. 두 노드가 속한 집합의 대표 원소를 찾아서 대표 원소가 서로 동일하면 같은 집합에 있는 걸로 판단하게 됩니다. 이러한 판단 과정에서 여러 집합들이 합쳐지...
    </summary>
  

  </entry>

</feed>


