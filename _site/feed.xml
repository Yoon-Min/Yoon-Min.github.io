

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>http://localhost:4000/</id>
  <title>Yoon-Min</title>
  <subtitle>부족한 개발 실력을 키우고 다른 사람들에게 도움이 되고 싶습니다.</subtitle>
  <updated>2023-12-05T00:04:27+09:00</updated>
  <author>
    <name>SeungMinYoon</name>
    <uri>http://localhost:4000/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="http://localhost:4000/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="http://localhost:4000/"/>
  <generator uri="https://jekyllrb.com/" version="4.3.1">Jekyll</generator>
  <rights> © 2023 SeungMinYoon </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>(프로그래머스 | Kotlin) - 2차원 동전 뒤집기</title>
    <link href="http://localhost:4000/posts/KotlinAlgorithm11/" rel="alternate" type="text/html" title="(프로그래머스 | Kotlin) - 2차원 동전 뒤집기" />
    <published>2023-11-23T12:00:00+09:00</published>
  
    <updated>2023-12-04T23:58:16+09:00</updated>
  
    <id>http://localhost:4000/posts/KotlinAlgorithm11/</id>
    <content src="http://localhost:4000/posts/KotlinAlgorithm11/" />
    <author>
      <name>yoonmin</name>
    </author>

  
    
    <category term="CS" />
    
    <category term="알고리즘 문제" />
    
  

  
    <summary>
      





      해결 방법

이 문제는 특정 행, 혹은 열을 뒤집어서 원하는 형태를 만드는 게 핵심이다. 어떤 행, 혹은 열을 뒤집는 순서가 중요한 것이 아니다. 어떤 행, 혹은 열의 상태를 어떻게 할 것인지(뒤집거나 그대로 두거나)가 중요하다.  M X N  형태에서 특정 열과 행의 상태를 결정하는 방식으로 로직을 짜면 된다.

​

뒷면, 앞면의 상태값을 비트로 표현해보자

문제 마지막에 보면 0 은 동전의 앞면, 1 은 동전의 뒷면을 의미한다. 그렇다면  0 1 을 비트 연산으로 처리해보자. 예를 들어서 2 X 2 형태라고 가정해보자. 행과 열은 각각 2개고 다음과 같이 표현할 수 있다.

두 개면 모두 앞면인 경우와 모두 뒷면 경우, 한쪽은 앞면 한쪽은 뒷면인 경우가 존재한다. 이를 비트 형식으로 표현하면 다음...
    </summary>
  

  </entry>

  
  <entry>
    <title>(프로그래머스 | C++) - 방금그곡</title>
    <link href="http://localhost:4000/posts/KotlinAlgorithm10/" rel="alternate" type="text/html" title="(프로그래머스 | C++) - 방금그곡" />
    <published>2023-11-23T12:00:00+09:00</published>
  
    <updated>2023-11-23T12:00:00+09:00</updated>
  
    <id>http://localhost:4000/posts/KotlinAlgorithm10/</id>
    <content src="http://localhost:4000/posts/KotlinAlgorithm10/" />
    <author>
      <name>yoonmin</name>
    </author>

  
    
    <category term="CS" />
    
    <category term="알고리즘 문제" />
    
  

  
    <summary>
      





      해결 방법

문제에서 주어진 조건을 가지고 시킨 것만 잘 수행하면 된다. musicinfos 에서는 "12:00,12:14,HELLO,CDEFGAB" 형식의 문자열을 원소로 가지고 있다. 이 문자열을 잘 분해해서 처리해야 하는데 순서는 다음과 같다.


  
    문자열을 , 기준으로 split 한 배열을 생성한다.  ["12:00", "12:14", "HELLO", "CDEFGAB"]

    vector&amp;lt;string&amp;gt; split(string str, char splitChar) {
    vector&amp;lt;string&amp;gt; result;
    istringstream iss(str);
    string buffer;
    while(getline(iss, buffer, split...
    </summary>
  

  </entry>

  
  <entry>
    <title>(프로그래머스 | Kotlin) - 전력망을 둘로 나누기</title>
    <link href="http://localhost:4000/posts/KotlinAlgorithm9/" rel="alternate" type="text/html" title="(프로그래머스 | Kotlin) - 전력망을 둘로 나누기" />
    <published>2023-11-21T12:00:00+09:00</published>
  
    <updated>2023-11-21T12:00:00+09:00</updated>
  
    <id>http://localhost:4000/posts/KotlinAlgorithm9/</id>
    <content src="http://localhost:4000/posts/KotlinAlgorithm9/" />
    <author>
      <name>yoonmin</name>
    </author>

  
    
    <category term="CS" />
    
    <category term="알고리즘 문제" />
    
  

  
    <summary>
      





      해결 방법

특정 전선이 끊어지면 하나의 트리는 두 개의 그룹으로 나뉘게 된다. 따라서 두 개의 그룹 각각, DFS 혹은 BFS 를 이용해서 그룹 내 노드의 개수를 카운트한다. 나는 BFS 를 이용해서 노드의 개수를 구했다.

그리고 탐색 시작점은 제거한 전선과 연결된 노드로 지정했다. 첫 번째 입출력 예제 그림에서 4 와  7 이 연결된 전선을 끊은 경우를 보여주는데 이때 생긴 두 개의 그룹에서 탐색 시작점은 4,  7 이 된다. 4 에서 탐색을 시작하면 6개, 7 에서 탐색을 시작하면 3개가 카운드된다.

따라서 모든 전선에 대해서 위 방법을 적용시켜 비교해야 한다. 예제에서 전선 정보가 담긴 wires 을 줬기 때문에 이 배열의 각 원소(전선)에 대해서 트리를 두 개로 나누고 각 트리마다 송전탑 ...
    </summary>
  

  </entry>

  
  <entry>
    <title>(프로그래머스 | Kotlin) - 호텔 대실</title>
    <link href="http://localhost:4000/posts/KotlinAlgorithm8/" rel="alternate" type="text/html" title="(프로그래머스 | Kotlin) - 호텔 대실" />
    <published>2023-11-21T12:00:00+09:00</published>
  
    <updated>2023-11-21T12:00:00+09:00</updated>
  
    <id>http://localhost:4000/posts/KotlinAlgorithm8/</id>
    <content src="http://localhost:4000/posts/KotlinAlgorithm8/" />
    <author>
      <name>yoonmin</name>
    </author>

  
    
    <category term="CS" />
    
    <category term="알고리즘 문제" />
    
  

  
    <summary>
      





      해결 방법

이 문제의 핵심은 그리디 알고리즘을 이용하는 것이다. 우선 문제에서 예약 시작 시간과 종료 시간이 여러 개 담긴 배열을 줬으므로 해당 예약 시작 시간을 기준으로 배열을 정렬시킨다. 그리고 정렬된 배열을 가지고 반복문을 돌려서 현재 원소의 예약 시작 시간보다 10분 더 적은 종료 시간이 있는 방 번호를 찾는다.

예를 들어서 현재 예약이 잡힌 방의 갯수를 n 개라고 가정하자. 그럼 방의 번호는 현재 1 번부터 n 번까지 존재한다. 정렬된 배열의 반복문을 돌렸을 때 가장 좋은 예약 방법은 기존에 존재하는 방에 예약을 거는 것이다. 그렇게 하기 위해선 현존하는 방들 중에서 마지막으로 예약된 시간대의 종료 시간이 현재 원소의 시작 시간보다 10분 더 적어야 한다.

그래서 모든 방을 탐색해서 예약...
    </summary>
  

  </entry>

  
  <entry>
    <title>(프로그래머스 | Kotlin) - 매칭 점수</title>
    <link href="http://localhost:4000/posts/KotlinAlgorithm7/" rel="alternate" type="text/html" title="(프로그래머스 | Kotlin) - 매칭 점수" />
    <published>2023-11-19T21:00:00+09:00</published>
  
    <updated>2023-11-19T21:00:00+09:00</updated>
  
    <id>http://localhost:4000/posts/KotlinAlgorithm7/</id>
    <content src="http://localhost:4000/posts/KotlinAlgorithm7/" />
    <author>
      <name>yoonmin</name>
    </author>

  
    
    <category term="CS" />
    
    <category term="알고리즘 문제" />
    
  

  
    <summary>
      





      해결 방법

정말 보자마자 머리가 지끈거리는 문제였다. 카카오 코테 문제를 풀어보면서 문자열 처리 로직을 많이 작성했었는데 설마 html 형식을 통째로 주는 건 상상도 못했다. 필요한 건 크게 url, 키워드, 외부 링크, 이렇게 세 가지다.

여기서 문제는 해당 세 가지를 구하기 위해서 정규식을 사용해야 하는데 나는 정규식을 사용할 때 항상 검색해서 복붙한 게 전부여서 식을 어떻게 작성해야 하는지 몰랐다. 그래서 검색을 해서 몇몇 정규식을 참고했다.

1. 현재 페이지의 URL

"(&amp;lt;meta property=\"og:url\" content=\"(\\S*)//(\\S*)\"/&amp;gt;)"


페이지의 url 을 구할 때 중요한 점은 문제에서 준 양식과 정확히 일치해야 한다는 것이다. 보니까 ur...
    </summary>
  

  </entry>

</feed>


