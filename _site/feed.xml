

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>http://localhost:4000/</id>
  <title>Yoon-Min</title>
  <subtitle>Android를 좋아하고 기록하는 사람입니다 :)</subtitle>
  <updated>2024-02-22T19:53:34+09:00</updated>
  <author>
    <name>SeungMinYoon</name>
    <uri>http://localhost:4000/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="http://localhost:4000/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="http://localhost:4000/"/>
  <generator uri="https://jekyllrb.com/" version="4.3.1">Jekyll</generator>
  <rights> © 2024 SeungMinYoon </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>Kotlin - ArrayList와 MutableList, 무엇을 써야 할까?</title>
    <link href="http://localhost:4000/posts/Kotlin-ArrayList-MutableList-Difference/" rel="alternate" type="text/html" title="Kotlin - ArrayList와 MutableList, 무엇을 써야 할까?" />
    <published>2024-02-20T12:00:00+09:00</published>
  
    <updated>2024-02-22T19:43:06+09:00</updated>
  
    <id>http://localhost:4000/posts/Kotlin-ArrayList-MutableList-Difference/</id>
    <content src="http://localhost:4000/posts/Kotlin-ArrayList-MutableList-Difference/" />
    <author>
      <name>yoonmin</name>
    </author>

  
    
    <category term="CS" />
    
    <category term="프로그래밍 언어" />
    
  

  
    <summary>
      





      

Collection

Kotlin Collection


  “The Kotlin Standard Library provides a comprehensive set of tools for managing collections – groups of a variable number of items (possibly zero) that are significant to the problem being solved and are commonly operated on.”

  Kotlin docs -


다양한 프로그래밍 언어에서 문제 해결을 위해 동일하거나 비슷한 의미를 가진 item 들이 하나의 그룹으로 제어된 방식으로 함께 동작하는 Collection 을 사용합니다. 코틀린에서 컬렉션은 4개의 메서드와...
    </summary>
  

  </entry>

  
  <entry>
    <title>Goodbye, 2023! Welcome, 2024! - [2023년 개발 회고]</title>
    <link href="http://localhost:4000/posts/Review2023/" rel="alternate" type="text/html" title="Goodbye, 2023! Welcome, 2024! - [2023년 개발 회고]" />
    <published>2024-01-24T12:00:00+09:00</published>
  
    <updated>2024-02-06T00:26:25+09:00</updated>
  
    <id>http://localhost:4000/posts/Review2023/</id>
    <content src="http://localhost:4000/posts/Review2023/" />
    <author>
      <name>yoonmin</name>
    </author>

  
    
    <category term="블로그" />
    
    <category term="회고록" />
    
  

  
    <summary>
      





      2024년을 맞이하며

눈 깜짝할 사이에 2023년이 끝났다. 2023년은 여러 이벤트가 겹치면서 다양한 경험을 할 수 있었다. 사용하는 기술 스택에 대한 이해가 이전보다 나아졌고 무엇보다도 확실한 협업 경험을 통해 협업 능력이 높아진 부분에 대해서 상당히 만족하는 한 해였던 것 같다.

이런 소중한 경험들을 머릿속에 두었다간 금방 잊힐 게 눈에 보여서 블로그 글로 23년의 경험들을 정리하고자 한다. 그리고 이왕 회고 글 작성을 시작한 김에 2023년을 시작으로 계속해서 1년 단위 회고를 작성하고자 한다. 해마다 계속해서 쌓이는 회고들을 보면서 내 성장 과정을 확인한다면 뭐라도 느끼는 게 있지 않을까 싶어서다.

이 글이 나중에 뭐 어떤 식으로든 도움이 되길 바라며 이야기를 시작하겠다.

목차
1. 팀...
    </summary>
  

  </entry>

  
  <entry>
    <title>(프로그래머스 | Kotlin) - 무인도 여행</title>
    <link href="http://localhost:4000/posts/KotlinAlgorithm13/" rel="alternate" type="text/html" title="(프로그래머스 | Kotlin) - 무인도 여행" />
    <published>2023-12-07T12:00:00+09:00</published>
  
    <updated>2023-12-07T12:00:00+09:00</updated>
  
    <id>http://localhost:4000/posts/KotlinAlgorithm13/</id>
    <content src="http://localhost:4000/posts/KotlinAlgorithm13/" />
    <author>
      <name>yoonmin</name>
    </author>

  
    
    <category term="CS" />
    
    <category term="알고리즘 문제" />
    
  

  
    <summary>
      





      해결 방법

그래프 탐색을 이용해서 X 가 아닌 영역들을 찾아서 합산한다. BFS 혹은 DFS 를 사용하면 되는데 나는 DFS 를 사용해서 풀었다. maps 의 모든 원소를 반복문으로 돌면서 X 가 아니면서 방문하지 않은 곳을 시작점으로 두고 DFS 를 돌린다.

그리고 DFS 를 돌면서 방문한 점들은 모두 방문 처리(true)를 한다. 전형적인 DFS BFS 문제라서 그래프 탐색 알고리즘만 작성할 수 있으면 어렵지 않게 풀 수 있는 문제다.

​

전체 코드

class Solution {
    fun solution(maps: Array&amp;lt;String&amp;gt;): IntArray {
        val answer = ArrayList&amp;lt;Int&amp;gt;()
        val isVisit...
    </summary>
  

  </entry>

  
  <entry>
    <title>(프로그래머스 | Kotlin) - 메뉴 리뉴얼</title>
    <link href="http://localhost:4000/posts/KotlinAlgorithm12/" rel="alternate" type="text/html" title="(프로그래머스 | Kotlin) - 메뉴 리뉴얼" />
    <published>2023-12-05T12:00:00+09:00</published>
  
    <updated>2023-12-05T12:00:00+09:00</updated>
  
    <id>http://localhost:4000/posts/KotlinAlgorithm12/</id>
    <content src="http://localhost:4000/posts/KotlinAlgorithm12/" />
    <author>
      <name>yoonmin</name>
    </author>

  
    
    <category term="CS" />
    
    <category term="알고리즘 문제" />
    
  

  
    <summary>
      





      해결 방법

가장 간단한 해결 방법은 orders 의 모든 원소들을 course 내의 희망 개수에 맞춰 단품메뉴 조합을 만드는 것이다. 예를 들어서 1번 예시를 보면 orders 의 첫 번째 원소는 ABCFG, course 의 첫 번째 원소는 2 다.

이를 토대로 ABCFG 에서 두 개로 구성된 조합을 모두 꺼내서 map 에 카운트를 증가시킨다. 마찬가지로 orders 의 나머지 원소들도 두 개로 구성된 조합을 모두 만들어서 map 에 카운트를 증가시킨다. 이렇게 해서 course 에서 2 에 대한 작업이 끝나면 나머지 3 4 도 동일하게 처리한다.

이제 map 에는 course 에서 희망한 단품메뉴 조합 수를 토대로 제작한 조합들이 key 값으로, 해당 조합이 등장한 횟수를 카운트한 값이 valu...
    </summary>
  

  </entry>

  
  <entry>
    <title>(프로그래머스 | Kotlin) - 2차원 동전 뒤집기</title>
    <link href="http://localhost:4000/posts/KotlinAlgorithm11/" rel="alternate" type="text/html" title="(프로그래머스 | Kotlin) - 2차원 동전 뒤집기" />
    <published>2023-11-23T12:00:00+09:00</published>
  
    <updated>2023-12-05T20:21:44+09:00</updated>
  
    <id>http://localhost:4000/posts/KotlinAlgorithm11/</id>
    <content src="http://localhost:4000/posts/KotlinAlgorithm11/" />
    <author>
      <name>yoonmin</name>
    </author>

  
    
    <category term="CS" />
    
    <category term="알고리즘 문제" />
    
  

  
    <summary>
      





      해결 방법

이 문제는 특정 행, 혹은 열을 뒤집어서 원하는 형태를 만드는 게 핵심이다. 어떤 행, 혹은 열을 뒤집는 순서가 중요한 것이 아니다. 어떤 행, 혹은 열의 상태를 어떻게 할 것인지(뒤집거나 그대로 두거나)가 중요하다.  M X N  형태에서 특정 열과 행의 상태를 결정하는 방식으로 로직을 짜면 된다.

​

뒷면, 앞면의 상태값을 비트로 표현해보자

문제 마지막에 보면 0 은 동전의 앞면, 1 은 동전의 뒷면을 의미한다. 그렇다면  0 1 을 비트 연산으로 처리해보자. 예를 들어서 2 X 2 형태라고 가정해보자. 행과 열은 각각 2개고 다음과 같이 표현할 수 있다.

두 개면 모두 앞면인 경우와 모두 뒷면 경우, 한쪽은 앞면 한쪽은 뒷면인 경우가 존재한다. 이를 비트 형식으로 표현하면 다음...
    </summary>
  

  </entry>

</feed>


