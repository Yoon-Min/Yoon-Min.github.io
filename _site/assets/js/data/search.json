[
  
  {
    "title": "Android Compose Navigation 01 - 컴포즈 네비게이션 소개",
    "url": "/posts/ComposeNavigationInro/",
    "categories": "Android, 라이브러리",
    "tags": "Android, Compose, Navigation",
    "date": "2024-08-31 00:00:00 +0900",
    





    
    "snippet": "Unsplash의Katie Drazdauskaite​Compose Navigation 포스팅 현황  Android Compose Navigation 01 - 컴포즈 네비게이션 소개  Android Compose Navigation 02 - NavGraph 생성과정 (예정)  Android Compose Navigation 03 - Navigator (...",
    "content": "Unsplash의Katie Drazdauskaite​Compose Navigation 포스팅 현황  Android Compose Navigation 01 - 컴포즈 네비게이션 소개  Android Compose Navigation 02 - NavGraph 생성과정 (예정)  Android Compose Navigation 03 - Navigator (예정)​Intro화면 이동은 모바일 애플리케이션에서 중요한 요소입니다. 당장 우리가 일상에서 사용하는 앱을 살펴봐도 단순히 하나의 화면만 있는 것이 아닌 여러 화면을 통해 사용자에게 다양한 서비스를 제공하는 것을 볼 수 있습니다. 모바일 운영체제중 하나인 Android도 마찬가지입니다.그래서 Android는 이러한 화면 이동 구현을 지원하는 네비게이션 라이브러리를 지원하는데, 제가 이번 글에서 소개할 것은 컴포즈 네비게이션입니다. 몇 년 전부터 Android가 강하게 밀고 있는 UI 제작 킷인 컴포즈에서 네비게이션은 어떤 구조로 이루어져 있고 각각 어떤 역할을 하는지 간략하게 정리하고자 합니다.네비게이션을 공부하면서 해당 라이브러리의 구조가 생각보다 깊고 복잡한 것을 느꼈기 때문에 컴포즈 네비게이션 포스팅은 단편이 아닌 여러 편으로 구성된 시리즈로 진행합니다. 그래서 이번 첫 번째 포스팅 이후에도 계속해서 글을 올릴 예정이니 필요하면 다음 편도 읽어보는 것도 좋을 것 같습니다.​네비게이션은 여행과 같다.  장소(목적지) 형성      네비게이션은 여행과도 같습니다. 가고 싶은 장소들을 정하고 일정에 따라 원하는 목적지로 이동하여 관광을 즐깁니다. 예를 들어 여름철 강릉으로 여행을 출발한다면 갈 수 있는 장소로 숙소, 바닷가, 맛집, 카페 등을 정합니다. 이것들이 모이면 하나의 여행지도가 완성됩니다.    이동 수단      한 장소에서 다른 장소로 옮길 때 어떻게 이동할 것인지도 여행의 한 요소입니다. 한 장소에서 다른 장소로 이동하는 과정은 다양한데 당장 생각나는 것들을 나열하면 다음과 같습니다.    기름값을 나눠 내고 일행중 자차가 있는 사람의 차를 이용  자동차 렌트  지하철, 버스, 택시와 같은 대중교통을 이용  가이드(플래너)      여행을 가게 되면 일행중 누군가는 여행 계획을 세웁니다. 이 사람은 여행 일정동안 가이드 역할을 진행하며 일행들의 상황을 파악하며 목적지 이동이나 목적지에서의 관광 과정에서 중간 소통자 역할을 합니다.  ​여행 예시를 네비게이션 개념으로 연결짓기  장소(목적지) 형성      여행을 가면 여러 곳을 방문하게 됩니다. 그래서 미리 지도 앱을 켜서 일정중에 갈 곳을 확인하고 동선을 정합니다. 이것은그래프안에 필요한 목적지들을 등록하는 네비게이션의 그래프와 비슷합니다. 앱 내에서 NavGraph 는 지도의 역할을 수행하고 NavDestination 은 지도 내 목적지의 역할을 수행합니다.    이동 수단      여행에서 장소와 장소 사이를 옮길 때 이동 방법을 생각하는 것은 그래프에서 목적지와 목적지 사이를 이동할 때 메커니즘을 생각하는 것과 비슷합니다. 앱 내에서 네비게이팅에 대한 메커니즘을 정의하는 클래스를 Navigator 라고 합니다.    가이드(플래너)      원할한 여행을 위해 중간에서 주도하는 가이드는 네비게이션의 NavController 와 비슷합니다. 컨트롤러는 정의한 네비게이션 정보를 토대로 그래프를 생성하여 컨트롤러와 연결시켜주는 NavHost 내에서 앱 탐색을 관리합니다. 그래서 NavGraph 을 가지고 특정 목적지에 대한 네비게이팅 요청을 할 수 있습니다.  ​여행 - 네비게이션  여행 지도 - NavGraph  목적지 - NavDestintaion  여행에서 이동 수단 - Navigator  가이드 - NavController​NavHost"
  },
  
  {
    "title": "GitHub Blog 간편하고 빠르게 꾸며보자 - 깃허브 블로그 커스터마이징 팁",
    "url": "/posts/GitHubBlogCustom/",
    "categories": "블로그, Github 블로그 만들기",
    "tags": "GitHub, Blog, 깃허브 블로그, 커스텀, 블로그 꾸미기",
    "date": "2024-08-23 00:00:00 +0900",
    





    
    "snippet": "Unsplash의Krishdiphong PrayoonwongkasemIntro깃허브 블로그의 장점중 하나는 블로그 테마를 본인 입맛대로 커스터마이징할 수 있다는 것입니다. 깃허브 블로그를 제작하는 과정은 본인이 마음에 드는 템플릿(테마) 파일을 받아서 초기화를 진행한 후에 깃허브를 통해 배포하는 것이 일반적이라 봅니다.블로그를 오픈하는 과정하는 설명대...",
    "content": "Unsplash의Krishdiphong PrayoonwongkasemIntro깃허브 블로그의 장점중 하나는 블로그 테마를 본인 입맛대로 커스터마이징할 수 있다는 것입니다. 깃허브 블로그를 제작하는 과정은 본인이 마음에 드는 템플릿(테마) 파일을 받아서 초기화를 진행한 후에 깃허브를 통해 배포하는 것이 일반적이라 봅니다.블로그를 오픈하는 과정하는 설명대로 따라가면 수월하게 할 수 있습니다만 이후의 블로그 관리는 조금 어려울 수 있습니다. 아이러니하게도 제가 블로그 관리에서 가장 어려움을 느꼈던 부분은 깃허브 블로그의 최고 장점이라 할 수 있는 커스터마이징 부분이었습니다.아무래도 모바일 개발을 주력으로 하다 보니 웹 개발과 관련된 개념에 무지했고 이 때문에 깃허브 블로그 테마 폴더 구조 파악이 쉽지 않았습니다. 이쁘게 블로그를 내 입맛대로 꾸며보고 싶은데 문법, 개념, 구조를 모르니 테마 폴더를 어디서부터 건드리고 어떻게 코드를 작성해야 하는지 고민이 많았습니다.그래서 이번 포스팅은 이렇게 웹 프로그래밍 지식이 부족한 제가 어떻게 블로그 테마 내 이것저것들을 수정을 할 수 있었는지 조그만한 팁을 공유하고자 합니다. 이 글을 읽고 블로그 테마 커스터마이징에 많은 도움이 되길 바라겠습니다!​크롬 개발자 도구를 활용하자블로그 디자인에 사용되는 테마 템플릿의 폴더 구조를 완벽하게 파악한다는 것은 어렵기 때문에 크롬 개발자 도구를 이용해서 커스텀이 필요한 요소가 정의된 위치를 빠르게 파악해야 합니다. 이를 위해 본인의 깃허브 블로그를 크롬 브라우저로 접속한 다음에 개발자 도구 페이지(Ctrl(Cmd) + Shift + C)를 부릅니다.​개발자 도구를 통한 커스터마이징디자인 수정이 필요한 요소 클릭하기인라인 코드 블럭(inline code block)을 디자인 수정 요소 예시로 사용합니다.개발자 도구를 열어서 디자인 수정이 필요한 요소에 커서를 올리면 해당 요소에 대한 정보가 간략하게 메시지 박스로 볼 수 있습니다. 그리고 요소를 클릭하면 오른쪽 개발자 도구 페이지에서 해당 요소와 관련된 코드와 코드 위치 정보가 나타납니다.​디자인 수정이 필요한 요소와 관련된 정보 확인하기  청록색 영역 ==      디자인 수정이 필요한 요소와 관련된 코드가 있는 영역입니다. 이곳에서 해당 요소가 어떻게 정의되었는지(모양, 색상, 크기, 효과 등) 확인할 수 있습니다.    초록색 영역 ==      청록색 영역에서 확인했던 디자인 정의 코드가 어느 위치에 있는지 표시하는 영역입니다. 어떤 코드 파일에 정의되어 있는지 확인할 수 있습니다. 그리고 정의된 코드가 위치한 라인까지 확인가능합니다.  ​원하는 디자인 속성이 정의되어 있는 코드 찾기인라인 코드 블럭 디자인에서 색상을 바꾼다고 가정하겠습니다. 색상과 관련된 정보는 위 사진의 청록색 영역이 해당됩니다. 훑어보면 인라인 코드 블럭의 코드 텍스트의 색상을 설정하는 코드인 것 같습니다. 저기서 색상 값을 직접 입력하는 것이 아닌 다른 곳에서 정의한 색상 변수를 사용하므로 해당 색상 변수의 위치를 파악해 봅시다.인라인 코드 블럭과 관련된 색상 변수는 세 가지로 뽑을 수 있습니다. 해당 세 가지 변수중 아무거나 클릭하면 해당 변수가 정의된 코드 파일 영역을 확인할 수 있습니다.드디어 인라인 코드 블럭의 색상을 바꿀 수 있는 코드의 위치를 찾았습니다. 해당 코드가 위치해 있는 파일을 확인해 보니 이름은 light-syntax.scss 고 218 번 라인에 코드가 있는 것을 확인했습니다. 이제 직접 테마 폴더를 뒤져서 해당 코드를 찾아갑시다.찾았습니다! 크롬 개발자 도구 설명대로 light-syntax.scss 파일 내 218 번 라인에 색상을 설정하는 변수가 있는 것을 확인했습니다. 인라인 코드 블럭의 텍스트 색상을 바꾼다고 하면 텍스트 색상은 --highlighter-rouge-color 가 관리합니다. 이 변수는 --main-color 를 참조하고 있기 때문에 최종적으로 --main-color 의 색상을 설정하면 됩니다.현재 설정되어 있는 색상은 주석처리하고 빨간색으로 수정하겠습니다. 수정했다면 해당 파일을 저장하고 블로그를 업데이트합니다. 블로그 업데이트까지 끝냈다면 인라인 코드 텍스트 색상이 바뀌었는지 확인합니다.정상적으로 바뀌었습니다! UI 컴포넌트의 색상뿐만 아니라 다른 속성도 이런 방식으로 커스텀하면 수월하게 디자인할 수 있습니다.​정리지금까지 크롬 개발자 도구를 이용해 깃허브 블로그의 디자인을 어렵지 않게 수정할 수 있는 방법을 알아봤습니다. 글에서는 색상 속성만 다뤘으나 이것만 해도 다른 속성 수정도 무리 없이 수정할 수 있을 겁니다. 또한 저와 다른 테마를 사용하여 테마 폴더 구조가 다르더라도 결국 CSS 부분을 수정하는 것은 동일하기 때문에 크게 상관없다고 봅니다. 그럼 본인만의 멋진 블로그를 만드는 데 제 글이 도움이 되길 바랍니다. 감사합니다."
  },
  
  {
    "title": "Android - 내부 동작으로 살펴보는 LiveData 값 설정부터 전달까지 과정",
    "url": "/posts/AndroidLiveDataSetValue/",
    "categories": "Android, 라이브러리",
    "tags": "Android, LiveData, UI",
    "date": "2024-08-18 00:00:00 +0900",
    





    
    "snippet": "사진: Unsplash의Jr KorpaIntro안드로이드의 LiveData 라이브러리를 사용하다 보면 라이브 데이터를 구독하고 있는 컴포넌트가 어떻게 값 변경에 대한 알림을 받는지 궁금할 수 있습니다. 저도 해당 라이브러리를 사용하면서 이 부분이 궁금했습니다. 그래서 라이브 데이터의 내부 코드를 분석하여 이를 정리하고자 합니다.​Observe라이브 데...",
    "content": "사진: Unsplash의Jr KorpaIntro안드로이드의 LiveData 라이브러리를 사용하다 보면 라이브 데이터를 구독하고 있는 컴포넌트가 어떻게 값 변경에 대한 알림을 받는지 궁금할 수 있습니다. 저도 해당 라이브러리를 사용하면서 이 부분이 궁금했습니다. 그래서 라이브 데이터의 내부 코드를 분석하여 이를 정리하고자 합니다.​Observe라이브 데이터는 보통 ViewModel 에서 생성 및 업데이트를 관리합니다. 그리고 이러한 변경사항을 라이브 데이터의 구독자인 액티비티 혹은 프래그먼트가 전달받습니다. 이러한 알림 수신이 가능한 이유는 라이브 데이터가 가지고 있는 observe 함수 덕분입니다.라이브 데이터를 구독할 수 있는 observe 메서드는 라이브 데이터 클래스 내 옵저버 맵에 구독자 정보를 저장합니다. 좀 더 자세히 설명하자면 구독자가 되는 액티비티와 액티비티에서 정의한 콜백 메서드 정보를 mObservers 에 저장하여 알림을 보낼 준비를 하는 것입니다.​ObserverWrapper라이브 데이터 내에 저장되는 옵저버는 옵저버 클래스 자체로 저장되지 않습니다. 옵저버 객체에 ObserverWrapper 추상 클래스 기반의 LifecycleBoundObserver 클래스로 감싸서 저장합니다.먼저 ObservrWrapper 는 말그대로 옵저버와 옵저버의 상태 정보를 저장하는 래핑 클래스입니다. 이러한 정보에 생명주기 관련 정보를 추가(LifecycleBoundObserver)하는 방식으로 생명주기 관찰에 기반한 알림 전달을 진행합니다.​setValue이제 라이브 데이터 값을 설정하는 메서드를 살펴 보겠습니다. 우선 setValue 입니다. 해당 메서드는 메인 스레드에서 라이브 데이터의 값을 설정한다는 특징을 가지고 있습니다.그래서 메서드 첫 번째 라인에 assertMainThrad 를 통해 메인 스레드에서의 실행을 강제합니다. 이후에는 mData 에 설정하려는 값을 저장하여 dispatchingValue 를 통해 mData 를 옵저버에게 알립니다. 라이브 데이터에 값을 설정하면 내부에서는 mData 라는 변수에 값을 저장하여 관리합니다.​postValue이 메서드는 setValue 와 마찬가지로 라이브 데이터의 값을 설정하는 특징을 가집니다. 그러나 차이점이라 하면 백그라운드 스레드에서 값을 변경하여 메인 스레드에서 실제 적용하는 과정을 거칩니다.기본적으로 라이브 데이터는 메인 스레드에서 값을 변경할 수 있습니다. 그런데 상황에 따라 백그라운드 환경에서 값을 설정해야 하는 경우도 있습니다. 그래서 postValue 메서드를 지원하여 백그라운드 환경에서 값을 변경하고 이를 메인 스레드에게 전달해 최종 적용하는 것입니다.백그라운드에서 값을 변경하기 위해서는 동기화 문제를 신경써야 합니다. 그래서 synchronized 를 통해 mData 가 아닌 mPendingData 에 임시로 값을 저장합니다. 임시로 값을 저장했으면 그 다음은 메인 스레드에게 post 합니다.메인 스레드에 전달하는 Runnable 객체는 임시로 저장한 값을 setValue 메서드를 호출하여 설정한 값을 실제 적용하는 작업을 진행합니다. 이를 통해 결국 postValue 는 최종적으로 setValue 를 호출한다는 것을 알 수 있습니다.​dispatchingValuesetValue 에서 마지막에 호출하는 이 메서드는 라이브 데이터 내 옵저버 맵에 저장되어 있는 옵저버에 알림(값이 변경됨)을 보냅니다. 이 알림은 considerNotify 에 위임합니다.여기서 단일(특정) 옵저버에 알림을 보낼 것인지, 모든 옵저버에 알림을 보낼 것인지 정해야 합니다. 만약 특정 옵저버에게만 알림을 보내고 싶다면 파라미터인 initiator 에 옵저버를 기입하고, 반대로 모든 옵저버에 알림을 보내고 싶다면 null 로 기입합니다.setValue 는 null 로 설정하기 때문에 해당 라이브 데이터를 관찰하고 있는 모든 옵저버에게 알림을 전송하게 되는 것입니다. 제가 설명하는 예제에서는 액티비티 하나만 라이브 데이터를 관찰하고 있기 때문에 이 액티비티에만 알림이 전송됩니다. 그러나 액티비티 이외에 다른 컴포넌트에서도 라이브 데이터를 관찰하고 있다면 해당 컴포넌트에도 알림이 전송됩니다.​considerNotify이 메서드에서 최종적으로 옵저버에 알림을 보냅니다. 먼저 옵저버가 활성화 상태인지 확인하는 작업을 거친 후에 마지막에 옵저버(액티비티)가 정의했던 onChanged 를 호출합니다.라이브 데이터 내 onChanged 호출로 인해서 제가 액티비티에 정의했던 Timber.d(\"result : $it\") 코드 블럭이 실행됩니다."
  },
  
  {
    "title": "Android - 내부 동작으로 살펴보는 LiveData의 생명주기(Lifecycle) 인식 원리",
    "url": "/posts/AndroidLiveDataLifecycle/",
    "categories": "Android, 라이브러리",
    "tags": "Android, LiveData, UI",
    "date": "2024-08-02 00:00:00 +0900",
    





    
    "snippet": "Unsplash의Nitish MeenaIntroLiveData 는 관찰 가능한 UI 데이터 홀더 클래스입니다. 라이브 데이터는 안드로이드의 수명주기를 인식하여 수명주기에 맞춰 동작한다는 특징을 가지고 있어서 UI Layer에서 UI 데이터를 보유하는 역할을 수행합니다.그런데 여기서 한 가지 궁금증이 생깁니다. 라이브 데이터가 안드로이드의 생명주기에 맞...",
    "content": "Unsplash의Nitish MeenaIntroLiveData 는 관찰 가능한 UI 데이터 홀더 클래스입니다. 라이브 데이터는 안드로이드의 수명주기를 인식하여 수명주기에 맞춰 동작한다는 특징을 가지고 있어서 UI Layer에서 UI 데이터를 보유하는 역할을 수행합니다.그런데 여기서 한 가지 궁금증이 생깁니다. 라이브 데이터가 안드로이드의 생명주기에 맞춰서 동작한다는 것은 알겠는데 어떻게 인식을 하는 걸까요? 이번 포스팅은 그 원리를 알아보는 시간을 가지고자 합니다.​Lifecycle라이브 데이터를 분석하기 전에 먼저 생명주기에 대해서 알 필요가 있습니다. 보통 안드로이드에서 생명주기라 하면 액티비티 혹은 프래그먼트의 생명주기를 떠올릴 것입니다.그 생명주기의 근간이 되는 클래스가 Lifecycle 입니다. 액티비티 혹은 프래그먼트와 같은 구성요소의 생명주기 상태 관련 정보를 포함하며 다른 객체가 이 상태를 관찰할 수 있게 하는 클래스입니다.  “Defines an object that has an Android Lifecycle. Fragment and FragmentActivity classes implement LifecycleOwner interface which has the LifecycleOwner. getLifecycle method to access the Lifecycle. You can also implement LifecycleOwner in your own classes.”  “Android Lifecycle을 가진 개체를 정의합니다. Fragment 및 FragmentActivity 클래스는 Lifecycle Owner를 가진 Lifecycle Owner 인터페이스를 구현합니다. Lifecycle 메서드를 가져와 Lifecycle에 액세스할 수 있습니다. 자신의 클래스에서 Lifecycle Owner를 구현할 수도 있습니다.”  Android Developers​LifecycleOwnerLifecycleOwner 는 Lifecycle 을 가지고 있는 인터페이스입니다. 뷰모델 저장소인 ViewModelStore 을 ViewModelStoreOwner 인터페이스가 가지고 있는 것과 동일한 방식입니다. 이 뷰모델 저장소의 오너는 액티비티 혹은 프래그먼트가 됩니다.생명주기 오너도 마찬가지로 액티비티 혹은 프래그먼트가 Lifecycle 의 Owner 가 되어 내부의 Lifecycle 클래스를 통해 생명주기를 관리합니다.액티비티의 첫 번째 뼈대가 되는 컴포넌트 액티비티와 프래그먼트에서 구현 인터페이스 목록을 보면 LifecycleOwner 가 있는 것을 볼 수 있습니다. 액티비티와 프래그먼트가 생명주기의 주인이 되어 LifecycleOwner 내부의 lifecycle 을 구현합니다.lifecycleRegistry 는 추상 클래스인 Lifecycle 의 하위(상속)클래스입니다. Lifecycle 은 생명주기의 기본적인 상태와 이벤트를 정의한 클래스라면 레지스트리는 생명주기를 관찰하여 처리하는 방법들을 정의한 클래스라 할 수 있습니다.​LifeCycleLifeCycle 객체는 Event , State 의 두 가지 열거형 클래스를 관리합니다. 생명주기에 대한 공부를 했다면 매우 익숙한 키워드일 것입니다.이벤트와 상태가 어떤 느낌인지 정확히 알려면 아래의 Android 수명주기를 인식하는 상태와 이벤트표를 참고하세요. 이 표를 보면 상태와 이벤트가 어떻게 연결되어 있는지 이해하는 데 도움이 될 것입니다.아래 그림을 통해 targtState , downFrom , downTo , upFrom , upTo 내부 코드는 충분히 이해가 가능합니다. 그리고 State 의 isAtLeast 는 State 열거 클래스 내 요소들의 순서 번호를 비교하여 최소 state 인자 이상의 상태인지 확인합니다.예를 들어서 isAtLeast 의 인자로 STARTED 가 전달되면 현재 상태가 최소한 STARTED 이상의 상태인지 확인한다고 이해하면 될 것 같습니다.​LifecycleRegistry마지막으로  Lifecycle 의 Owner 가 가지고 있는 Lifecycle 객체를 보겠습니다. 가지고 있는 라이프 사이클 구현체는 위에서 설명했던 대로 LifecycleRegistry 가 되겠습니다.이 구현체는 여러 관찰자(Observers)를 처리(Handle)하는 역할을 가지고 있습니다. 그리고 생명주기에 변화가 생기면 해당 정보를 관찰자들에게 전달하여 관찰자들이 바로바로 상태를 감지할 수 있도록 합니다. 이러한 점 때문에 LiveData 도 해당 객체에 생명주기를 관찰하는 관찰자로 들어가서 생명주기를 인식할 수 있습니다.​addObserverLifecycleOwner  가 되는 액티비티 혹은 프래그먼트의 상태가 변경될 때 알림을 받을 옵저버를 추가합니다.  메인스레드에서 동작되는지 확인 (해당 동작은 메인스레드에서 동작되어야 함)  현재 상태에 따라 초기 상태를 설정하고 추가하려는 옵저버가 이미 존재하는지 확인  이미 존재하는 옵저버면 동기화 작업이 필요하지 않으므로 종료  observerMap 에 옵저버를 추가하고 현재 생명주기 상태에 맞춰주는 동기화 작업을 진행          한 단계씩 차례대로 상태 갱신        현재 addObserver 가 재진입 상태면 sync() 작업을 진행하지 스택의 Top 일 때 sync() 작업을 진행한다.          sync() - LifecycleOwner 의 상태와 모든 옵저버의 상태를 동기화하는 작업      isReentrance ? - 함수가 실행되는 도중에 같은 함수가 다시 호출(옵저버 추가 과정)될 수 있기 때문에 오류방지 차원에서 확인      ​ObserveWithState옵저버와 옵저버의 현재 상태를 함께 저장하기 위한 클래스입니다. 그리고 내부의 dispatchEvent 메서드를 통해 옵저버에게 이벤트를 전달하여 옵저버가 생명주기를 인식할 수 있게 합니다.​calculateTargetState옵저버의 목표 상태를 계산해서 반환합니다.​syncLifecycleOwner 의 상태와 모든 옵저버의 상태를 동기화하는 작업을 진행합니다. 현재 등록된 옵저버들 중에서 가장 오래된 것과 가장 최신의 것을 각각 현재 상태와 비교하여 backwarPass 혹은 forwarPass 기법으로 동기화를 진행합니다.backwarPass 와 forwardPass 의 차이는 동기화를 진행하는 방향에 있습니다. 전자는 Event.downFrom , 후자는 Event.upFrom 으로 동기화를 진행합니다.​handleLifecycleEvent생명주기의 변화가 생기면 내부적으로 handleLifecycleEvent 가 실행되고 상태값을 새로 설정하여 옵저버들에게 이를 알립니다. 현재 상태 값을 갱신하게 되면 sync 메서드를 통해 옵저버들에게 알림을 보냅니다.​LiveData이제 생명주기에 대한 얘기를 끝내고 라이브 데이터를 살펴 보겠습니다. 보통 라이브 데이터는 ViewModel 에서 생성 및 관리를 하게 됩니다. 액티비티에서는 ViewModl 을 참조하여 라이브 데이터에 대해 오직 observe 메서드만 사용하여 관찰합니다.따라서 LiveData 와 Lifecycle 의 내부 동작으로 인해 다음과 같은 효과를 얻습니다. 이것들이 어떻게 가능한지 LiveData 내부 메서드를 통해 알아 보겠습니다.  LifecycleOwner 가 STARTED  혹은 RESUMED 의 활성 상태일 때 이벤트를 수신한다.  DESTROYED 상태라면 이벤트를 수신하지 않는다.  LifecycleOwner 가 비활성 상태일 때 업데이트를 받지 않고 다시 활성화되면 마지막으로 사용 가능한 데이터를 자동 수신한다.​observe라이브 데이터의 observe 함수를 통해 옵저버 정보를 내부에 저장하는 작업을 먼저 진행하고 마지막은 LifecycleOwner 에 옵저버 정보를 등록하는 작업을 진행합니다. 옵저버 저장 코드 라인이 두 가지인 이유는 다음과 같습니다.  mObservers.putIfAbsent(observer, wrapper);      Activity 가 LiveData 의 UI 데이터를 얻기 위해 구독하기 때문에 라이브 데이터 클래스 내부에 액티비티가 구독할 때 전달한 정보를 저장하는 것입니다.    owner.getLifecycle().addObserver(wrapper);      LiveData 가 Activity 의 생명주기에 맞춰 UI 데이터를 전달해 줘야 하기 때문에 Lifecycle 클래스 내 옵저버로 LiveData 을 등록하는 것입니다.  ​LifecycleBoundObserver라이브 데이터의 observe 메서드를 통해 옵저버를 내외부에 등록할 때는 옵저버 정보를 LifecycleBoundObserver 객체에 감싸서 등록합니다. LifecycleBoundObserver 클래스는 LifecycleObserver 인터페이스를 구현하고 ObserverWrapper 추상 클래스를 확장한 형태입니다.LifecycleBoundObserver 는 LifecyleOwenr 의 생명주기 변화 발생시 등록된 옵저버들의 onStateChanged 메서드를 실행(생명주기의 오너가 되는 액티비티 혹은 프래그먼트가 옵저버들을 꺼내서 해당 메서드 실행)함으로써 옵저버들에게 생명주기 이벤트를 송신할 수 있도록 합니다.ObserverWrapper 는 수신한 생명주기 이벤트를 라이브 데이터 내부 동작 처리에 사용합니다. 라이브 데이터가 활성 상태일 때 이벤트를 수신할 수 있는 이유가 이 클래스를 통해 라이브 데이터의 활성 상태를 설정하고 판별하기 때문입니다.​LifecycleBoundObserver - onStateChangedLifecycle 은 생명주기 이벤트를 LiveData 로 넘길 때 라이브 데이터를 래핑한 옵저버 객체의 onStatChanged 메서드를 호출합니다. 생명주기 이벤트가 Lifecycle -&gt; LiveData 로 넘어가는 첫 단계라고 생각하시면 될 것 같습니다.해당 메서드의 인자는 Lifecycle 에서 보낸 값이고 내부에서 관찰 대상의 생명주기 정보를 최신화하고 activeStateChanged 메서드를 통해 라이브 데이터 활성화를 결정합니다. 만약 관찰 대상의 생명주기가 파괴됐다면 관찰 대상이 라이브 데이터를 구독했을 때 넘겼던 옵저버 정보를 삭제합니다.  LiveData -&gt; Activity : 액티비티의 생명주기 관찰을 위해 구독  Activity -&gt; LiveData : 라이브 데이터가 지닌 UI 데이터를 얻기 위해 구독​LifecycleBoundObserver - activeStateChanged라이브 데이터의 활성 상태를 설정하는 메서드입니다. 라이브 데이터의 활성 조건은 관찰 대상의 생명주기가 최소 STARTED 이어야 합니다. 그래서 인자로 들어오는 newActive 는 shouldBeActive() 메서드의 결과값이 됩니다.만약 라이브 데이터의 기존 활성 상태와 인자로 들어온 newActive 가 같다면 갱신 작업이 필요없으므로 종료합니다. 반면에 새로운 상태가 들어왔다면 갱신작업을 진행하고 활성화 상태에 해당되면 dispatchingValue 을 통해 라이브 데이터를 구독하는 옵저버에 값을 전달하는 작업을 준비합니다.​LifecycleBoundObserver - dispatchingValue여기서는 라이브 데이터를 구독하는 옵저버에게 값을 전달하기 전에 단일 옵저버를 대상으로 알림을 보내는 것인지 모든 옵저버를 대상으로 알림을 보내는 것인지 구분하여 작업을 진행합니다.특정 옵저버를 대상으로 알림을 보내는 것이라면 해당 옵저버의 정볼르 인자 initiator  로 전달해서 알립니다. 만약 모든 옵저버에게 알림을 보내고 싶다면 initiator 값을 null 로 전달합니다. 알림 전송은 considrNotify 가 진행합니다.​LifecycleBoundObserver - considerNotify알림 전송을 하기 전에 옵저버(Activity)가 활성 상태인지 확인한 후에 알림을 전송합니다. 이때 마지막에 호출하는 onChanged 함수가 액티비티에서 정의했던 viewModl.livedata.observer(this) { /* onChanged body */ } 코드에 해당합니다.결국 생명주기의 변화가 시작되어 최종적으로 LiveData 의 considerNotify 가 실행되면 라이브 데이터를 구독했던 액티비티에게 알림을 전송하게 되는 것입니다. 이 과정에서 액티비티의 생명주기 상태에 따라 알림 전송을 취소하기도 합니다.​참조Android Developers - Handling Lifecycles with Lifecycle-Aware ComponentsAndroid Developers - LiveData"
  },
  
  {
    "title": "Android - 화면 구성 변환에도 ViewModel 데이터가 보존될 수 있는 이유",
    "url": "/posts/ViewModelClear/",
    "categories": "Android, 라이브러리",
    "tags": "Android, 뷰모델, ViewModel",
    "date": "2024-07-23 00:00:00 +0900",
    





    
    "snippet": "Intro뷰모델은 ViewModelStoreOwner 가 사라질 때까지 메모리에 남아 있습니다. 덕분에 액티비티의 화면 구성 변경 후에도 뷰모델을 유지할 수 있습니다. 뷰모델이 파괴되는 조건은 다음과 같이 세 가지가 있습니다.  액티비티가 완료될 때 -&gt; onDestroy  프래그먼트가 분리될 때  네비게이션 백 스택에서 삭제될 때그런데 여기서 ...",
    "content": "Intro뷰모델은 ViewModelStoreOwner 가 사라질 때까지 메모리에 남아 있습니다. 덕분에 액티비티의 화면 구성 변경 후에도 뷰모델을 유지할 수 있습니다. 뷰모델이 파괴되는 조건은 다음과 같이 세 가지가 있습니다.  액티비티가 완료될 때 -&gt; onDestroy  프래그먼트가 분리될 때  네비게이션 백 스택에서 삭제될 때그런데 여기서 궁금한 점이 생겼습니다. 대표적인 구성 변경인 화면 전환이 발생하면 분명 액티비티는 onDestroy 후에 onCreate 으로 재생성을 하는 과정을 거치는데 뷰모델의 파괴 조건에 따르면 이때 뷰모델도 파괴되어야 합니다. 하지만 구성 변경이 발생하면 뷰모델은  Clear 되지 않습니다.안드로이드는 구성 변경과 같이 액티비티가 잠깐 파괴되는 경우는 뷰모델을 클리어하지 않고 액티비티가 완전히 전환되거나 메모리 관리로 인한 앱 종료와 같은 완전 파괴는 클리어를 진행한다고 합니다. 그렇다면 내부에서 액티비티 종료 케이스를 어떻게 구분하는 걸까요?​Activity 관계도이를 알기 위해서는 우선 액티비티 관련 클래스의 관계를 알아야 합니다. 내용이 빈 액티비티를 새로 생성하면 AppCompatActivity 을 상속받은 MainActivity 를 볼 수 있습니다.이 AppCompatActivity 클래스 내부에 들어가면 FragmentActivity 를 상속받은 것을 볼 수 있고 FragmentActivity 내부로 들어가면 ComponentActivity 을 상속받은 것을 볼 수 있습니다. 결국 이를 종합하면 액티비티 클래스는 아래와 같은 구조로 이루어져 있음을 알 수 있습니다.​ComponentActivity액티비티의 가장 기본 뼈대가 되는 ComponentActivity 는 생명주기 관련 콜백 메서드가 정의되어 있습니다. 그래서 해당 클래스 내부에 액티비티가 onDestroy 됐을 때의 동작 코드를 볼 수 있습니다.​isChangingConfigurationsinit 내의 코드를 보면 생명주기 옵저버 관련 코드를 볼 수 있습니다. 생명주기를 관찰하는 옵저버를 추가하여 특정 생명주기 단계가 발생했을 때 어떤 동작을 할 것인지 정의하는 것입니다. 그중에서 onDestroy 상황과 관련한 코드는 다음과 같습니다.여기서 isChangingConfigurations 을 보면 딱 감이 옵니다. 해당 변수는 구성 변경 발생 유무에 따라 논리 값을 저장합니다. 화면 전환과 같은 구성 변경이 발생하면 true 로 저장되고 위의 조건문에서는 ! 로 인해 false 로 바뀝니다. 따라서 뷰모델 저장소 내 뷰모델의 클리어를 막을 수 있습니다.반대로 화면 전환과 같은 구성 변경에 의한 onDestroy 가 아니라면 isChangingConfigurations 은 false 가 되고 조건문에서는 ! 로 인해  true 로 적용되어 viewModelStore.clear() 가 실행됩니다.​정리결국 액티비티의 onDestroy 가 발생하면 isChangingConfigurations 을 통해 액티비티의 파괴가 구성 변환에 의한 것인지 아닌지 판별을 하는 과정 덕분에 내부에서 액티비티 종료 케이스를 구분할 수 있습니다. 그리고 이러한 결과를 가지고 ViewModel 의 clear 작업을 결정합니다.참조Android Architecture Components: Lifecycle and LiveModelAndroid Developers - ViewModel 개요"
  },
  
  {
    "title": "Google I/O Android Korea 2024 후기",
    "url": "/posts/GoogleIOAndroid/",
    "categories": "블로그, 회고록",
    "tags": "Google I/O, Android, GDG",
    "date": "2024-07-23 00:00:00 +0900",
    





    
    "snippet": "처음 가보는 Android 행사여태까지 Android를 다루는 행사에 참여해본 적이 없었는데 Google I/O를 통해 새로운 경험을 하게 되어서 매우 즐거웠다. 안드로이드 공부를 오랜만에 다시 시작한 탓에 내외부로 바뀐 것들에 대한 파악이 필요했었는데 마침 GDG에서 이를 알려주는 행사를 열어서 바로 찾아가게 된 것이 이번 행사의 참가 계기가 되겠다...",
    "content": "처음 가보는 Android 행사여태까지 Android를 다루는 행사에 참여해본 적이 없었는데 Google I/O를 통해 새로운 경험을 하게 되어서 매우 즐거웠다. 안드로이드 공부를 오랜만에 다시 시작한 탓에 내외부로 바뀐 것들에 대한 파악이 필요했었는데 마침 GDG에서 이를 알려주는 행사를 열어서 바로 찾아가게 된 것이 이번 행사의 참가 계기가 되겠다.Android 행사 참여는 처음이지만 행사를 진행하는 구글 스타트업 캠퍼스는 너무나 익숙했다. 예전에 GDSC 활동을 할 때 잡페어 행사에 참가한 적이 있는데 그 행사를 구글 스타트업 캠퍼스에서 진행했었다. 그래서 한 번 가본 장소기 때문에 행사장은 문제 없이 잘 찾아갈 수 있었다.분위기는 굉장히 자유롭고 편했다. 중간마다 간단한 마실 것과 휴식 시간을 넉넉하게 챙겨줘서 5시간동안 진행하는 발표임에도 집중해서 잘 들었다. 물, 커피, 탄산 음료, 얼음컵 등 굉장히 다양하게 준비되어 있었고 심지어 맥주도 마실 수 있어서 맥주를 마시면서 발표를 듣기도 했다. 물론 나는 공복에 피곤해서 한 입만 했다.모든 발표가 끝나고나서 개인 일정 때문에 아쉽게 마지막에 진행하는 피자&amp;맥주 네트워킹 시간을 가지지 못하고 바로 나왔다. 개인적으로 피자와 맥주를 엄청 좋아하는데 즐기지 못해서 너무 아쉬웠다.​기억에 남는 내용들Key Note생각보다 20살 미만의 미성년자도 많이 참석해서 놀랐다. 웬만하면 10의 9는 성인인줄 알았는데 발표 시작전에 하는 키노트에서 미성년자 개발자도 굉장히 많이 참석했다는 말을 듣고 일찍부터 이런 행사에 참석하는 열정이 멋있고 부러웠다. 나는 고등학생 때 딱히 하고싶은 것도 되고싶은 것도 없었던 것 같은데 대단한 것 같다.​AI - Gemini이번 행사에 참여하기 전에 가장 기대하고 알고 싶었던 내용이었다. 안드로이드 스튜디오에 가장 큰 변화를 준 요소라고 생각한다. 그래서 그런지 이번 I/O(미국)에서 Gemini 내용의 비중이 상당했는데 그럴만하다. 오랜만에 안드로이드 스튜디오를 켜서 생성형 AI가 적용된 것을 보고 엄청 놀랐으니 말이다.따로 크롬을 켜서 GPT를 사용할 필요 없이 스튜디오 내부에서 생성형 AI를 활용할 수 있다는 점이 매우 만족스러웠다. 또 질의응답에 그치지 않고 코드 인스펙션도 지원한다는 점이 굉장히 마음에 들었다. AI를 스튜디오 곳곳에 다양하게 적용을 했는데 그중에서 가장 신기했던 것은 코드 자동완성 지원이다.// 사용자가 입력한 부분val binding = // AI가 분석후 추천하는 코드val binding = ActivityMainBinding.inflate(layoutInflater)예를 들어 바인딩 변수를 만든다고 할 때 위처럼 코드 추천을 받을 수 있다. 그래서 ‘‘이거 어떻게 만들더라?’ 라는 생각을 덜 수 있다. 하지만 어디까지나 자동완성은 개발자의 편의를 돕기 위한 기능이지 코드의 퀄리티를 보장하지 않는다. 따라서 해당 기능을 사용할 때는 해당 코드가 적절한지 개발자가 검토하는 것을 권유한다(구글 피셜).Google Blog 이미지 참조개발툴에서까지 AI가 적용되고 실제 사용을 해보니 정말 많은 것이 바뀌었다는 것을 실감한다. 20년도에 처음 안드로이드 개발을 접했을 때는 AI고 뭐고 구글에 공식문서와 스택오버플로우를 왔다갔다 하면서 그야말로 박치기를 했었는데 4년이 지난 지금은 굳이 구글에 접속하지 않아도 스튜디오 내에서 웬만한 궁금증들을 해결할 수 있다.이런 것들을 보면 요즘은 정말 나도 모르게 확확 바뀌는 것 같아서 당황할 때가 있다. 얼른 바뀐 것들에 적응해야겠다. 그리고 마지막 TMI로 초록색보다는 재미나이 컬러의 안드로이드가 더 영롱하고 멋있는 것 같다(항상 초록색 안드로이드만 봐서 조금 질리는 것도 있다).​Compose컴포즈에 관한 내용은 가볍게 들을 수 있어서 좋았다. 나는 아직 컴포즈를 사용해본 경험이 없기 때문에 조금 가볍게 컴포즈를 다루고 어떤 느낌인지 알고자 하는 느낌의 내용을 원했는데 발표 내용이 매우 도움이 되었다. 점점 컴포즈 관련 세션이 증가하고 있는 것을 보면 컴포즈 도입 움직임이 이전에 비해 훨씬 많아졌다는 것을 느낀다.구글에서 컴포즈에 대한 지원을 아낌없이 하는 것을 보면 XML 방식에서 컴포즈로 완전히 전환하려는 것 같다. 이번년도가 끝나기 전에 컴포즈를 사용해보고 친해지는 것이 목표인데 꼭 달성했으면 좋겠다.​UIUI 관련 발표 내용에서 가장 기억에 남는 것은 상태바 투명 처리 관련 기능 추가다. 이전부터 안드로이드 개발을 하면서 가장 억장 무너지는 순간중 하나가 상태바 투명 처리였다. 투명 처리를 하는 과정이 생각보다 단순하지 않아서 단순하게 개선해줬으면 좋겠다는 생각을 했었는데 이번에 개선이 된 것 같아서 만족스럽다. 물론 직접 사용을 해봐야 알겠지만 그래도 대충 개선 내용을 훑어보니 이전 방식보다는 괜찮을 것 같다.override fun onCreate(savedInstanceState: Bundle?) { enableEdgeToEdge() super.onCreate(savedInstanceState) ...}Activity 을 생성하면 이전과는 다르게 엣지 투 엣지 코드가 추가된 것을 확인할 수 있다. 나는 처음에 저게 뭔가 했는데 해당 함수의 코멘트를 대충 해석을 해보니 API 버전에 따라 투명 처리를 지원한다는 내용이었다. 그래서 이때 투명처리에 관한 개선이 있다는 것을 대충은 알고 있었다.​App Benchmark앱 성능을 테스트할 수 있는 Macrobenchmark에 관한 내용도 들을 수 있었다. 앱 테스트 경험이 별로 없어서 처음 접해보는 기능이었는데 잘만 사용한다면 성능 개선에 굉장히 많은 도움이 될 것 같다는 생각이 들었다. 프로파일러와 레이아웃 인스펙터정도만 알고 있었는데 이번 기회로 좋은 테스트 도구를 알아간다. 나중에 테스트할 일이 생기면 이 도구를 꼭 사용해봐야겠다.​마무리처음 가보는 Android 행사였는데 한 번 가봤던 행사장에 자유로운 분위기가 더해져서 그런지 잘 즐기다 왔다. 물론 돌아오는 길에 미친 비폭탄과 강풍이 몰아치는 날씨에 정신줄을 놨지만 안드로이드에 대한 열정을 다시 올릴 수 있는 좋은 경험이었다. 다음년도에도 시간이 있다면 참석하고 싶다.​참조Android Developers - 앱에 더 넓은 화면에 콘텐츠 표시하기Android Developers - Macrobenchmark 작성"
  },
  
  {
    "title": "Android - ViewModel 생성과 반환",
    "url": "/posts/ViewModelCreation/",
    "categories": "Android, 라이브러리",
    "tags": "Android, 뷰모델, ViewModel",
    "date": "2024-07-22 00:00:00 +0900",
    





    
    "snippet": "IntroViewModel 은 안드로이드의 UI 층을 구현하는 데 많은 도움을 주는 Jetpack 라이브러리입니다. 화면 구성의 변경이나 여러 프래그먼트에서 UI 상태 데이터를 보존하고 공유할 수 있다는 장점 덕분에 많은 사람들이 사용하고 있고, 저 역시 뷰모델을 애용하고 있습니다.그러나 지금까지 뷰모델의 사용 방법과 역할만 숙지한 탓에 최근 내부 동...",
    "content": "IntroViewModel 은 안드로이드의 UI 층을 구현하는 데 많은 도움을 주는 Jetpack 라이브러리입니다. 화면 구성의 변경이나 여러 프래그먼트에서 UI 상태 데이터를 보존하고 공유할 수 있다는 장점 덕분에 많은 사람들이 사용하고 있고, 저 역시 뷰모델을 애용하고 있습니다.그러나 지금까지 뷰모델의 사용 방법과 역할만 숙지한 탓에 최근 내부 동작이 어떻게 되는지에 대한 이해가 매우 부족한 것을 느꼈습니다. 현재 계획하고 있는 프로젝트가 두 개이고 해당 프로젝트를 앞으로 제대로 수행하려면 사용하는 라이브러리에 대한 이해가 필요할 것 같아 이번 기회에 정리하고자 합니다.​ViewModel 관련 관계도먼저 뷰모델 생성 및 관리에 관여하는 객체들의 관계도는 위 그림과 같습니다. 뷰모델을 생성할 때는 바로 뷰모델 클래스를 통해 객체를 create 하는 것이 아니라 프로바이더를 통해 뷰모델 객체를 공급받습니다. 프로바이더는 뷰모델의 생성과 관리를 위한 객체들 - Store , Factory 을 가지고 있습니다.  프로바이더 호출  프로바이더 내부 객체들을 이용해 뷰모델을 생성하거나 기존 객체 반환          ViewModelStore - 뷰모델 객체가 보관되는 장소      ViewModelProvider.Factory - 뷰모델 객체를 생성하는 역할      ​ViewModelProvider프로바이더는  StoreOwner  와 Factory 을 가지고 있고 내부에는 프로바이더 객체 생성, 뷰모델 로딩, 팩토리 인터페이스 등의 코드가 정의되어 있습니다. 즉, 프로바이더 객체를 생성( create )하고 get 을 통해 뷰모델을 가져오는 것이 주가 되겠습니다.      생성자 구성                  ViewModelStoreOwner - ViewModelStore 보유                    ViewModelStore - 뷰모델 객체가 저장되는 장소                    Factory - 뷰모델 객체를 생성하는 팩토리 (프로바이더 내부에 인터페이스 정의)                  get - 뷰모델을 가져옵니다.        create - 프로바이더 객체를 생성합니다.  ​ViewModelStoreOwnerViewModelStoreOwner 은 이름 그대로 ViewModelStore 을 가지고 있습니다. 해당 인터페이스의 owner 는 액티비티 혹은 프래그먼트이기 때문에 이들 클래스 내부에 viewModelStore 가 멤버변수로 자리합니다.액티비티 클래스의 첫 번째 뼈대인 ComponentActivity 클래스를 보면 ViewModelStoreOwner 인터페이스를 받아서 구현한 코드를 확인할 수 있습니다.​ViewModelStore뷰모델 저장소인 스토어는 Map 으로 관리합니다. 키를 등록하기 위한 put , 뷰모델을 꺼내기 위한 get , 맵을 정리하기 위한 clear 가 멤버 메서드로 자리하고 있습니다. 새로 생성된 뷰모델 정보는 put 으로 맵에 등록되며 등록된 뷰모델을 꺼낼 때는 get 을 사용합니다.​ViewModelProvider.Factory뷰모델 프로바이더 내부에 인터페이스로 자리하고 있는 Factory 는 ViewModelProvider 내부의 get 메서드 호출을 통해 뷰모델을 가져오는 작업이 필요할 때 사용됩니다.뷰모델을 가져오는 작업을 한다면 첫 번째로 ViewModelStore 에 저장되어 있는 뷰모델인지 먼저 확인해야 합니다. 스토어에 저장되어 있는 뷰모델이라면 굳이 생성할 필요 없이 꺼내 쓰면 됩니다. 반대로 저장되지 않은 뷰모델이라면 새로 생성하는 과정을 거쳐야 하는데 여기서 Factory 가 create 역할을 수행합니다.팩토리에서 생성된 뷰모델은 반환되기 전에 스토어에 정보를 저장하는 작업을 거칩니다. 그래서 다음에 호출되면 새로 생성하는 것이 아닌 스토어에서 바로 반환합니다.​ViewModel 호출 흐름이 어떻게 되는지 살펴보기  실행 환경 :  액티비티 내 ViewModel을 호출1. Activity에서 ViewModel 변수 설정다음과 같이 뷰모델을 액티비티에서 사용한다고 가정하겠습니다. viewModels() 에 뷰모델 로딩을 위임하여 제가 임의로 정의한 ViewModel 을 불러옵니다.​2. viewModels()viewModels() 내부는 ViewModelLazy 의 반환값을 반환하는 코드로 정의되어 있습니다. 반환 함수는 필요한 뷰모델의 클래스 정보, ViewModelStore , ViewModelProvider.Factory , Extras 을 파라미터로 가집니다.팩토리의 경우는 액티비티에서 사용할 팩토리를 명시하지 않았으면 defaultViewModelProviderFactory 을 사용합니다. 스토어는 액티비티가 가지고 있는 스토어를 사용합니다. Extras 는 팩토리와 마찬가지로 확인해서 null 이면 기본 값을 사용합니다.​3. ViewModelLazy여기서는 캐싱 기법을 사용합니다. cached 변수에 이전에 사용했던 뷰모델 정보를 저장해서 재사용에 대비합니다. 만약 저장된 뷰모델이 없다면 이때부터는 ViewModelProvider 에게 뷰모델을 요청하는 과정을 거칩니다.위 설명대로 프로바이더 객체를 create 로 생성하고 get 을 통해 원하는 뷰모델을 요청합니다. 뷰모델을 불러오는 데 성공했다면 cached 변수에 뷰모델 정보를 저장합니다.​4. ViewModelProvider프로바이더 내 create 를 호출하면 생성자로 ViewModelProviderImpl 이 생성되고 create 다음에 호출하는 get 은 ViewModelProviderImpl 을 통해 뷰모델을 가져오는 작업을 수행합니다.get 을 실행하면 Impl 내 getViewModel 함수가 호출되는데 여기서는 스토어에 뷰모델이 저장되어 있는지 확인하고 있다면 반환하고 없다면 새로 생성하고 반환합니다.​5. createViewModel스토어에 뷰모델 정보가 존재하지 않아 새로 만들어야 하는 상황이라면 팩토리에게 생성을 요청합니다. 팩토리에 의해 뷰모델이 생성되면 마지막에 스토어에 저장하고 반환합니다. 이를 통해 최종적으로 액티비티에 뷰모델이 전달됩니다.​참조Android OverviewViewModel이란 무엇인가? ViewModel 초보를 위한 가이드ViewModel’s Internal working in Android. A full guideDeep dive inside of Android’s ViewModel (Architecture Components)"
  },
  
  {
    "title": "Kotlin Function (2/2) - 고차 함수와 inline",
    "url": "/posts/KotlinHighOrderFunction2/",
    "categories": "CS, 프로그래밍 언어",
    "tags": "Kotlin, Android, 함수형 프로그래밍, 고차 함수, inline",
    "date": "2024-04-01 00:00:00 +0900",
    





    
    "snippet": "Contents      함수 타입과 함수 리터럴    1-1. Intro    1-2. 코틀린 함수 타입    1-3. 함수 리터럴 기반의 람다 표현식과 익명 함수    1-4. 람다 함수와 익명 함수의 반환    1-5. 정리    1-6. 참조        고차 함수와 inline    2-1. Contents    2-2. Intro    2-...",
    "content": "Contents      함수 타입과 함수 리터럴    1-1. Intro    1-2. 코틀린 함수 타입    1-3. 함수 리터럴 기반의 람다 표현식과 익명 함수    1-4. 람다 함수와 익명 함수의 반환    1-5. 정리    1-6. 참조        고차 함수와 inline    2-1. Contents    2-2. Intro    2-3. 고차 함수를 활용해야 하는 이유    2-4. 고차 함수 활용 시 주의사항    2-5. 인라인 함수    2-6. 인라인 관련 추가 기능    2-7. 참조  ​Intro저번 고차 함수와 인라인 1편에서 코틀린 함수가 왜 고차 함수인지 함수 타입과 함수 리터럴을 통해 알아봤습니다. 코틀린은 함수에 대한 타입을 제공하고 이를 통해서 함수를 인자로 활용하거나 반환 값으로 활용할 수 있습니다. 특히 인자로 활용하는 과정에서 함수 리터럴을 활용하면 가독성이 뛰어난 코드 구현이 가능합니다.이런 뛰어난 장점을 가진 고차 함수도 단점은 존재합니다. 이 때문에 코틀린은 고차 함수의 단점을 보완하기 위해 inline 이라는 키워드를 제공하여 고차 함수의 단점을 보완하는 데 도움을 제공합니다.따라서 코틀린이 제공하는 함수형 프로그래밍을 제대로 활용하려면 고차 함수의 장단점이 무엇인지 파악하고 사용해야 합니다. 이번 글에서는 고차 함수가 가지는 장단점이 무엇이며 단점을 해결하기 위한 inline 키워드에 대해 알아보겠습니다.​고차 함수를 활용해야 하는 이유1. 코드 재사용성 및 모듈성특정 기능을 개별 함수로 분리하여 전역의 여러 부분에서 재사용이 가능합니다. 애플리케이션 전역에서 재사용이 가능하다는 점 덕분에 베이스 코드의 유지 관리가 용이하고 중복성을 줄일 수 있습니다.전역의 여러 부분에서 사용하는 확장 함수를 보면 이해가 쉽습니다. 우리가 자주 사용하는 고차 함수 특징을 활용한 forEach , map 등의 확장 함수 베이스 코드는 Collections.kt 파일에서 관리합니다./* _Collections.kt */public inline fun &lt;T, R&gt; Iterable&lt;T&gt;.map(transform: (T) -&gt; R): List&lt;R&gt; {    return mapTo(ArrayList&lt;R&gt;(collectionSizeOrDefault(10)), transform)}public inline fun &lt;T&gt; Iterable&lt;T&gt;.forEach(action: (T) -&gt; Unit): Unit {    for (element in this) action(element)}forEach , map 함수는 둘 다 모든 원소에 대해서 파라미터로 받는 함수 내 정의된 동작을 적용합니다. 따라서 forEach , map 을 호출하는 지점에서 우리는 각 원소에 적용할 동작 코드만 정의하면 됩니다.listOf(1,2,3,4,5,6).map { it+1 } // ex) 각 원소에 1을 더하기 위한 map 사용listOf(1,2,3,4,5,6).forEach { println(it) } // ex) 각 원소를 출력하기 위한 forEach 사용이런 식으로 공통 코드(베이스 코드)를 정의해 놓고 필요한 동작만 함수 파라미터로 우리가 작성해서 전달하면 베이스 코드와 필요한 동작 코드가 분리되어 유지 관리가 편리하고 재사용하기 좋습니다.​2. 추상화와 캡슐화를 통한 분리함수의 구현 세부 사항을 숨기고 필요한 기능만 노출하는 추상화를 가능하게 합니다. 이러한 캡슐화는 보안을 강화하고 복잡한 기능을 단순화합니다. 그리고 관심사를 분리하여 쉬운 유지보수가 가능합니다.forEach , map 을 사용하기 위해 필요한 것은 오직 각 원소에 적용할 동작을 정의하는 것입니다. _Collections.kt 파일에 구현 세부 사항을 정의하고 사용자 정의가 필요한 부분만 함수 파라미터로 받기 때문에 forEach , map 을 사용하는 우리는 필요한 동작만 정의해서 전달하면 됩니다./* _Collections.ktpublic inline fun &lt;T, R&gt; Iterable&lt;T&gt;.map(transform: (T) -&gt; R): List&lt;R&gt; {    return mapTo(ArrayList&lt;R&gt;(collectionSizeOrDefault(10)), transform)}*/fun main() {    listOf(1,2,3,4,5,6).map { it+1 }}​3. 가독성 향상고차 함수의 람다 표현식을 통해서 보다 표현력이 풍부하고 간결한 코드를 작성할 수 있습니다. 특히 코틀린이 주장하는 코틀린의 강력한 장점 중 하나인 함수형 프로그래밍을 위해서 고차 함수의 좋은 가독성은 필수입니다.코틀린 공식 홈페이지를 보면 코틀린의 장점 다섯 가지를 확인할 수 있는데 그중 하나가 함수형 프로그래밍 구현입니다. 고차 함수를 활용하면 다음과 같은 간결하고 명료한 코드 작성이 가능합니다.fun main() {    // Who sent the most messages?    val frequentSender = messages        .groupBy(Message::sender)        .maxByOrNull { (_, messages) -&gt; messages.size }        ?.key                                                 // Get their names    println(frequentSender) // [Ma]    // Who are the senders?    val senders = messages        .asSequence()                                         // Make operations lazy (for a long call chain)        .filter { it.body.isNotBlank() &amp;&amp; !it.isRead }        // Use lambdas...        .map(Message::sender)                                 // ...or member references        .distinct()        .sorted()        .toList()                                             // Convert sequence back to a list to get a result    println(senders) // [Adam, Ma]}data class Message(                                           // Create a data class    val sender: String,    val body: String,    val isRead: Boolean = false,                              // Provide a default value for the argument)val messages = listOf(                                        // Create a list    Message(\"Ma\", \"Hey! Where are you?\"),    Message(\"Adam\", \"Everything going according to plan today?\"),    Message(\"Ma\", \"Please reply. I've lost you!\"),)실제로 위와 같은 고차 함수를 활용한 메서드 체이닝 기법을 사용하면 무슨 동작을 할 것인지에 대해서만 코드를 작성할 수 있기 때문에 코드 가독성 개선에 좋습니다.​고차 함수 활용 시 주의사항  “Using higher-order functions imposes certain runtime penalties: each function is an object, and it captures a closure. A closure is a scope of variables that can be accessed in the body of the function. Memory allocations (both for function objects and classes) and virtual calls introduce runtime overhead.”  Kotlin docs공식 문서에서 말하는 고차 함수 사용 시 발생할 수 있는 부작용입니다. 고차 함수를 사용하면 특정 런타임 페널티가 부과되는데  고차 함수가 객체로 전환되며 클로저를 이용합니다. 클로저는 함수 본문에서 접근할 수 있는 변수의 범위입니다. 메모리 할당(함수 객체와 클래스 모두)와 가상 호출은 런타임 오버헤드를 유발합니다.​코틀린 클로저?  “A lambda expression or anonymous function (as well as a local function and an object expression can access its closure, which includes the variables declared in the outer scope. The variables captured in the closure can be modified in the lambda”  Kotlin docs  “A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment). In other words, a closure gives you access to an outer function’s scope from an inner function. In JavaScript, closures are created every time a function is created, at function creation time.”  MDN - JavaScript코틀린이 설명하는 클로저는 람다 표현식 또는 익명 함수(로컬 함수 및 객체 표현식도 마찬가지)를 사용할 때 외부 범위에서 선언된 변수에 액세스할 수 있는 것을 말합니다.자바스크립트에서 설명하는 클로저는 함수를 주변 상태(어휘 환경)에 대한 참조와 함께 묶음 결합한 것입니다. 다시 말해, 클로저를 사용하면 내부 함수에서 외부 함수의 범위에 접근할 수 있습니다.즉, 종합하면 클로저는 외부 범위에 접근할 수 있는 기능이라고 할 수 있습니다. 한번 생각해 봅시다. 코틀린 반복문인 forEach 을 사용하기 위해  함수 리터럴로 동작 코드를 정의할 때 자연스럽게 외부 변수를 가져다 사용한 경험이 있지 않나요? 다음 예시처럼요.var sum = 0listOf(1,2,3,4).forEach {    sum += it}println(sum)알고 보면 우리는 코틀린을 사용할 때 클로저라는 기능을 지금까지 자연스럽게 사용해 왔습니다. 그렇다면 우린 다음과 같은 생각을 할 수 있습니다.  “그럼 코틀린과 밀접한 자바도 외부 변수에 접근하고 수정도 가능하겠네?”​자바 클로저는 코틀린과 같을까?  “In Android Java world, you know that when you declare a lambda in a function, you can access the parameters of that function as well as the local variables declared before the lambda. These variables are said to be captured by the lambda, but the variables must be final or effectively final to be captured by lambda. In Kotlin, this constraint has been removed.”  “안드로이드 자바 세계에서는 함수에서 람다를 선언하면 해당 함수의 매개변수와 람다 앞에 선언된 로컬 변수에 액세스할 수 있다는 것을 알고 계실 겁니다. 이러한 변수는 람다에 의해 캡처된다고 하지만, 람다가 캡처하려면 변수가 final이거나 effectively final이어야 합니다. Kotlin에서는 이 제약 조건이 제거되었습니다.”  How Kotlin lambda capture variable자바 클로저는 enclosing scope 지역 변수에 접근하려면 해당 변수가 final 혹은 effectively final 이어야 하는 조건이 있습니다. 람다 표현식이나 익명 함수에서 외부 지역 변수를 사용할 경우, 해당 변수를 캡처해서 람다 인스턴스 내부에서 사용할 수 있습니다.String prefix = \"prefix\";Executor executor = Executors.newSingleThreadExecutor();executor.execute(() -&gt; System.out.println(prefix + \"hello world\"));// $FF: synthetic classpublic final class -$$Lambda$Foo$SO0lUY_bGsXMRCTRPJJFcOU0yQM implements Runnable {   // $FF: synthetic field   public final String f$0;   // $FF: synthetic method   public _$$Lambda$Foo$SO0lUY_bGsXMRCTRPJJFcOU0yQM/* $FF was: -$$Lambda$Foo$SO0lUY_bGsXMRCTRPJJFcOU0yQM*/(String var1) {      this.f$0 = var1;   }   public final void run() {      System.out.println(this.f$0 + \"hello world\");   }}위 코드를 보면 f$0  멤버 변수가 외부에서 캡처한 값을 저장합니다. 그 밑을 보면 외부에서 캡처한 정보를 var1 로 가져와서 f$0 에 저장하는 것을 볼 수 있습니다. 굳이 람다 인스턴스 내에서 멤버 변수를 따로 만들어서 외부 지역 변수 값을 복사하는 이유가 뭘까요?람다 인스턴스는 힙에서 관리가 되지만 외부 지역 변수를 포함한 메서드는 스택에서 관리됩니다. 메모리 관리 특성상 메서드가 끝난 이후에도 힙은 계속 남아 있을 수 있기 때문에 람다 내에서 변수를 호출했을 때 변수가 존재하지 않을 가능성이 있습니다. 그래서 람다 인스턴스 내에 따로 멤버 변수를 둬서 해당 문제를 방지하는 것입니다.그런데 인스턴스 내부에 변수를 두고 사용하는 부분에서 위험한 점이 존재합니다. 위에서 람다 인스턴스 내부에서 사용하는 변수는 복사하려는 외부 지역 변수를 캡처한 것이라고 언급했습니다.캡처한 시점의 값을 사용하고 있는데 외부 지역 변수의 값이 변경된다면 값이 일치하지 않는 시점이 생깁니다. 이 부분은 개발자에게 큰 혼란을 야기하기 때문에 자바는 이 상황에서 외부 지역 변수를 final 혹은 effectively final 로 강제해서 값이 다른 상황을 방지합니다.하지만 코틀린은 자바와 다르게 외부 지역 변수 수정이 가능합니다. 코틀린은 함수형 프로그래밍 구현을 강력하게 지원하기 때문에 가능하면 람다나 익명 함수를 이용한 유연한 코드 처리를 지원합니다.​      val 키워드를 이용하여 불변 변수를 람다 표현식에 이용할 때    val prefix = \"Hello\"val threadPool = Executors.newSingleThreadExecutor()threadPool.execute {    println(\"$prefix world\")}        final String prefix = \"Hello\";ExecutorService threadPool = Executors.newSingleThreadExecutor();threadPool.execute((Runnable)(new Runnable() {   public final void run() {      String var1 = prefix + \" world\";      System.out.println(var1);   }}));            var 키워드를 이용하여 가변 변수를 람다 표현식에 이용할 때    var prefix = \"Hello\"val threadPool = Executors.newSingleThreadExecutor()threadPool.execute {    prefix += \" my\"    println(\"$prefix world\")}        final Ref.ObjectRef prefix = new Ref.ObjectRef();prefix.element = \"Hello\";ExecutorService threadPool = Executors.newSingleThreadExecutor();threadPool.execute((Runnable)(new Runnable() {   public final void run() {      Ref.ObjectRef var10000 = prefix;      String var10001 = (String)var10000.element;      var10000.element = var10001 + \" my\";      String var1 = (String)prefix.element + \" world\";      System.out.println(var1);   }}));  /* Hello my world */      ​불변 변수를 이용할 때는 final 키워드가 붙는 자바 방식으로 처리가 되지만 가변 변수를 사용해서 람다 표현식 내에 수정 작업을 하면 final 이 붙지 않고 Ref 라는 객체 참조 클래스를 이용하여 외부 지역 변수와 연결합니다. 이 덕분에 람다 표현식 내에서도 외부 지역 변수 수정이 가능합니다.public class Ref {    private Ref() {}    public static final class ObjectRef&lt;T&gt; implements Serializable {        public T element;        @Override        public String toString() {            return String.valueOf(element);        }    }    public static final class ByteRef implements Serializable {        public byte element;        @Override        public String toString() {            return String.valueOf(element);        }    }    public static final class ShortRef implements Serializable {        public short element;        @Override        public String toString() {            return String.valueOf(element);        }    }    public static final class IntRef implements Serializable {        public int element;        @Override        public String toString() {            return String.valueOf(element);        }    }    public static final class LongRef implements Serializable {        public long element;        @Override        public String toString() {            return String.valueOf(element);        }    }    public static final class FloatRef implements Serializable {        public float element;        @Override        public String toString() {            return String.valueOf(element);        }    }    public static final class DoubleRef implements Serializable {        public double element;        @Override        public String toString() {            return String.valueOf(element);        }    }    public static final class CharRef implements Serializable {        public char element;        @Override        public String toString() {            return String.valueOf(element);        }    }    public static final class BooleanRef implements Serializable {        public boolean element;        @Override        public String toString() {            return String.valueOf(element);        }    }}​고차 함수는 객체 전환 비용이 발생한다클로저 다음으로 알아야 할 것은 고차 함수의 객체 전환 비용입니다. 코틀린은 고차 함수가 사용될 경우, 인자나 반환 값으로 활용되는 함수를 객체로 변환합니다. 그래서 고차 함수를 활용하면 필연적으로 메모리 할당에 대한 오버헤드가 따라올 수밖에 없습니다.말로만 들으면 이해가 잘 안되니 예시로 첫 번째로 함수를 인자로 활용하는 경우를 보겠습니다. 다음과 같이 func 이름의 함수가 함수를 인자로 받아서 이를 내부에서 실행하는 코드가 있습니다.fun func(lambda: () -&gt; Unit) {    lambda()}그리고 이 함수를 다음과 같이 main 영역에서 활용합니다. 이를 실행하면 예상대로 sum 은 1 이 되어 출력됩니다.fun main() {    var sum = 0    func {        sum += 1        println(sum)    }}코틀린 코드는 위와 같습니다. 그렇다면 코틀린에서 자바 코드로 변환될 때는 코드가 어떻게 될까요? 디컴파일을 하면 다음과 같습니다.public static final void main() {    \t\tfinal Ref.IntRef sum = new Ref.IntRef();    sum.element = 0;    func((Function0)(new Function0() {       // $FF: synthetic method       // $FF: bridge method       public Object invoke() {          this.invoke();          return Unit.INSTANCE;       }       public final void invoke() {          ++sum.element;          int var1 = sum.element;          System.out.println(var1);       }    }));}public static final void func(@NotNull Function0 lambda) {    Intrinsics.checkNotNullParameter(lambda, \"lambda\");    lambda.invoke();}고차 함수인 func 의 파라미터(함수를 인자로 받는)가 Function0 이라는 객체로 전환된 것을 알 수 있습니다. 실제로 메인 영역에서 람다 표현식을 전달할 때 new Function0() 코드로 인스턴스를 생성합니다.이번에는 함수를 반환 값으로 활용하는 경우를 보겠습니다. 함수를 인자로 활용하는 예시와 마찬가지로 함수를 반환하는 func 함수를 정의하고 메인 영역에서 호출합니다. 결과는 예상대로 2 가 출력됩니다.fun main() {\t\tval adder = func()    println(adder(1))}fun func() = { n: Int -&gt; n + 1  }이를 자바 코드로 변환하면 다음과 같습니다. func 의 반환되는 함수가 Function1 로 전환이 됐고 해당 인스턴스를 반환합니다. 해당 인스턴스를 받은 메인 영역은 invoke 메서드를 통해 정의했던 함수 - { n: Int -&gt; n + 1  } 를 실행합니다.public static final void main() {  Function1 adder = func();  int var1 = ((Number)adder.invoke(1)).intValue();  System.out.println(var1);}@NotNullpublic static final Function1 func() {  return (Function1)null.INSTANCE;}위의 두 가지 예시를 통해서 우리는 이제 코틀린 공식 문서가 말하는 고차 함수의 런타임 오버헤드가 무엇인지 알 수 있습니다. 고차 함수를 활용하면 인자나 반환 값으로 활용되는 함수를 객체로 전환하고 심지어 외부 변수 사용에 대한 클로저도 객체를 사용합니다.​인라인 함수  “But it appears that in many cases this kind of overhead can be eliminated by inlining the lambda expressions.”  Kotlin docs코틀린은 이러한 문제점을 해결하기 위해 전달되는 인자를 포함해서 고차 함수의 코드를 호출 지점에 인라이닝할 수 있는 기능을 제공합니다. 이것이 inline 키워드입니다.inline 키워드는 fun 앞에 붙일 수 있으며 인라인으로 지정한 함수는 호출 지점에 본인의 코드를 붙여넣습니다. 이를 인라이닝이라고 합니다.​인라이닝위에서 예시로 사용했던 func 함수를 다시 보겠습니다. 다음과 같이 함수를 인자로 받고 내부에서 인자로 받은 함수를 실행하는 코드를 가지고 있습니다.fun main() {    var sum = 0    func {        sum += 1        println(sum)    }}fun func(lambda: () -&gt; Unit) {    lambda()}이것을 inline 함수로 바꾸고 몇 개의 출력문 코드를 추가하겠습니다.inline fun func(lambda: () -&gt; Unit) {    println(\"before lambda()\")    lambda()    println(\"after lambda()\")}이제 func 함수는 인라인 함수가 됐습니다. 자바 코드로 디컴파일 했을 때 코드가 어떻게 변했는지 보겠습니다./* inline 키워드를 사용한 경우 */public static final void main() {  int sum = 0;  int $i$f$func = false;  String var2 = \"before lambda()\";  System.out.println(var2);  int var3 = false;  ++sum;  System.out.println(sum);  var2 = \"after lambda()\";  System.out.println(var2);}/* inline 키워드를 사용하지 않은 경우 */public static final void main() {  final Ref.IntRef sum = new Ref.IntRef();  sum.element = 0;  func((Function0)(new Function0() {     // $FF: synthetic method     // $FF: bridge method     public Object invoke() {        this.invoke();        return Unit.INSTANCE;     }     public final void invoke() {        ++sum.element;        int var1 = sum.element;        System.out.println(var1);     }  }));}인라인 키워드를 사용하게 되면 함수 표현식을 객체에 담아서 전달할 필요 없이 오히려 표현식을 인자로 받는 func 의 코드를 호출 지점으로 불러옵니다.원래라면 함수를 호출하고 준비물로 람다 표현식을 전달하는데 이 과정에서 메모리 관련 오버헤드가 발생하므로 함수 호출 대신에 함수의 내부 코드를 불러와서 오버헤드를 방지하는 것입니다.​인라인 키워드 사용시 주의점자바 바이트 코드 증가오버헤드를 방지한다는 점에서 인라인 키워드는 굉장히 매력적으로 다가옵니다. 그러나 인라인 키워드를 사용하면 호출할 함수의 코드를 호출 지점으로 복사 붙여넣기를 하기 때문에 자바 바이트 코드가 증가한다는 단점이 있습니다.그래서 인라인 키워드는 코드양이 많지 않은 함수에 사용하는 것이 효율적입니다. 코틀린 공식 문서는 크기가 적당한 함수를 인라이닝하면 성능 면에서 이점을 얻을 수 있다고 말합니다.  “Inlining may cause the generated code to grow. However, if you do it in a reasonable way (avoiding inlining large functions), it will pay off in performance, especially at “megamorphic” call-sites inside loops.”  Kotlin docs​함수 타입 파라미터를 사용하는 경우가 아니면 고려가 필요또한 인라인은 함수를 인자로 받는 경우에 사용하는 것이 가장 효율적입니다. 그 이외의 경우에 인라인 키워드를 사용하는 것은 크게 효율적이지 않을 수 있기 때문에 개인이 잘 판단하면 될 것 같습니다.실제로 함수 파라미터가 없거나 reified 타입 파라미터가 없는데 inline 키워드를 사용하는 경우 경고 문구가 뜹니다. 그래도 inline 키워드를 사용하고자 경고 문구를 삭제하고 싶다면 다음 주석을 추가하면 됩니다.@Suppress(\"NOTHING_TO_INLINE\") ​인라인 관련 추가 기능noinline일반적으로 인라인 함수에 전달되는 함수 인자는 모두 인라인 처리됩니다. 그러나 특정 함수 인자를 인라인 처리하고 싶지 않다면 noinline 을 앞에 추가하면 됩니다.inline fun foo(inlined: () -&gt; Unit, noinline notInlined: () -&gt; Unit) { ... }인라인 처리된 람다 표현식은 인라인 함수 내부에서만 호출하거나 인라인 인자로 전달할 수 있습니다. 그러나 비인라인 처리가 된 람다 표현식은 필드에 저장하거나 전달되는 등 원하는 방식으로 조작할 수 있습니다.​crossinline만약 인라인 함수 본문에서 함수 파라미터를 직접 실행하지 않고 다른 실행 컨텍스트에서 실행하고자 한다면 crossinline 을 앞에 추가하면 됩니다.inline 함수는 호출 지점에 코드가 복사되기 때문에 비 지역 반환이 가능하다는 특징이 있습니다. 이 점 때문에 만약 다른 컨텍스트에서 함수 파라미터를 실행한다면 비 지역 반환 제어 흐름이 복잡해질 우려가 있습니다.그래서 크로스 인라인은 다른 실행 컨텍스트에서 함수 파라미터 실행을 허용하지만 비 지역 리턴 기능은 허용하지 않습니다.inline fun f(crossinline body: () -&gt; Unit) {    val f = object: Runnable {        override fun run() = body()    }    // ...}​reified런타임에 타입 파라미터를 파악하고 싶은 경우 사용하는 키워드입니다. 타입 파라미터를 제네릭이라 하는데 제네릭은 컴파일 타임에 타입 검사가 끝나고 런타임에는 타입이 소거됩니다.이러한 특성 때문에 제네릭을 이용한 타입 관련 검사를 시도한다면 오류가 발생할 수 있습니다. 그런데 인라인 함수는 호출 지점으로 코드가 이동하는 특징 덕분에 런타임에도 타입 파라미터 체크가 가능합니다.다음 예시를 보겠습니다. 함수에 제네릭을 사용할 경우 함수 이름 앞에 정의하면 됩니다. 그리고 꺾쇠 안에 reified 키워드를 추가하고 본문에 타입 파라미터 체크 관련 코드를 추가합니다.inline fun &lt;reified T&gt; printGeneric(t: T){    val generic =  when(T::class) {        Char::class -&gt; \"Char\"        String::class -&gt; \"String\"        Int::class -&gt; \"Int\"        Boolean::class -&gt; \"Boolean\"        else -&gt; \"Nothing\"    }    println(generic)}메인 함수는 다음과 같이 정의합니다. 결과는 인라인 함수에서 정의한 대로 정상 출력됩니다.fun main() {    printGeneric('a')}/*    Char      Process finished with exit code 0*/printGeneric 이 메인 영역에 복사되면 다음과 같습니다. 인라이닝 특징 덕분에 문자 타입인 a 와 타입 검사 코드가 메인 영역에 묶여 타입 정보를 런타임에도 알 수 있습니다.public static final void main() {    char t$iv = true;    int $i$f$printGeneric = false;    KClass var2 = Reflection.getOrCreateKotlinClass(Character.class);    String generic$iv = Intrinsics.areEqual(var2, Reflection.getOrCreateKotlinClass(Character.TYPE)) ? \"Char\" : (Intrinsics.areEqual(var2, Reflection.getOrCreateKotlinClass(String.class)) ? \"String\" : (Intrinsics.areEqual(var2, Reflection.getOrCreateKotlinClass(Integer.TYPE)) ? \"Int\" : (Intrinsics.areEqual(var2, Reflection.getOrCreateKotlinClass(Boolean.TYPE)) ? \"Boolean\" : \"Nothing\")));    System.out.println(generic$iv);}​참조Android Interview Questions: 7 - What are the High-order functions in Kotlin?How Kotlin lambda capture variableHigher-order functions and lambdasInline functionsFirst-Class and Higher-Order Functions클로저(Closure): Java와 Kotlin 비교"
  },
  
  {
    "title": "Kotlin Function (1/2) - 함수 타입과 함수 리터럴",
    "url": "/posts/KotlinHighOrderFunction/",
    "categories": "CS, 프로그래밍 언어",
    "tags": "Kotlin, Android, 함수형 프로그래밍, 람다, 익명 함수, inline",
    "date": "2024-03-13 00:00:00 +0900",
    





    
    "snippet": "Contents      함수 타입과 함수 리터럴    1-1. Intro    1-2. 코틀린 함수 타입    1-3. 함수 리터럴 기반의 람다 표현식과 익명 함수    1-4. 람다 함수와 익명 함수의 반환    1-5. 정리    1-6. 참조        고차 함수와 inline    2-1. Contents    2-2. Intro    2-...",
    "content": "Contents      함수 타입과 함수 리터럴    1-1. Intro    1-2. 코틀린 함수 타입    1-3. 함수 리터럴 기반의 람다 표현식과 익명 함수    1-4. 람다 함수와 익명 함수의 반환    1-5. 정리    1-6. 참조        고차 함수와 inline    2-1. Contents    2-2. Intro    2-3. 고차 함수를 활용해야 하는 이유    2-4. 고차 함수 활용 시 주의사항    2-5. 인라인 함수    2-6. 인라인 관련 추가 기능    2-7. 참조  Intro  “Kotlin functions are first-class, which means they can be stored in variables and data structures, and can be passed as arguments to and returned from other higher-order functions. You can perform any operations on functions that are possible for other non-function values.”  Kotlin docsKotlin 함수는 first-class - 일급 함수로, 변수와 데이터 구조에 저장할 수 있으며 다른 상위 함수에 인자로 전달하거나 반환 값으로 활용할 수 있습니다. 즉, 함수에 대한 다양한 연산을 수행할 수 있다는 뜻입니다.이는 자연스럽게 코틀린 함수는 일급 함수뿐만 아니라 함수를 파라미터로 활용하거나 반환할 수 있는 고차 함수(Higher-order functions)에도 해당한다는 것을 알 수 있습니다./* 함수를 파라미터로 사용  */fun &lt;T, R&gt; Collection&lt;T&gt;.fold(    initial: R,    combine: (acc: R, nextElement: T) -&gt; R): R {    var accumulator: R = initial    for (element: T in this) {        accumulator = combine(accumulator, element)    }    return accumulator}/* 함수를 변수로 사용  */val sum: (Int, Int) -&gt; Int = { x: Int, y: Int -&gt; x + y }/* 함수를 반환값으로 사용  */fun adderInitializer(x: Int): (Int) -&gt; Int {    return { it + x }}val adder = adderInitializer(10)println(adder(2))일급 함수와 고차 함수에 해당한다는 이점 덕분에 코틀린 함수는 코드 재사용성과 가독성을 높이고 좀 더 추상적인 구현을 지원합니다. 그렇다면 코틀린 함수는 어떻게 고차 함수이고 어떤 활용 방법이 있을까요? 또한 거기서 나오는 장단점은 무엇이며 이에 대한 보완책은 무엇일까요?이번 포스팅은 코틀린의 고차 함수와 여기에서 발생하는 문제점을 막기 위한 inline 키워드에 대해 알아보고자 합니다. 이를 알기 위해서 먼저 코틀린에서 지원하는 유연한 함수 처리 방법에 대해 알아야 할 필요가 있습니다.​코틀린 함수 타입Common type코틀린은 함수를 변수, 인자, 반환 값으로 활용할 수 있기 때문에 정수는 Int , 문자열은 String 인 것처럼 함수도 코드로 명시할 타입이 필요합니다. 코틀린이 지정한 모든 함수의 공통적인 타입 표기는 다음과 같습니다.(A, B) -&gt; C소괄호 내에 파라미터 목록을 표기하고 파라미터가 없다면 빈 소괄호로 표기합니다. 그리고 -&gt; 을 추가하고 소괄호 내 파라미터 목록을 활용하여 C 타입의 값을 반환합니다.이 방식으로 다음 예제와 같이 함수에 대한 타입을 표기합니다.// ex1(Int) -&gt; String// ex2val onClick: () -&gt; Unit = { /* ... */ }​Option1. Receiver type수신자가 있는 함수 타입으로 정의를 하는 방법도 있습니다. 수신자가 있는 함수 타입 정의는 다음과 같이 수신자와 . 을 앞에 표기합니다. 이렇게 하면 수신자 객체 A 에서 매개변수 B 를 호출하고 C 를 반환하는 동작을 합니다.A.(B) -&gt; C이 방식은 수신자가 있는 함수 리터럴로 인스턴스화 할 수 있습니다. 즉, 람다 표현식이나 익명 함수와 같은 함수 리터럴 본문 내에서 수신자 객체를 암시적 this 로 접근해서 수신자 객체나 멤버에게 접근할 수 있습니다./* Lambda expression */val add: Int.(Int) -&gt; Int = { this.plus(it) }println(2.add(10))println(add(2,10))/* Anonymous function */val add = fun Int.(other: Int): Int = this + otherprintln(2.add(3))println(add(2,3))코드에서 어디서 본 듯한 익숙함을 느끼지 않았나요? 이 동작은 함수 본문 내에서 수신자 객체의 멤버에게 접근할 수 있는 확장 함수의 동작과 유사한 것을 알 수 있습니다.​Option2. Suspend type중단 함수에 대한 타입을 정의하는 방법도 있습니다. 함수 타입 맨 앞에 suspend 키워드를 추가합니다.suspend A.(B) -&gt; C​함수 리터럴 기반의 람다 표현식과 익명 함수Function literals함수 리터럴은 선언되지 않고 표현식으로 즉시 전달되는 함수입니다. 코틀린이 제공하는 람다 표현식과 익명 함수가 함수 리터럴에 해당합니다.Lambda expression/* 람다 표현식 전체 구문 */val sum: (Int, Int) -&gt; Int = { x: Int, y: Int -&gt; x + y }/* 람다로 함수 타입 유추가 가능하므로 함수 타입 생략 가능 */val sum = { x: Int, y: Int -&gt; x + y }/* 함수 타입으로 타입 유추가 가능하므로 파라미터 이름만 만들어서 사용 */val sum: (Int, Int) -&gt; Int = { x, y -&gt; x + y }/* 함수 타입에서 파라미터명 정의해서 사용 */val sum: (x: Int, y: Int) -&gt; Int = { x, y -&gt; x + y }/* 파라미터가 없는 경우는 생략 가능 */val temp: () -&gt; Unit = { println(\"temp\") }  람다 표현식은 항상 중괄호로 둘러싸여 있습니다.  매개변수 선언은 중괄호 안에서, 매개변수 타입은 작성한 문법에 따라 생략이 가능합니다.  함수 본문은 중괄호 내 매개변수 뒤에 위치한  -&gt; 다음에 정의합니다.  람다의 유추된 반환 유형이 Unit이 아닌 경우, 함수 본문 내 마지막 표현식이 반환 값으로 처리됩니다.​Anonymous functionfun(x: Int, y: Int): Int = x + yfun(x: Int, y: Int): Int { return x + y }람다 표현식은 파라미터와 반환식을 통해 반환 값 타입 유추가 가능하기 때문에 반환 타입을 명시하지 않습니다. 하지만 반환 타입 명시가 필요한 경우 람다와 같은 함수 리터럴인 익명 함수를 사용할 수 있습니다.익명 함수는 파라미터와 반환 타입은 일반 함수와 동일한 방식으로 지정되지만, 문맥에서 유추할 수 있는 경우 파라미터 타입은 생략할 수 있습니다./* forEach */ @kotlin.internal.HidesMemberspublic inline fun &lt;T&gt; Iterable&lt;T&gt;.forEach(action: (T) -&gt; Unit): Unit { /* T -&gt; Unit 확인 */    for (element in this) action(element)}/* (Int) -&gt; Unit 형태의 함수 리터럴이 필요 */listOf(1,2,3,4).forEach(fun(item) {println(item)})/* filter */public inline fun &lt;T&gt; Iterable&lt;T&gt;.filter(predicate: (T) -&gt; Boolean): List&lt;T&gt; { /* T -&gt; Boolean 확인 */    return filterTo(ArrayList&lt;T&gt;(), predicate)}/* (Int) -&gt; Boolean 형태의 함수 리터럴이 필요 */listOf(1,2,3,4).filter(fun(item) = item &gt; 0)또한 익명 함수는 표현식을 사용했을 때 반환 타입 추론이 가능하지만 함수 블록을 사용하는 경우에는 반환 타입을 명시해야 합니다. 단, 반환형이  Unit 인 경우는 블록을 사용해도 생략할 수 있습니다.val l = listOf(1,2,3,4)l.forEach(fun(item) { println(item) }) /* Unit 반환형은 함수 블록에서도 생략 가능 */l.filter(fun(item): Boolean { return item &gt; 2 }) /* 함수 블록 사용시 반환형 명시 */l.filter(fun(item) = item &gt; 2) /* 표현식 사용시 반환형 추론 가능 */​람다 함수와 익명 함수의 차이Non-local return코틀린에서 fun 키워드를 사용하는 이름이 있는 명명된 함수와 익명 함수는 레이블이 없는 반환이 가능합니다. 이 덕분에 흔히 사용하는 return 을 반환될 fun 을 명시하는 레이블 없이 사용할 수 있습니다.fun(x: Int, y: Int): Int {  return x + y }반면에 람다 표현식은 fun 키워드 없이 사용되기 때문에 표현식 내부에서 반환을 요청하면 람다를 감싸고 있는 fun 키워드의 함수가 반환됩니다. 즉, 람다 표현식 내에 반환을 요청한다고 해서 람다 표현식 자체를 반환하는 것은 불가능하고 오히려 람다를 감싸고 있는 외부 함수가 영향을 받습니다.람다 컨텍스트가 아닌 외부 함수 흐름을 제어하는 부분을 의식한 건지, 기본적으로 람다 표현식 내부에서 레이블 없는 반환은 금지되어 있습니다.fun foo() {    ordinaryFunction {        return // ERROR: cannot make `foo` return here    }}만약 람다 표현식에서 람다 자체를 반환하고 싶다면 다음과 같이 람다가 실행되는 함수 영역 대한 레이블을 추가해야 합니다. 그러면 람다를 감싸고 있는 fun 키워드의 함수가 반환되지 않고 람다 컨텍스트만 종료됩니다.fun func(lambda: () -&gt; Unit) {    lambda()}fun main() {  func {      return@func  }}이렇게 람다 표현식은 기본적으로 정규화되지 않은 반환을 못하지만 람다 표현식을 인자로 사용하는  inline 키워드가 붙은 함수를 fun 키워드 함수 내부에 호출한다면, 정규화되지 않은 반환이 가능합니다.inline 키워드를 추가한 함수를 호출하면 호출 함수의 코드를 호출 지점으로 붙여넣기 해서 실행합니다. 이러한 특징 때문에 인라인 함수의 람다 표현식은 레이블 없는(정규화되지 않은) 반환이 가능합니다.inline fun func(lambda: () -&gt; Unit) {    println(\"start main function\")    lambda()    println(\"finish main function\")}fun main() {    func {        return    }}start main functionProcess finished with exit code 0위의 코드를 디컴파일해서 보면 다음과 같이 인라인 함수의 코드가 호출 지점에 인라이닝된 것을 확인할 수 있습니다. 인라인 함수의 println(\"start main function\") 이 String var1 = \"start main function\"; 으로 호출 지점에 인라이닝 됐습니다.그리고 첫 문자열 출력 이후에 인자로 전달된 람다 표현식이 실행되는데 람다 표현식 내부에 return 반환도 호출 지점에 인라이닝 되기 때문에 람다 표현식 내 반환 이후 메인 함수는 별다른 작업 없이 종료합니다.public static final void func(@NotNull Function0 lambda) {  int $i$f$func = 0;  Intrinsics.checkNotNullParameter(lambda, \"lambda\");  String var2 = \"start main function\";  System.out.println(var2);  lambda.invoke();  var2 = \"finish main function\";  System.out.println(var2);}public static final void main() {  int $i$f$func = false;  String var1 = \"start main function\";  System.out.println(var1);  int var2 = false;}이러한 반환(람다에 위치하지만 둘러싼 함수를 종료하는)을 Non-local return - 비로컬 반환이라고 합니다. 익명 함수와 다르게 람다 표현식은 조건(인라인 함수 이용)에 따라 비로컬 반환이 가능하다는 차이점이 있습니다.  고차 함수와 인라인 키워드에 대한 자세한 내용은 2편에서 자세히 다룰 예정입니다.​Passing trailing lambdas코틀린은 함수의 마지막 매개변수가 함수인 경우 해당 인자로 전달되는 람다 표현식을 괄호 밖에 배치할 수 있다는 특징이 있습니다. 예시로 Iterable 의 확장 함수인 fold 함수를 보겠습니다.public inline fun &lt;T, R&gt; Iterable&lt;T&gt;.fold(initial: R, operation: (acc: R, T) -&gt; R): R {    var accumulator = initial    for (element in this) accumulator = operation(accumulator, element)    return accumulator}R 타입의 첫 번째 매개변수 다음에 (R,T) -&gt; R 함수 타입이 마지막에 위치해 있습니다. 코틀린이 제공하는 trailing lambda 에 따라서 마지막 함수 인자를 람다 표현식으로 전달할 경우 다음과 같이 괄호 밖에 배치가 가능합니다.val product = items.fold(1) { acc, e -&gt; acc * e }반면에 익명 함수는 괄호 안에 넣어서 전달해야 합니다. 괄호 밖에 함수를 배치할 수 있는 문법은 람다 표현식만 가능합니다.val product = items.fold(1, fun(acc, e): Int { return acc * e})​정리코틀린의 함수는 일급 함수이면서 고차 함수의 조건을 만족합니다. 이에 대한 근거로 함수를 변수, 인자, 반환 값으로 사용하기 위한 함수 타입 문법을 제공하고 이를 이용한 람다 표현식과 익명 함수 기능을 제공합니다.익명 함수는 fun 키워드를 이용한 함수 리터럴이며 자체 반환이 가능하고 반면에 람다 표현식은 fun 키워드 없이 중괄호를 이용한 함수 리터럴이며 조건에 따라 비로컬 반환이 가능하다는 특징을 가지고 있습니다.지금까지 알아본 내용을 토대로 코틀린의 함수가 왜 고차 함수인지 알게 되었으므로 다음 2편에는 고차 함수와 inline 키워드에 대한 내용을 다룰 예정입니다. 이번 포스팅에서 다룬 inline 키워드와 고차 함수에 대한 이해가 더 필요하다면 다음 포스팅을 읽어보는 것을 추천합니다. 감사합니다.​참조Higher-order functions and lambdasFirst-class functionInline functionsReturns and jumps"
  },
  
  {
    "title": "Android Retrofit - 인스턴스 생성과 API Interface의 동작 과정",
    "url": "/posts/Android-Retrofit-01/",
    "categories": "Android, 라이브러리",
    "tags": "Kotlin, Retrofit2, REST API, Android, 레트로핏",
    "date": "2024-03-03 00:00:00 +0900",
    





    
    "snippet": "Retrofit version - 2.9.0Retrofit Intro  A type-safe HTTP client for Android and Java - Square -레트로핏은 Android, Java에서 사용되는 타입 세이프한 Http Client이며 안드로이드 애플리케이션에서 네트워크 요청 및 응답 처리에 대한 과정을 단순화시켜 주는 라이브러리...",
    "content": "Retrofit version - 2.9.0Retrofit Intro  A type-safe HTTP client for Android and Java - Square -레트로핏은 Android, Java에서 사용되는 타입 세이프한 Http Client이며 안드로이드 애플리케이션에서 네트워크 요청 및 응답 처리에 대한 과정을 단순화시켜 주는 라이브러리입니다. 이 라이브러리를 알아보기 전에 레트로핏의 기반이 되는 OkHttpClient 가 무엇인지부터 알아야 할 필요가 있습니다.Square에서 레트로핏 이전에 OkHttpClient 라는 Http Client를 먼저 제공했습니다. 이후에 OkHttpClient의 네트워크 처리 기능 기반에 어노테이션을 이용한 API 인터페이스로 응답을 처리하는 좀 더 높은 수준의 추상화를 추가하게 됐는데 이것이 Retrofit입니다.실제로 레트로핏을 안드로이드 프로젝트에 사용하게 되면, 어노테이션을 이용하여 요청이 처리되는 방법에 대한 인터페이스를 정의하고 해당 인터페이스의 메서드를 호출하는 방식으로 API 응답을 얻습니다.​      OkHttpClient 방식    클라이언트 객체를 생성하고, 요청 처리 방법을 Request 객체로 만들어서 해당 요청을 클라이언트가 처리합니다.    OkHttpClient client = new OkHttpClient();  String run(String url) throws IOException {  Request request = new Request.Builder()      .url(url)      .build();    try (Response response = client.newCall(request).execute()) {    return response.body().string();  }}      ​      Retrofit 방식    요청 처리 방법을 어노테이션을 이용한 인터페이스로 정의하고, 레트로핏 객체를 통해서 인터페이스 내 메서드를 호출할 수 있게 내부적으로 create 합니다. 생성된 이후에 메서드 호출을 통해 응답받습니다.    public interface GitHubService {  @GET(\"users/{user}/repos\")  Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path(\"user\") String user);}  Retrofit retrofit = new Retrofit.Builder()    .baseUrl(\"https://api.github.com/\")    .build();  GitHubService service = retrofit.create(GitHubService.class);Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(\"octocat\");      ​            그러면 여기서 생기는 궁금증                  1. Retrofit 객체 생성 과정은?              2. 인터페이스를 사용가능한 객체로 만드는 과정은?      두 가지 모두 레트로핏 라이브러리 자체에서 처리되기 때문에 내부를 들여다보지 않는 한 단순 인터페이스 정의로 HTTP 통신을 할 수 있다는 것을 완벽히 이해하기는 힘듭니다.따라서 이번 글은 레트로핏의 인스턴스 생성 과정과 전반적인 구조를 훑어보고 인터페이스 메서드 호출이 가능한 이유를 파악하여 Retrofit 라이브러리에 대한 시야를 넓히고자 합니다.​Retrofit 구성하는 클래스와 인터페이스Retrofit 객체 생성과 인터페이스 처리 과정을 알아보기 전에 레트로핏을 구성하는 대표적인 클래스와 인터페이스가 무엇이고 어떤 역할을 하는지 알아야 할 필요가 있습니다. 그리고 각 클래스와 인터페이스를 구성하는 주요한 메서드가 무엇인지도 같이 알아보겠습니다.Callinterface Call : Cloneable { /* ... */ }  “An invocation of a Retrofit method that sends a request to a webserver and returns a response. Each call yields its own HTTP request and response pair.”  웹 서버에 요청 및 응답을 반환하고 HTTP 요청과 응답에 대한 쌍을 생성하는 역할을 합니다.Call 에서 주요하게 볼 부분은 동기, 비동기 처리 방식이 모두 존재한다는 것입니다. 그래서 코틀린에서 지원하는 코루틴과 적절히 섞어 사용한다면 효율적인 부분을 기대할 수 있습니다.​fun execute(): Response  “Synchronously send the request and return its response.”  요청과 응답을 받는 과정을 동기적으로 처리합니다.​fun enqueue(responseCallback: Callback)  “Asynchronously send the request and notify callback of its response or if an error occurred talking to the server, creating the request, or processing the response.”  요청과 응답을 받는 과정을 비동기로 처리합니다.Callback 이라는 파라미터가 있는데 서버 또는 오프라인 요청에 대한 결과를 가져옵니다. 우리는 해당 Callback 인터페이스를 구현하여 결과에 대한 원하는 동작을 정의할 수 있습니다.​​Callbackinterface Callback { /* ... */ }  “Communicates responses from a server or offline requests.”  서버 또는 오프라인 요청의 응답을 전달하는 역할입니다.콜백 메서드는 레트로핏이 가지고 있는 콜백 실행기에 의해 실행됩니다. 만약 콜백 실행기를 따로 설정하지 않는다면 내부에서 지정한 기본 실행기를 사용합니다.기본 실행기는 Platform 클래스에서 가져오는데 여기서 기본 실행기로 처리되는 콜백은 메인 스레드에서 처리되는 것을 알 수 있습니다. 즉, 기본적으로 Android 내에서  콜백은 메인 스레드에서 처리됩니다.@Overridepublic Executor defaultCallbackExecutor() {  return new MainThreadExecutor();}static final class Android extends Platform {\t  /* ... */  static final class MainThreadExecutor implements Executor {    private final Handler handler = new Handler(Looper.getMainLooper());    @Override    public void execute(Runnable r) {      handler.post(r);    }  }}​fun onFailure(call: Call, e: IOException)  “Invoked when a network exception occurred talking to the server or when an unexpected exception occurred creating the request or processing the response.”  서버 통신 과정에서 네트워크 예외, 응답을 처리하거나 요청을 만드는 과정에서 예기치 못한 예외가 발생했을 때 실행됩니다.​@Throws(IOException::class)fun onResponse(call: Call, response: Response)  “Called when the HTTP response was successfully returned by the remote server.”  HTTP 응답이 원격 서버에 의해 성공적으로 반환됐을 때 호출됩니다.여기서 Response  타입의 파라미터를 볼 수 있는데 이것을 통해서 응답 본문을 읽을 수 있습니다. 콜백 인터페이스에 달린 라이브러리 자체 코멘트를 보면 response 는 응답 본문이 close 되기 전에는 유효한 것을 알 수 있습니다.이 부분에 대해서 close 는 레트로핏이 알아서 처리해주므로 우리가 직접 처리해줄 필요는 없습니다. close 와 관련하여 레트로핏 깃허브 이슈에 관련 내용들을 찾을 수 있는데 @Streaming 을 메서드에 사용하지 않는 이상, 내부에서 처리하므로 신경 쓸 필요가 없다고 합니다.close 처리는 OkHttpCall 이라는 Call 구현체와 관련있는데 뒤에서 자세히 다뤄보도록 하겠습니다. 지금은 그냥 response 를 통해서 응답 본문을 얻을 수 있다는 것만 알고 넘어가면 됩니다.​​CallAdapterpublic interface CallAdapter&lt;R, T&gt;   “Adapts a Call with response type R into the type of T. Instances are created by a factory which is installed into the Retrofit instance.”  Call&lt;R&gt; 을 T 로 조정합니다. 콜 어댑터 인스턴스는 레트로핏 인스턴스 내에 설치된 어댑터 팩토리에 의해 생성됩니다.​Type responseType();  *“Returns the value type that this adapter uses when converting the HTTP response body to a Java object. For example, the response type for Call is Repo. This type is used to prepare the call passed to #adapt.\"*  HTTP 응답 본체를 Java 개체로 변환할 때 이 어댑터가 사용하는 값 유형을 반환합니다. 예를 들어 Call&lt;Repo&gt; 에 대한 응답 유형은 Repo 입니다.​T adapt(Call&lt;R&gt; call);  “Returns an instance of T which delegates to call.”  call을 위임하는 T의 인스턴스를 반환합니다.여러 종류의 응답을 핸들링하기 위해 만들어둔 관련 클래스에 R 을 씌우고 싶을 때 콜 어댑터를 사용할 수 있습니다. 예를 들어서 Success , Failure , 여러 네트워크 오류가 담긴 sealed class Resul 가 있다고 한다면 Call&lt;R&gt; 을 Call&lt;Result&lt;R&gt;&gt; 형식으로 리턴하도록 조정할 수 있습니다.T 가 Call&lt;Result&lt;R&gt;&gt; 으로 되는 것입니다. 그렇게 하면 응답을 받는 곳에서 when 을 사용하여 Result.Success , Result.Failure  이런 식으로 깔끔하게 구분할 수 있고 코드의 가독성 향상을 기대할 수 있습니다.​​CallAdapter.Factorypublic interface CallAdapter&lt;R, T&gt; {  abstract class Factory { /* ... */ }}  “Creates CallAdapter instances based on the return type of the service interface methods.”  서비스 인터페이스 메서드의 반환 유형에 기반하여 CallAdapter 인스턴스를 생성합니다.​public abstract @Nullable CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit);  “Returns a call adapter for interface methods that return returnType, or null if it cannot be handled by this factory.”  returnType을 반환하는 인터페이스 메서드에 대한 콜 어댑터를 반환합니다. 만약 팩토리에서 처리할 수 없는 경우 null을 반환합니다.​protected static Type getParameterUpperBound(int index, ParameterizedType type) {  return Utils.getParameterUpperBound(index, type);}  “Extract the upper bound of the generic parameter at index from type. For example, index 1 of Map&lt;String, ? extends Runnable&gt; returns Runnable.”  type 에서 index 값 기준으로 제네릭 파라미터의 상한을 추출합니다. 예시로 index 가 1 인 경우, Map&lt;String, ? extends Runnable&gt; 은 Runnable 을 리턴합니다.​protected static Class&lt;?&gt; getRawType(Type type) {  return Utils.getRawType(type);}  “Extract the raw class type from type. For example, the type representing List&lt;? extends Runnable&gt; returns List.class.”  type 에서 원시 클래스를 추출합니다. 예시로 type 이 List&lt;? extends Runnable&gt; 인 경우, 원시 클래스로 List.class 을 리턴합니다.​​Converterpublic interface Converter&lt;F, T&gt;  “Convert objects to and from their representation in HTTP.”  HTTP 응답 본문을 자바 객체로 변환하거나, 자바 객체를 HTTP 요청의 본문으로 변환하는 작업을 수행합니다. 즉, 서버와 클라이언트 간에 발생하는 데이터 형식의 변환을 담당합니다.​​Converter.Factorypublic interface Converter&lt;F, T&gt; {  abstract class Factory { /* ... */ }}  “Creates {@link Converter} instances based on a type and target usage.”  주어진 타입과 타겟 사용에 기반하여 컨버터 인스턴스를 생성합니다.​Retrofit 인스턴스 생성 과정Builder constructor우선 레트로핏은 인스턴스를 생성하는 데 빌더 패턴을 사용합니다. 빌더 패턴의 특성상, 빌더 클래스 내에서 타겟 인스턴스를 생성하므로 빌더의 생성자부터 보겠습니다.Builder(Platform platform) {  this.platform = platform;}public Builder() {  this(Platform.get());}​Get Platfrom()생성자로 Platform.get() 을 호출하게 되는데 플랫폼 클래스 내에 시스템의 가상 머신 이름으로 플랫폼을 구분하는 메서드가 존재합니다. 안드로이드는  Dalvik VM 이므로 Android() 가 반환됩니다./* Platform.java */class Platform {  private static final Platform PLATFORM = findPlatform();  static Platform get() {    return PLATFORM;  }  private static Platform findPlatform() {    return \"Dalvik\".equals(System.getProperty(\"java.vm.name\"))        ? new Android() //        : new Platform(true);  }    /* ... */}System.getProperty(\"java.vm.name\") 의 반환값이 Dalvik 인 이유는 Android Developer 공식문서에 정리되어 있습니다. System 클래스의 getProperty(String key) 메서드에 대한 설명을 보면 Dalvik 가상머신에서 제공하는 프로퍼티 목록을 확인할 수 있습니다.            Name      Meaning      Example                  java.vm.name      VM implementation name      Dalvik      ​build()이제 빌더 객체의 생성이 완료되어 레트로핏 객체 생성에 필요한 준비물을 전달할 수 있습니다. 여기서 필수로 전달해야 할 정보와 전달하지 않아도 되는 정보가 있는데 이는 build 메서드 코드를 보면 알 수 있습니다.public Retrofit build() {  if (baseUrl == null) {    throw new IllegalStateException(\"Base URL required.\");  }  okhttp3.Call.Factory callFactory = this.callFactory;  if (callFactory == null) {    callFactory = new OkHttpClient();  }  Executor callbackExecutor = this.callbackExecutor;  if (callbackExecutor == null) {    callbackExecutor = platform.defaultCallbackExecutor();  }  // Make a defensive copy of the adapters and add the default Call adapter.  List&lt;CallAdapter.Factory&gt; callAdapterFactories = new ArrayList&lt;&gt;(this.callAdapterFactories);  callAdapterFactories.addAll(platform.defaultCallAdapterFactories(callbackExecutor));  // Make a defensive copy of the converters.  List&lt;Converter.Factory&gt; converterFactories =      new ArrayList&lt;&gt;(          1 + this.converterFactories.size() + platform.defaultConverterFactoriesSize());  // Add the built-in converter factory first. This prevents overriding its behavior but also  // ensures correct behavior when using converters that consume all types.  converterFactories.add(new BuiltInConverters());  converterFactories.addAll(this.converterFactories);  converterFactories.addAll(platform.defaultConverterFactories());  return new Retrofit(      callFactory,      baseUrl,      unmodifiableList(converterFactories),      unmodifiableList(callAdapterFactories),      callbackExecutor,      validateEagerly);}  BaseUrl      해당 정보를 전달하지 않는다면 빌드 과정에서 IllegalStateException 예외가 발생하므로 이 정보는 필수입니다.    Call.Factory      이 정보는 전달하지 않아도 기본으로 OkHttpClient 을 사용하기 때문에 선택사항입니다. 여기서 내부적으로 OkHttpClient 을 이용한다는 것을 알 수 있습니다.    CallbackExecutor      레트로핏을 사용하는  Android 에서 Callback 은 MainThread 에서 처리됩니다. 따라서 커스텀 콜백 실행자가 따로 없다면 기본으로 플랫폼 객체에서 MainThreadExecutor 을 가지고 와서 사용합니다.    CallAdapter.Factory      CallAdapter 을 만드는 역할입니다.  defaultCallAdapterFactories 메서드를 호출해서 기존 리스트에 기본 팩토리를 추가합니다.    Converter.Factory      Converter 를 만드는 역할입니다. 어답터 팩토리와 마찬가지로 BuiltInConverters 객체와 defaultConverterFactories 메서드 호출을 통해 기존 리스트에 추가합니다.    Retrofit      최종적으로 위의 정보들이 Retrofit 인스턴스 생성을 위한 인자로 전달되는데 마지막 인자인 validateEagerly 는 빌드 과정에서 true 로 설정하지 않는다면 false 로 전달됩니다. 이런 과정을 통해 최종적으로 생성된 레트로핏 인스턴스가 반환됩니다.  인터페이스 내부 처리GitHubService service = retrofit.create(GitHubService.class);public &lt;T&gt; T create(final Class&lt;T&gt; service) {  validateServiceInterface(service);  return (T)      Proxy.newProxyInstance(          service.getClassLoader(),          new Class&lt;?&gt;[] {service},          new InvocationHandler() {            private final Platform platform = Platform.get();            private final Object[] emptyArgs = new Object[0];            @Override            public @Nullable Object invoke(Object proxy, Method method, @Nullable Object[] args)                throws Throwable {              // If the method is a method from Object then defer to normal invocation.              if (method.getDeclaringClass() == Object.class) {                return method.invoke(this, args);              }              args = args != null ? args : emptyArgs;              return platform.isDefaultMethod(method)                  ? platform.invokeDefaultMethod(method, service, proxy, args)                  : loadServiceMethod(method).invoke(args);            }          });}  “Create an implementation of the API endpoints defined by the service interface.”  서비스 인터페이스에서 정의한 API 엔드포인트의 구현체를 생성합니다.​validateServiceInterface(service)create 의 가장 첫 번째 작업은 구현할 인터페이스의 적합성 검사입니다. 해당 함수에서는 크게 세 가지를 검사합니다.첫 번째 검사 - 인터페이스가 맞는가?if (!service.isInterface()) {  throw new IllegalArgumentException(\"API declarations must be interfaces.\");}두 번째 검사 - 인터페이스 제네릭이 존재하는가?Deque&lt;Class&lt;?&gt;&gt; check = new ArrayDeque&lt;&gt;(1);check.add(service);while (!check.isEmpty()) {  Class&lt;?&gt; candidate = check.removeFirst();  if (candidate.getTypeParameters().length != 0) {    StringBuilder message =        new StringBuilder(\"Type parameters are unsupported on \").append(candidate.getName());    if (candidate != service) {      message.append(\" which is an interface of \").append(service.getName());    }    throw new IllegalArgumentException(message.toString());  }  Collections.addAll(check, candidate.getInterfaces());}클래스 정보가 담긴 Class&lt;T&gt; 의 클래스 제네릭을 전부 가져오는 getTypeParameters 을 통해서 제네릭을 배열의 사이즈가 0 인지 확인합니다. 제네릭이 하나라도 존재한다면 length 가 0 이 아니기 때문에 예외가 발생합니다. 여기서는 인터페이스에 제네릭이 존재하는 것을 허용하지 않기 때문에 제네릭 없는 인터페이스로 구현 요청을 해야 합니다.getTypeParameters 예시로  만약 HashMap 을 대상으로 호출하면 해시맵은 제네릭으로 &lt;K, V&gt; 두 개를 사용하기 때문에 length 값이 2 가 됩니다. 예시 인터페이스인 GitHubService 는 제네릭이 없기 때문에 위의 조건을 통과합니다.public class HashMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; implements Map&lt;K, V&gt;, Cloneable, Serializable { /* ... */ }public interface GitHubService { /* ... */ }세 번째 검사 - validateEagerly 가 true 인가?if (validateEagerly) {  Platform platform = Platform.get();  for (Method method : service.getDeclaredMethods()) {    if (!platform.isDefaultMethod(method) &amp;&amp; !Modifier.isStatic(method.getModifiers())) {      loadServiceMethod(method);    }  }}  “I’d like an option to do all the reflection &amp; annotation introspection eagerly. When I’m in development, eager validation is worth the cost.”  validateEagerly 도입 배경validateEagerly 은 변수명 그대로 좀 더 자세하게 검사할 것을 원하는지 물어보는 겁니다. 빌드 과정에서 validateEagerly 을 true 로 설정했다면 “인터페이스 검사를 좀 더 확실하게 해주세요” 이렇게 요청하는 거라고 이해하시면 좋을 것 같습니다.true 로 설정했을 때 모든 메서드에 대해서 디폴트 혹은 스태틱인지 검사를 해서 둘 다 해당하지 않으면 메서드를 분석을 진행하는 loadServiceMethod 을 호출합니다. 이 방식은 API 인터페이스를 사용하기 전에 안전하게 모든 메서드 분석을 끝내기 때문에 초기에 에러를 찾아낼 수 있습니다.만약 validateEagerly 가 false 일 경우, API 메서드를 호출할 때 해당 메서드에 대한 loadServiceMethod 가 실행됩니다. 즉, 레트로핏은 기본적으로 호출 메서드에 대한 분석을 Lazy 방식으로 처리합니다.​Proxy.newProxyInstancevalidateServiceInterface(service) 이후에는 프록시 객체를 통해 인터페이스를 구현하게 됩니다. 프록시는 단어의 의미 그대로 원본 객체의 동작을 대신 처리합니다. 레트로핏은 자바의 동적 프록시 객체를 사용하여 런타임에 인터페이스를 구현합니다.일반적으로 프록시는 구현하려는 인터페이스 구조에 맞춰 클래스로 구현해야 합니다. 그런데 구현이 필요한 인터페이스가 한 개가 아닌 여러 개라면, 그만큼 프록시 객체가 많아져서 많은 코드량, 복잡성, 코드 중복 등의 껄끄러운 부분을 피할 수 없습니다.우리가 모바일 애플리케이션을 만든다면 분명 여러 기능을 구현할 테고, 그만큼 정의하는 API 인터페이스의 수가 많아질 것입니다. 일반 프록시 객체를 이용한다면 모든 인터페이스에 대한 프록시를 구현해야 하는 수고가 발생합니다.게다가 모든 API 인터페이스 내 모든 메서드는 서버 통신을 통해 요청에 대한 응답을 가져오는 공통된 동작을 가지고 있습니다. 일반 프록시 객체를 사용한다면, 모든 메서드에 해당 동작이 담긴 동일한 코드를 추가해야 하므로 코드 중복을 피할 수 없습니다.하지만 동적 프록시를 사용하면 한 번 정의해 둔 InvocationHandler 을 가지고 모든 API 인터페이스에 대한 프록시 생성이 가능해서 중복 코드와 구현 노동을 방지할 수 있습니다.동적 프록시를 사용하면 등록한 인터페이스 내에 어떤 메서드를 호출해도 호출된 메서드가 바로 실행되지 않습니다. 호출된 메서드의 정보를 가진 InvocationHandler 의 invoke 함수가 실행되기 때문에 해당 함수 내에 필요한 공통 동작 코드를 정의하면 됩니다.레트로핏에서 정의한 invoke 함수를 보면 메서드가 Object 소속인지, default 인지 확인하는 코드가 있습니다. 우리가 요청한 메서드는 인터페이스 소속입니다. 이는 둘 다 해당하지 않으므로 메서드 분석을 통해 응답을 가져오는 loadServiceMethod(method).invoke(args) 가 리턴값으로 반환됩니다.Proxy.newProxyInstance(    service.getClassLoader(),    new Class&lt;?&gt;[] {service},    new InvocationHandler() {      private final Platform platform = Platform.get();      private final Object[] emptyArgs = new Object[0];      @Override      public @Nullable Object invoke(Object proxy, Method method, @Nullable Object[] args)          throws Throwable {        // If the method is a method from Object then defer to normal invocation.        if (method.getDeclaringClass() == Object.class) {          return method.invoke(this, args);        }        args = args != null ? args : emptyArgs;        return platform.isDefaultMethod(method)            ? platform.invokeDefaultMethod(method, service, proxy, args)            : loadServiceMethod(method).invoke(args);      }    });​loadServiceMethodServiceMethod&lt;?&gt; loadServiceMethod(Method method) {  ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);  if (result != null) return result;  synchronized (serviceMethodCache) {    result = serviceMethodCache.get(method);    if (result == null) {      result = ServiceMethod.parseAnnotations(this, method);      serviceMethodCache.put(method, result);    }  }  return result;}loadServiceMethod(method).invoke(args) 가 무엇인지 알기 위해서 우선 loadServiceMethod 내부로 들어왔습니다. 메서드 이름에서 알 수 있듯이, 이 함수는 API 인터페이스의 method 호출을 HTTP 호출로 만들어 주는 역할을 합니다.그런데 HTTP 호출로 만드는 과정에서 메서드에 붙은 어노테이션 분석을 거치는데, 이는 잠재적 비용이 큰 리플렉션을 사용하기 때문에 한 번 리플렉션을 사용하여 어노테이션을 분석한 메서드는 serviceMethodCache 에 캐싱하여 다음 호출에 재사용합니다.ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);if (result != null) return result;serviceMethodCache 에 method 정보가 존재하지 않는다면 ServiceMethod.parseAnnotations 로 어노테이션 분석을 진행한 다음, 결괏값을 캐싱하고 리턴합니다.synchronized (serviceMethodCache) {  result = serviceMethodCache.get(method);  if (result == null) {    result = ServiceMethod.parseAnnotations(this, method);    serviceMethodCache.put(method, result);  }}return result;​ServiceMethod.parseAnnotationsmethod 를 HTTP 호출 형태로 다듬어서 캐싱하는 것까지 알았으니, 이제는 어떻게 HTTP 호출 형태로 바뀌는지 ServiceMethod.parseAnnotations 내부를 알아보겠습니다. ServiceMethod 구조는 다음과 같습니다.abstract class ServiceMethod&lt;T&gt; {  static &lt;T&gt; ServiceMethod&lt;T&gt; parseAnnotations(Retrofit retrofit, Method method) {    RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);    Type returnType = method.getGenericReturnType();    if (Utils.hasUnresolvableType(returnType)) {      throw methodError(          method,          \"Method return type must not include a type variable or wildcard: %s\",          returnType);    }    if (returnType == void.class) {      throw methodError(method, \"Service methods cannot return void.\");    }    return HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);  }  abstract @Nullable T invoke(Object[] args);}parseAnnotation 은 메서드의 리턴 타입과 어노테이션 분석을 통해서 메서드의 HTTP 호출을 반환합니다. 이때 반환 타입인 HttpServiceMethod 은 ServiceMethod 을 확장한 추상 클래스입니다. 메서드 어노테이션에 대한 분석은 RequestFactory 가 대신 처리하고 분석 결과를 기반으로 HTTP 호출로 다듬는 역할은 HttpServiceMethod 가 합니다.invoke 은 추상 메서드로 호출 메서드의 결과값을 반환합니다. 동적 프록시 객체를 생성할 때 인터페이스 메서드의 결과값으로 loadServiceMethod(method).invoke(args) 을 반환한다는 것을 위에서 설명했습니다. 즉, 이 함수는 우리가 원하는 요청에 대한 서버 응답 값을 제공하는 최종 함수입니다.​RequestFactory.parseAnnotationsstatic RequestFactory parseAnnotations(Retrofit retrofit, Method method) {  return new Builder(retrofit, method).build();}RequestFactory 는 빌더 패턴을 사용하여 빌더 클래스에서 메서드 분석을 진행합니다. build 메서드를 보면 크게 세 가지 작업을 진행합니다.1. 예외 처리발생할 수 있는 여러 변수에 대한 예외 처리를 진행합니다. 각 예외 처리에 대한 메시지를 보면 무엇을 말하는지 알 수 있습니다.if (httpMethod == null) {  throw methodError(method, \"HTTP method annotation is required (e.g., @GET, @POST, etc.).\");}if (!hasBody) {  if (isMultipart) {    throw methodError(        method,        \"Multipart can only be specified on HTTP methods with request body (e.g., @POST).\");  }  if (isFormEncoded) {    throw methodError(        method,        \"FormUrlEncoded can only be specified on HTTP methods with \"            + \"request body (e.g., @POST).\");  }}if (relativeUrl == null &amp;&amp; !gotUrl) {  throw methodError(method, \"Missing either @%s URL or @Url parameter.\", httpMethod);}if (!isFormEncoded &amp;&amp; !isMultipart &amp;&amp; !hasBody &amp;&amp; gotBody) {  throw methodError(method, \"Non-body HTTP method cannot contain @Body.\");}if (isFormEncoded &amp;&amp; !gotField) {  throw methodError(method, \"Form-encoded method must contain at least one @Field.\");}if (isMultipart &amp;&amp; !gotPart) {  throw methodError(method, \"Multipart method must contain at least one @Part.\");}2. 어노테이션 분석메서드에 붙은 모든 어노테이션을 분석합니다.for (Annotation annotation : methodAnnotations) {  parseMethodAnnotation(annotation);}나올 수 있는 HTTP Method에 대해서 조건별 처리를 진행합니다. 여기서 눈에 띄는 부분은 @DELETE , @GET , @HEAD , @PATCH , @POST , @PUT , @OPTIONS 일 경우, 호출하는 parseHttpMethodAndPath 입니다.private void parseMethodAnnotation(Annotation annotation) {  if (annotation instanceof DELETE) {    parseHttpMethodAndPath(\"DELETE\", ((DELETE) annotation).value(), false);  } else if (annotation instanceof GET) {    parseHttpMethodAndPath(\"GET\", ((GET) annotation).value(), false);  } else if (annotation instanceof HEAD) {    parseHttpMethodAndPath(\"HEAD\", ((HEAD) annotation).value(), false);  } else if (annotation instanceof PATCH) {    parseHttpMethodAndPath(\"PATCH\", ((PATCH) annotation).value(), true);  } else if (annotation instanceof POST) {    parseHttpMethodAndPath(\"POST\", ((POST) annotation).value(), true);  } else if (annotation instanceof PUT) {    parseHttpMethodAndPath(\"PUT\", ((PUT) annotation).value(), true);  } else if (annotation instanceof OPTIONS) {    parseHttpMethodAndPath(\"OPTIONS\", ((OPTIONS) annotation).value(), false);  } else if (annotation instanceof HTTP) {    HTTP http = (HTTP) annotation;    parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());  } else if (annotation instanceof retrofit2.http.Headers) {    String[] headersToParse = ((retrofit2.http.Headers) annotation).value();    if (headersToParse.length == 0) {      throw methodError(method, \"@Headers annotation is empty.\");    }    headers = parseHeaders(headersToParse);  } else if (annotation instanceof Multipart) {    if (isFormEncoded) {      throw methodError(method, \"Only one encoding annotation is allowed.\");    }    isMultipart = true;  } else if (annotation instanceof FormUrlEncoded) {    if (isMultipart) {      throw methodError(method, \"Only one encoding annotation is allowed.\");    }    isFormEncoded = true;  }}parseHttpMethodAndPath 의 첫 번째 인자는 Http 메서드 명칭의 String 값입니다. 두 번째 인자는 인터페이스에 메서드를 작성할 때 어노테이션 옆에 적은 URL 의 String 값을 의미합니다. 세 번째 인자는 파라미터명 그대로 Body 를 가졌는지에 대한 논리값을 의미합니다.예시를 보면 @GET 옆에 엔드 포인트 URL 이 있습니다. 해당 문자열 값은 GET 어노테이션 인터페이스 내 value() 메서드로 접근할 수 있습니다.public interface GitHubService {  @GET(\"users/{user}/repos\")  Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path(\"user\") String user);}/* GET.java */@Documented@Target(METHOD)@Retention(RUNTIME)public @interface GET {  String value() default \"\";}parseHttpMethodAndPath 내부로 들어가면 처음엔 HTTP 메서드 종류와 바디 소유 여부를 저장하고, 만약 URL 이 존재하지 않는다면 함수를 종료하는 것을 볼 수 있습니다.URL 이 존재한다면 쿼리가 포함됐는지 확인해서 파라미터 정보를 추출하고 URL 과 함께 저장합니다.private void parseHttpMethodAndPath(String httpMethod, String value, boolean hasBody) {  if (this.httpMethod != null) {    throw methodError(        method,        \"Only one HTTP method is allowed. Found: %s and %s.\",        this.httpMethod,        httpMethod);  }  this.httpMethod = httpMethod;  this.hasBody = hasBody;  if (value.isEmpty()) {    return;  }  // Get the relative URL path and existing query string, if present.  int question = value.indexOf('?');  if (question != -1 &amp;&amp; question &lt; value.length() - 1) {    // Ensure the query string does not have any named parameters.    String queryParams = value.substring(question + 1);    Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(queryParams);    if (queryParamMatcher.find()) {      throw methodError(          method,          \"URL query string \\\"%s\\\" must not have replace block. \"              + \"For dynamic query parameters use @Query.\",          queryParams);    }  }  this.relativeUrl = value;  this.relativeUrlParamNames = parsePathParameters(value);}3. 파라미터 분석마지막은 parseParameter 을 통해 메서드의 모든 파라미터를 분석해서 파라미터별 핸들러를 저장합니다.int parameterCount = parameterAnnotationsArray.length;parameterHandlers = new ParameterHandler&lt;?&gt;[parameterCount];for (int p = 0, lastParameter = parameterCount - 1; p &lt; parameterCount; p++) {  parameterHandlers[p] =      parseParameter(p, parameterTypes[p], parameterAnnotationsArray[p], p == lastParameter);}parseParameter 내부에서는 먼저 파라미터에 붙은 어노테이션을 분석하고 그에 맞는 핸들러를 리턴합니다.ParameterHandler&lt;?&gt; result = null;if (annotations != null) {  for (Annotation annotation : annotations) {    ParameterHandler&lt;?&gt; annotationAction =        parseParameterAnnotation(p, parameterType, annotations, annotation);    if (annotationAction == null) {      continue;    }    if (result != null) {      throw parameterError(          method, p, \"Multiple Retrofit annotations found, only one allowed.\");    }    result = annotationAction;  }}그런데 suspend 함수의 파라미터로 추가되는 Continuation 과 같이 파라미터에 어노테이션이 없는 경우도 있습니다. 이런 경우, Continuation 인지 확인하여 isKotlinSuspendFunction 의 값을 true 로 설정합니다.if (result == null) {  if (allowContinuation) {    try {      if (Utils.getRawType(parameterType) == Continuation.class) {        isKotlinSuspendFunction = true;        return null;      }    } catch (NoClassDefFoundError ignored) {    }  }  throw parameterError(method, p, \"No Retrofit annotation found.\");}여기서 allowContinuation 은 인자로 들어온 파라미터가 마지막 파라미터인지가 맞는지에 대한 값입니다. Continuation 은 함수의 파라미터 중에서 순번이 마지막입니다.그래서 메서드의 모든 파라미터를 차례대로 검사할 때 마지막 파라미터는 Continuation 일 가능성이 있으니 마지막 파라미터 차례가 오면 allowContinuation 을 true 로 설정하여 중단 함수인지 확인하는 것입니다.중단 함수를 확인하는 이유는 만약 호출한 메서드가 중단 함수라면, 서버 응답을 반환하는 과정에서 코루틴을 사용해서 처리하기 위함입니다. 레트로핏은 코루틴을 이용한 처리도 지원하므로 suspend 키워드를 이용해서 API 메서드 호출을 하면 그에 맞춰 내부 코루틴 처리를 통한 응답을 반환합니다.​HttpServiceMethod.parseAnnotationsRequestFactory 을 통해서 메서드의 어노테이션, 파라미터에 대한 분석을 모두 마쳤기 때문에 이제는 이 분석 결과로 HTTP 호출 형태로 만들어야 합니다. HttpServiceMethod 의 parseAnnotations 이 해당 작업을 맡습니다.parseAnnotation 의 초반 작업은 인터페이스 메서드가 중단 함수인지, 일반 함수인지 구분해서 CallAdapter 에 들어갈 타입과 어노테이션을 정합니다.중단 함수인 경우에는 메서드 반환 값이 Response&lt;T&gt; 인 경우와 그렇지 않은 경우를 구분해서 continuationWantsResponse 와 adapterType 을 설정합니다. 일반 함수인 경우에는 바로 메서드 반환 타입에 대한 adapterType 을 설정합니다.static &lt;ResponseT, ReturnT&gt; HttpServiceMethod&lt;ResponseT, ReturnT&gt; parseAnnotations(    Retrofit retrofit, Method method, RequestFactory requestFactory) {  boolean isKotlinSuspendFunction = requestFactory.isKotlinSuspendFunction;  boolean continuationWantsResponse = false;  boolean continuationBodyNullable = false;  Annotation[] annotations = method.getAnnotations();  Type adapterType;  if (isKotlinSuspendFunction) {    Type[] parameterTypes = method.getGenericParameterTypes();    Type responseType =        Utils.getParameterLowerBound(            0, (ParameterizedType) parameterTypes[parameterTypes.length - 1]);    if (getRawType(responseType) == Response.class &amp;&amp; responseType instanceof ParameterizedType) {      // Unwrap the actual body type from Response&lt;T&gt;.      responseType = Utils.getParameterUpperBound(0, (ParameterizedType) responseType);      continuationWantsResponse = true;    } else {      // TODO figure out if type is nullable or not      // Metadata metadata = method.getDeclaringClass().getAnnotation(Metadata.class)      // Find the entry for method      // Determine if return type is nullable or not    }    adapterType = new Utils.ParameterizedTypeImpl(null, Call.class, responseType);    annotations = SkipCallbackExecutorImpl.ensurePresent(annotations);  } else {    adapterType = method.getGenericReturnType();  }    /* ... */}이렇게 해서 만든 adapterType 와 annotation 을 가지고 CallAdapter 을 제작합니다.CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter = createCallAdapter(retrofit, method, adapterType, annotations);그다음은 반환 타입에서 발생할 수 있는 변수를 예외 처리합니다.Type responseType = callAdapter.responseType();if (responseType == okhttp3.Response.class) {  throw methodError(      method,      \"'\"          + getRawType(responseType).getName()          + \"' is not a valid response body type. Did you mean ResponseBody?\");}if (responseType == Response.class) {  throw methodError(method, \"Response must include generic type (e.g., Response&lt;String&gt;)\");}// TODO support Unit for Kotlin?if (requestFactory.httpMethod.equals(\"HEAD\") &amp;&amp; !Void.class.equals(responseType)) {  throw methodError(method, \"HEAD method must use Void as response type.\");}responseType 에 대한 예외처리 검사를 마치면, 해당 값을 가지고 Converter 을 제작합니다.Converter&lt;ResponseBody, ResponseT&gt; responseConverter = createResponseConverter(retrofit, method, responseType);컨버터 제작 이후에는 콜 팩토리를 제작합니다.okhttp3.Call.Factory callFactory = retrofit.callFactory;여기까지 CallAdapter , Converter , Call.Factory 이렇게 세 가지를 만들었습니다. 이 세 가지는 HttpServiceMethod 객체 생성을 위한 생성자로 사용됩니다.객체 생성은 중단 함수를 구분하는 isKotlinSuspendFunction 값을 기준으로 진행됩니다. 레트로핏에서 구현된 HttpServiceMethod 구현체는 일반 함수용 한 개, 중단 함수용 두 개로 총 세 개가 존재합니다.if (!isKotlinSuspendFunction) {  return new CallAdapted&lt;&gt;(requestFactory, callFactory, responseConverter, callAdapter);} else if (continuationWantsResponse) {  return (HttpServiceMethod&lt;ResponseT, ReturnT&gt;)      new SuspendForResponse&lt;&gt;(          requestFactory,          callFactory,          responseConverter,          (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter);} else {  return (HttpServiceMethod&lt;ResponseT, ReturnT&gt;)      new SuspendForBody&lt;&gt;(          requestFactory,          callFactory,          responseConverter,          (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter,          continuationBodyNullable);}​HttpServiceMethod 구현체먼저 일반 함수일 경우, CallAdapted 가 생성됩니다. adapt 가 호출되면 멤버 콜 어댑터를 통해서 adapt 처리를 합니다.static final class CallAdapted&lt;ResponseT, ReturnT&gt; extends HttpServiceMethod&lt;ResponseT, ReturnT&gt; {  private final CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter;  CallAdapted(      RequestFactory requestFactory,      okhttp3.Call.Factory callFactory,      Converter&lt;ResponseBody, ResponseT&gt; responseConverter,      CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter) {    super(requestFactory, callFactory, responseConverter);    this.callAdapter = callAdapter;  }  @Override  protected ReturnT adapt(Call&lt;ResponseT&gt; call, Object[] args) {    return callAdapter.adapt(call);  }}나머지 두 개는 중단 함수 전용으로 SuspendForResponse 와 SuspendForBody 입니다. 이 두 객체의 adapt 처리는 CallAdapted 와는 다르게 코루틴 블럭을 사용하여 처리합니다.두 클래스의 마지막 반환 코드를 보면 KotlinExtensions.kt 내의 메서드를 호출합니다. 여기서 코루틴 블럭을 이용한 비동기 처리를 합니다.static final class SuspendForResponse&lt;ResponseT&gt; extends HttpServiceMethod&lt;ResponseT, Object&gt; {  private final CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt; callAdapter;  SuspendForResponse(      RequestFactory requestFactory,      okhttp3.Call.Factory callFactory,      Converter&lt;ResponseBody, ResponseT&gt; responseConverter,      CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt; callAdapter) {    super(requestFactory, callFactory, responseConverter);    this.callAdapter = callAdapter;  }  @Override  protected Object adapt(Call&lt;ResponseT&gt; call, Object[] args) {    call = callAdapter.adapt(call);    Continuation&lt;Response&lt;ResponseT&gt;&gt; continuation =        (Continuation&lt;Response&lt;ResponseT&gt;&gt;) args[args.length - 1];    try {      return KotlinExtensions.awaitResponse(call, continuation);    } catch (Exception e) {      return KotlinExtensions.suspendAndThrow(e, continuation);    }  }}static final class SuspendForBody&lt;ResponseT&gt; extends HttpServiceMethod&lt;ResponseT, Object&gt; {  private final CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt; callAdapter;  private final boolean isNullable;  SuspendForBody(      RequestFactory requestFactory,      okhttp3.Call.Factory callFactory,      Converter&lt;ResponseBody, ResponseT&gt; responseConverter,      CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt; callAdapter,      boolean isNullable) {    super(requestFactory, callFactory, responseConverter);    this.callAdapter = callAdapter;    this.isNullable = isNullable;  }  @Override  protected Object adapt(Call&lt;ResponseT&gt; call, Object[] args) {    call = callAdapter.adapt(call);    Continuation&lt;ResponseT&gt; continuation = (Continuation&lt;ResponseT&gt;) args[args.length - 1];    try {      return isNullable          ? KotlinExtensions.awaitNullable(call, continuation)          : KotlinExtensions.await(call, continuation);    } catch (Exception e) {      return KotlinExtensions.suspendAndThrow(e, continuation);    }  }}KotlinExtensions.await 의 코드입니다.  suspendCancellableCoroutine 을 이용하여 내부에서 enqueue 을 호출하고 continuation 을 resume 하여 중단 지점에 호출 결과를 전달합니다. 이렇게 하면 중단됐던 지점은 호출 결과를 가지고 함수 실행을 재개할 수 있습니다.suspend fun &lt;T : Any&gt; Call&lt;T&gt;.await(): T {  return suspendCancellableCoroutine { continuation -&gt;    continuation.invokeOnCancellation {      cancel()    }    enqueue(object : Callback&lt;T&gt; {      override fun onResponse(call: Call&lt;T&gt;, response: Response&lt;T&gt;) {        if (response.isSuccessful) {          val body = response.body()          if (body == null) {            val invocation = call.request().tag(Invocation::class.java)!!            val method = invocation.method()            val e = KotlinNullPointerException(\"Response from \" +                method.declaringClass.name +                '.' +                method.name +                \" was null but response body type was declared as non-null\")            continuation.resumeWithException(e)          } else {            continuation.resume(body)          }        } else {          continuation.resumeWithException(HttpException(response))        }      }      override fun onFailure(call: Call&lt;T&gt;, t: Throwable) {        continuation.resumeWithException(t)      }    })  }}​InvokeHttpServiceMethod 객체가 생성되면 이후에 이 객체는 어디로 이동하고 어떤 동작을 할까요? 앞서 살펴본 Retrofit 인스턴스 생성 과정을 차근차근 다시 살펴봅시다.public &lt;T&gt; T create(final Class&lt;T&gt; service) {  validateServiceInterface(service);  return (T)      Proxy.newProxyInstance(          service.getClassLoader(),          new Class&lt;?&gt;[] {service},          new InvocationHandler() {            private final Platform platform = Platform.get();            private final Object[] emptyArgs = new Object[0];            @Override            public @Nullable Object invoke(Object proxy, Method method, @Nullable Object[] args)                throws Throwable {              // If the method is a method from Object then defer to normal invocation.              if (method.getDeclaringClass() == Object.class) {                return method.invoke(this, args);              }              args = args != null ? args : emptyArgs;              return platform.isDefaultMethod(method)                  ? platform.invokeDefaultMethod(method, service, proxy, args)                  : loadServiceMethod(method).invoke(args);            }          });}우리가 호출하는 인터페이스 메서드는 프록시 객체 InvocationHandler 의 invoke 에서 처리되고, 그 결과로loadServiceMethod(method).invoke(args) 이 반환됩니다.즉, 우리가 원하는 API 응답 값은 loadServiceMethod(method).invoke(args) 입니다. loadServiceMethod(method) 은 내부에서 ServiceMethod 을 확장한  HttpServiceMethod  을 반환합니다.결국 loadServiceMethod(method).invoke(args) 은 HttpServiceMethod 의 invoke 라는 결론을 얻게 됩니다.  HttpServiceMethod 의 invoke 함수를 보겠습니다.@Overridefinal @Nullable ReturnT invoke(Object[] args) {  Call&lt;ResponseT&gt; call = new OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter);  return adapt(call, args);}adapt 에 넘길 call 구현체로 OkHttpCall 을 사용합니다. 그리고 위에서 설명한 HttpServiceMethod 의 adapt 를 통해 우리가 원하는 타입의 API 응답을 얻을 수 있게 됩니다.​Retrofit 동작의 전체적인 흐름참조Retrofit And OkHttpSquare RetrofitRetrofit JavadocAndroid Developer - SystemCheat sheet part 1: RetrofitRetrofit GitHub누구나 쉽게 배우는 Dynamic Proxy 다루기Android-Retrofit"
  },
  
  {
    "title": "Kotlin - ArrayList와 MutableList, 무엇을 써야 할까?",
    "url": "/posts/Kotlin-ArrayList-MutableList-Difference/",
    "categories": "CS, 프로그래밍 언어",
    "tags": "Kotlin, Collection, ArrayList, MutableList",
    "date": "2024-02-20 12:00:00 +0900",
    





    
    "snippet": "CollectionKotlin Collection  “The Kotlin Standard Library provides a comprehensive set of tools for managing collections – groups of a variable number of items (possibly zero) that are significant ...",
    "content": "CollectionKotlin Collection  “The Kotlin Standard Library provides a comprehensive set of tools for managing collections – groups of a variable number of items (possibly zero) that are significant to the problem being solved and are commonly operated on.”  Kotlin docs -다양한 프로그래밍 언어에서 문제 해결을 위해 동일하거나 비슷한 의미를 가진 item 들이 하나의 그룹으로 제어된 방식으로 함께 동작하는 Collection 을 사용합니다. 코틀린에서 컬렉션은 4개의 메서드와  Iterable 의 iterator 을 상속받은 구조입니다./** * A generic collection of elements. Methods in this interface support only read-only access to the collection; * read/write access is supported through the [MutableCollection] interface. * @param E the type of elements contained in the collection. The collection is covariant in its element type. */public interface Collection&lt;out E&gt; : Iterable&lt;E&gt; {    public val size: Int    public fun isEmpty(): Boolean    public operator fun contains(element: @UnsafeVariance E): Boolean    override fun iterator(): Iterator&lt;E&gt;    public fun containsAll(elements: Collection&lt;@UnsafeVariance E&gt;): Boolean}​Collection 기반의 List​  List stores elements in a specified order and provides indexed access to them.  Kotlin docs-List 는 지정된 순서로 요소를 저장하고 인덱스를 통한 요소 접근을 제공하는 Collection 기반의 인터페이스입니다. Collection 자체가 읽기만 가능(read-only)하기 때문에 이를 상속받은 List 도 read-only 입니다. 메서드 구성을 보면 읽기 관련만 있는 것을 알 수 있습니다./** * A generic ordered collection of elements. Methods in this interface support only read-only access to the list; * read/write access is supported through the [MutableList] interface. * @param E the type of elements contained in the list. The list is covariant in its element type. */public interface List&lt;out E&gt; : Collection&lt;E&gt; {    override val size: Int    override fun isEmpty(): Boolean    override fun contains(element: @UnsafeVariance E): Boolean    override fun iterator(): Iterator&lt;E&gt;    override fun containsAll(elements: Collection&lt;@UnsafeVariance E&gt;): Boolean      public operator fun get(index: Int): E    public fun indexOf(element: @UnsafeVariance E): Int    public fun lastIndexOf(element: @UnsafeVariance E): Int    public fun listIterator(): ListIterator&lt;E&gt;    public fun listIterator(index: Int): ListIterator&lt;E&gt;    public fun subList(fromIndex: Int, toIndex: Int): List&lt;E&gt;}읽기와 쓰기 작업이 모두 가능한 List - MutableList쓰기 작업도 가능한 컬렉션을 만들기 위해서 코틀린은 Collection 이외에도 MutableCollection 도 제공합니다. 그리고 List 도 요소에 읽기뿐만 아니라 쓰기 작업도 가능한 MutableList 가 존재합니다. 이는 MutableCollection , List 인터페이스 기반입니다.public interface MutableList&lt;E&gt; : List&lt;E&gt;, MutableCollection&lt;E&gt; {    // Modification Operations    /**     * Adds the specified element to the end of this list.     *     * @return `true` because the list is always modified as the result of this operation.     */    override fun add(element: E): Boolean    override fun remove(element: E): Boolean    // Bulk Modification Operations    /**     * Adds all of the elements of the specified collection to the end of this list.     *     * The elements are appended in the order they appear in the [elements] collection.     *     * @return `true` if the list was changed as the result of the operation.     */    override fun addAll(elements: Collection&lt;E&gt;): Boolean    /**     * Inserts all of the elements of the specified collection [elements] into this list at the specified [index].     *     * @return `true` if the list was changed as the result of the operation.     */    public fun addAll(index: Int, elements: Collection&lt;E&gt;): Boolean    override fun removeAll(elements: Collection&lt;E&gt;): Boolean    override fun retainAll(elements: Collection&lt;E&gt;): Boolean    override fun clear(): Unit    // Positional Access Operations    /**     * Replaces the element at the specified position in this list with the specified element.     *     * @return the element previously at the specified position.     */    public operator fun set(index: Int, element: E): E    /**     * Inserts an element into the list at the specified [index].     */    public fun add(index: Int, element: E): Unit    /**     * Removes an element at the specified [index] from the list.     *     * @return the element that has been removed.     */    public fun removeAt(index: Int): E    // List Iterators    override fun listIterator(): MutableListIterator&lt;E&gt;    override fun listIterator(index: Int): MutableListIterator&lt;E&gt;    // View    override fun subList(fromIndex: Int, toIndex: Int): MutableList&lt;E&gt;}MutableList의 구현체 - ArrayListArrayList 는 MutableList 인터페이스의 구현체입니다. 즉, interface 가 아닌 class 입니다. MutableList 의 성질을 가지고 있기 때문에 요소의 읽기, 쓰기가 모두 가능하고 동적 배열로 동작합니다.expect class ArrayList&lt;E&gt; : MutableList&lt;E&gt;, RandomAccess {    constructor()    constructor(initialCapacity: Int)    constructor(elements: Collection&lt;E&gt;)    fun trimToSize()    fun ensureCapacity(minCapacity: Int)    // From List    override val size: Int    override fun isEmpty(): Boolean    override fun contains(element: @UnsafeVariance E): Boolean    override fun containsAll(elements: Collection&lt;@UnsafeVariance E&gt;): Boolean    override operator fun get(index: Int): E    override fun indexOf(element: @UnsafeVariance E): Int    override fun lastIndexOf(element: @UnsafeVariance E): Int    // From MutableCollection    override fun iterator(): MutableIterator&lt;E&gt;    // From MutableList    override fun add(element: E): Boolean    override fun remove(element: E): Boolean    override fun addAll(elements: Collection&lt;E&gt;): Boolean    override fun addAll(index: Int, elements: Collection&lt;E&gt;): Boolean    override fun removeAll(elements: Collection&lt;E&gt;): Boolean    override fun retainAll(elements: Collection&lt;E&gt;): Boolean    override fun clear()    override operator fun set(index: Int, element: E): E    override fun add(index: Int, element: E)    override fun removeAt(index: Int): E    override fun listIterator(): MutableListIterator&lt;E&gt;    override fun listIterator(index: Int): MutableListIterator&lt;E&gt;    override fun subList(fromIndex: Int, toIndex: Int): MutableList&lt;E&gt;}ArrayList 에 대한 actual 클래스를 보면 내부적으로 백업 저장소 역할을 하는 backingArray: Array&lt;E&gt; 를 이용해서 멤버 메서드 동작을 처리하는 것을 알 수 있습니다./* * Copyright 2010-2023 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license * that can be found in the LICENSE file. */package kotlin.collectionsactual class ArrayList&lt;E&gt; private constructor(    private var backingArray: Array&lt;E&gt;,    private var offset: Int,    private var length: Int,    private var isReadOnly: Boolean,    private val backingList: ArrayList&lt;E&gt;?,    private val root: ArrayList&lt;E&gt;?) : MutableList&lt;E&gt;, RandomAccess, AbstractMutableList&lt;E&gt;() {    private companion object {        private val Empty = ArrayList&lt;Nothing&gt;(0).also { it.isReadOnly = true }    }    init {        if (backingList != null) this.modCount = backingList.modCount    }    actual constructor() : this(10)    actual constructor(initialCapacity: Int) : this(            arrayOfUninitializedElements(initialCapacity), 0, 0, false, null, null)    actual constructor(elements: Collection&lt;E&gt;) : this(elements.size) {        addAll(elements)    }    @PublishedApi    internal fun build(): List&lt;E&gt; {        if (backingList != null) throw IllegalStateException() // just in case somebody casts subList to ArrayList        checkIsMutable()        isReadOnly = true        return if (length &gt; 0) this else Empty    }    override actual val size: Int        get() {            checkForComodification()            return length        }    override actual fun isEmpty(): Boolean {        checkForComodification()        return length == 0    }    override actual fun get(index: Int): E {        checkForComodification()        AbstractList.checkElementIndex(index, length)        return backingArray[offset + index]    }    override actual operator fun set(index: Int, element: E): E {        checkIsMutable()        checkForComodification()        AbstractList.checkElementIndex(index, length)        val old = backingArray[offset + index]        backingArray[offset + index] = element        return old    }    override actual fun indexOf(element: E): Int {        checkForComodification()        var i = 0        while (i &lt; length) {            if (backingArray[offset + i] == element) return i            i++        }        return -1    }    override actual fun lastIndexOf(element: E): Int {        checkForComodification()        var i = length - 1        while (i &gt;= 0) {            if (backingArray[offset + i] == element) return i            i--        }        return -1    }    override actual fun iterator(): MutableIterator&lt;E&gt; = listIterator(0)    override actual fun listIterator(): MutableListIterator&lt;E&gt; = listIterator(0)    override actual fun listIterator(index: Int): MutableListIterator&lt;E&gt; {        checkForComodification()        AbstractList.checkPositionIndex(index, length)        return Itr(this, index)    }    override actual fun add(element: E): Boolean {        checkIsMutable()        checkForComodification()        addAtInternal(offset + length, element)        return true    }    override actual fun add(index: Int, element: E) {        checkIsMutable()        checkForComodification()        AbstractList.checkPositionIndex(index, length)        addAtInternal(offset + index, element)    }    override actual fun addAll(elements: Collection&lt;E&gt;): Boolean {        checkIsMutable()        checkForComodification()        val n = elements.size        addAllInternal(offset + length, elements, n)        return n &gt; 0    }    override actual fun addAll(index: Int, elements: Collection&lt;E&gt;): Boolean {        checkIsMutable()        checkForComodification()        AbstractList.checkPositionIndex(index, length)        val n = elements.size        addAllInternal(offset + index, elements, n)        return n &gt; 0    }    override actual fun clear() {        checkIsMutable()        checkForComodification()        removeRangeInternal(offset, length)    }    override actual fun removeAt(index: Int): E {        checkIsMutable()        checkForComodification()        AbstractList.checkElementIndex(index, length)        return removeAtInternal(offset + index)    }    override actual fun remove(element: E): Boolean {        checkIsMutable()        checkForComodification()        val i = indexOf(element)        if (i &gt;= 0) removeAt(i)        return i &gt;= 0    }    override actual fun removeAll(elements: Collection&lt;E&gt;): Boolean {        checkIsMutable()        checkForComodification()        return retainOrRemoveAllInternal(offset, length, elements, false) &gt; 0    }    override actual fun retainAll(elements: Collection&lt;E&gt;): Boolean {        checkIsMutable()        checkForComodification()        return retainOrRemoveAllInternal(offset, length, elements, true) &gt; 0    }    override actual fun subList(fromIndex: Int, toIndex: Int): MutableList&lt;E&gt; {        AbstractList.checkRangeIndexes(fromIndex, toIndex, length)        return ArrayList(backingArray, offset + fromIndex, toIndex - fromIndex, isReadOnly, this, root ?: this)    }    actual fun trimToSize() {        if (backingList != null) throw IllegalStateException() // just in case somebody casts subList to ArrayList        registerModification()        if (length &lt; backingArray.size)            backingArray = backingArray.copyOfUninitializedElements(length)    }    final actual fun ensureCapacity(minCapacity: Int) {        if (backingList != null) throw IllegalStateException() // just in case somebody casts subList to ArrayList        if (minCapacity &lt;= backingArray.size) return        registerModification()        ensureCapacityInternal(minCapacity)    }    \t/* ... */}특히 add 함수 구현 내용을 보면 요소 추가가 가능한지 먼저 체크를 한 후에 요소 추가 작업을 진행하는데 배열 용량이 부족하면 용량을 늘리는 것을 보아 동적 배열인 것을 확인할 수 있습니다.private fun insertAtInternal(i: Int, n: Int) {    ensureExtraCapacity(n)    backingArray.copyInto(backingArray, startIndex = i, endIndex = offset + length, destinationOffset = i + n)    length += n}ArrayList VS MutableList객체 생성시 내부 동작코틀린에서 ArrayList 와 MutableList 둘 다 객체를 생성하는 방식은 ArrayList 클래스를 이용합니다. 생성 방식에 대한 코드는 코틀린 Collections.kt 에서 확인할 수 있습니다.MutableList 을 생성할 때, 내부에서 ArrayList 객체를 생성하여 반환하는 것을 알 수 있습니다. ArrayList 생성은 당연히 ArrayList 객체를 이용합니다.@SinceKotlin(\"1.1\")@kotlin.internal.InlineOnlypublic inline fun &lt;T&gt; mutableListOf(): MutableList&lt;T&gt; = ArrayList()@SinceKotlin(\"1.1\")@kotlin.internal.InlineOnlypublic inline fun &lt;T&gt; MutableList(size: Int, init: (index: Int) -&gt; T): MutableList&lt;T&gt; {    val list = ArrayList&lt;T&gt;(size)    repeat(size) { index -&gt; list.add(init(index)) }    return list}@SinceKotlin(\"1.1\")@kotlin.internal.InlineOnlypublic inline fun &lt;T&gt; arrayListOf(): ArrayList&lt;T&gt; = ArrayList()이를 통해 알 수 있는 것은 결국 ArrayList 와 MutableList 는 이름만 다를 뿐이지 내부에서는 둘 다 ArrayList 을 이용한다는 것입니다. 그래서 이 부분만 봐서는 둘의 차이를 느끼기 힘들기 때문에 다른 부분을 봐야 합니다.사용 목적에 따른 분류객체 생성은 둘 다 ArrayLIst 인스턴스를 생성하므로 동작은 동일합니다. 그렇다면 개발 철학적인 관점에서 사용 이유를 생각해 봐야 합니다.인터페이스인 MutableList 는 객체의 동작만 보면 됩니다. 어떻게 동작하는지는 알 필요가 없습니다. 그냥 인터페이스를 통해 원하는 리스트 동작만 처리해주면 그만입니다.반면에 ArrayList 는 MutableList 를 구현한 클래스입니다. 여기서는 각 동작에 대한 설계 구조를 파악할 수 있고 직접적인 컨트롤이 가능합니다. 따라서 인터페이스처럼 단순 동작에 집중하는 것이 아닌 동작의 원리(구조)에 집중하게 됩니다. ArrayList 의 독자적인 메서드 두 개만 봐도 객체의 메모리 관리에 직접 관여가 가능한 것을 알 수 있습니다./**ArrayList 의 capacity 을 리스트의 현재 사이즈만큼 줄이는 최소화 작업을 하여 메모리 관리를 합니다.*/fun trimToSize()/**필요한 경우 ArrayList 의 용량을 늘려 minCapacity 크기의 요소 수 이상을 유지할 수 있도록 합니다. 만약 공간이 충분할 경우, 추가 작업 없이 return 합니다.*/fun ensureCapacity(minCapacity: Int)결론정리하면 내부 동작에는 관심이 없고 단순히 리스트의 기능이 필요하다면 MutableList ,  ArrayList 의 동작 구조를 파악하여 문제 해결에 적합하다고 판단이 되면 ArrayList 의 사용을 추천하고 있습니다.그리고 MutableList 의 구현체가 지금은 ArrayList 이지만 미래에 이보다 더 나은 다양한 구현 클래스가 제공될 수 있으므로 인터페이스 리스트를 이용하는 것이 미래 변동 사항에 유연하게 대처할 수 있다는 의견도 있습니다.결국 동작 수행은 똑같으므로 본인의 개발 가치관에 따라서 자유롭게 선택하거나 직접 구현해서 사용하면 될 것 같습니다. 직접 구현할 경우, 코틀린에서 사용자의 구현을 돕기 위해 뼈대가 잡혀있는 AbstractionCollection , AbstractList  등의 추상 클래스를 지원하고 있습니다. 참고하시면 좋을 것 같습니다.​  The only difference between the two is communicating your intent.  When you write val a = mutableListOf(), you’re saying “I want a mutable list, and I don’t particularly care about the implementation”. When you write, instead, val a = ArrayList(), you’re saying “I specifically want an ArrayList”.  In practice, in the current implementation of Kotlin compiling to the JVM, calling mutableListOf will produce an ArrayList, and there’s no difference in behaviour: once the list is built, everything will behave the same.  Now, let’s say that a future version of Kotlin changes mutableListOf to return a different type of list.  Likelier than not, the Kotlin team would only make that change if they figure the new implementation works better for most use cases. mutableListOf would then have you using that new list implementation transparently, and you’d get that better behaviour for free. Go with mutableListOf if that sounds like your case.  On the other hand, maybe you spent a bunch of time thinking about your problem, and figured that ArrayList really is the best fit for your problem, and you don’t want to risk getting moved to something sub-optimal. Then you probably want to either use ArrayList directly, or use the arrayListOf factory function (an ArrayList-specific analogue to mutableListOf).  stackoverflow - Difference between ArrayList() and mutableListOf() in Kotlin​  Under the covers, both mutableListOf() and arrayListOf() create an instance of ArrayList. ArrayList is a class that happens to implement the MutableList interface.  The only difference is that arrayListOf() returns the ArrayList as an actual ArrayList. mutableListOf() returns a MutableList, so the actual ArrayList is “disguised” as just the parts that are described by the MutableList interface.  The difference, in practice, is that ArrayList has a few methods that are not part of the MutableList interface (trimToSize and ensureCapacity).  The difference, philosophically, is that the MutableList only cares about the behaviour of the object being returned. It just returns “something that acts like a MutableList”. The ArrayList cares about the “structure” of the object. It allows you to directly manipulate the memory allocated by the object (trimToSize).  The rule of thumb is that you should prefer the interface version of things (mutableListOf()) unless you actually have a reason to care about the exact details of the underlying structure.  Or, in other words, if you don’t know which one you want, choose mutableListOf first.  stackoverflow - Difference between ArrayList() and mutableListOf() in Kotlin참조stackoverflow - Difference between ArrayList() and mutableListOf() in KotlinKotlin docs - ArrayListKotlin docs - MutableListKotlin docs - Collection"
  },
  
  {
    "title": "Goodbye, 2023! Welcome, 2024! - [2023년 개발 회고]",
    "url": "/posts/Review2023/",
    "categories": "블로그, 회고록",
    "tags": "2023년 회고록, 개발자, 개발 회고",
    "date": "2024-01-24 12:00:00 +0900",
    





    
    "snippet": "2024년을 맞이하며눈 깜짝할 사이에 2023년이 끝났다. 2023년은 여러 이벤트가 겹치면서 다양한 경험을 할 수 있었다. 사용하는 기술 스택에 대한 이해가 이전보다 나아졌고 무엇보다도 확실한 협업 경험을 통해 협업 능력이 높아진 부분에 대해서 상당히 만족하는 한 해였던 것 같다.이런 소중한 경험들을 머릿속에 두었다간 금방 잊힐 게 눈에 보여서 블로...",
    "content": "2024년을 맞이하며눈 깜짝할 사이에 2023년이 끝났다. 2023년은 여러 이벤트가 겹치면서 다양한 경험을 할 수 있었다. 사용하는 기술 스택에 대한 이해가 이전보다 나아졌고 무엇보다도 확실한 협업 경험을 통해 협업 능력이 높아진 부분에 대해서 상당히 만족하는 한 해였던 것 같다.이런 소중한 경험들을 머릿속에 두었다간 금방 잊힐 게 눈에 보여서 블로그 글로 23년의 경험들을 정리하고자 한다. 그리고 이왕 회고 글 작성을 시작한 김에 2023년을 시작으로 계속해서 1년 단위 회고를 작성하고자 한다. 해마다 계속해서 쌓이는 회고들을 보면서 내 성장 과정을 확인한다면 뭐라도 느끼는 게 있지 않을까 싶어서다.이 글이 나중에 뭐 어떤 식으로든 도움이 되길 바라며 이야기를 시작하겠다.목차1. 팀 리더로서 첫 프로젝트2. GDSC, 2년의 마침표3. 해커톤 최우수상4. 2023 총정리5. 2024 목표​첫 번째 이야기 - 팀 리더로서 첫 프로젝트첫 프로젝트 리더2023년 3월부터 6월까지는 대학교에 다닌 시기다. 4학년 1학기였고 졸업 필수조건인 캡스톤 강의를 수강해야 했다. 캡스톤은 학교에 협력하는 여러 기업에서 필요로 하는 기능이나 서비스를 강의를 수강하는 학생들이 팀을 이루어 개발하는 졸업 프로젝트다. 그래서 캡스톤을 수강한 학생이라면 최소한 한 번의 프로젝트 경험을 얻게 된다.나는 대학교 개강 전에 미리 연락을 돌려 캡스톤 팀원을 모으고자 했는데 당시에 활동하고 있던 개발 커뮤니티에서 합을 맞춰본 지인을 섭외하는 데 성공했다. 그리고 나머지 두 자리는 내가 섭외했던 지인이 두 명을 데리고 왔다. 팀원은 총 4명이고 나는 모바일 개발, 한 명은 웹 개발, 나머지 두 명은 서버 개발을 맡았다.팀 구성이 끝나고 여러 기업이 요구하는 과제를 둘러봤는데 우리 팀 구성에 맞는 프로젝트가 딱 한 개 있었다. 반려동물 케어 서비스를 요구하는 프로젝트였다. 모바일, 웹, 서버 개발이 모두 가능했기에 주저 없이 해당 프로젝트를 선택했다.팀도 구성했고 프로젝트 선택도 끝났으니 마지막으로 팀장을 뽑는 시간을 가졌다. 팀원 모집할 때 내가 섭외했던 지인을 포함해서 나머지 팀원들에게 혹시 팀장을 맡을 의향이 있는지 물어봤는데 원하지 않는 눈치였다. 그래서 마침 팀장으로서의 포지션도 경험하고 싶었던 내가 맡기로 했다.기획모든 준비가 끝났고 본격적으로 기획 회의에 들어갔다. 기획부터 쉽지 않았다. 시중에 서비스하는 반려동물 케어 관련 서비스들을 확인했는데 웬만한 것들은 다 있어서 어떻게 차별성을 만들지 아주 많은 고민을 했다. 그래서 2~3번의 기획 회의를 진행했고 결론은 다음과 같다.반려인과 동반으로 여행하는 반려동물의 안전을 위해서 반려동물에 맞춘 여행지 정보 제공 및 리뷰 제공 서비스를 하기로 했다. AI 기술을 이용한 서비스 개발은 팀 구성을 봤을 때 불가능하고 짧은 시간 내에 프로젝트를 마무리해야 해서 충분히 시도해볼만한 주제를 탐색했다. 이를 고려하여 위와 같은 주제를 선택했고 유사 서비스를 벤치마킹하여 좀 더 세밀하게 정보를 제공한다는 목표로 기획을 마무리했다.UI 디자인두 번째 난관에 봉착했다. 어려웠던 기획을 끝내고 모바일 UI/UX 디자인을 시작했는데 이 부분도 굉장히 어려웠다. 시각적인 요소들을 다루는 걸 좋아해서 평소에 UI/UX 디자이너 영상을 챙겨보는 편인데 막상 영상에서 배웠던 걸 적용하려 하니까 쉽지 않았다.그래서 강의 영상과 구글링해서 배우는 것 이외에도 야놀자, 여기어때, 토스 앱의 UI/UX를 참고했다. 카테고리 배치와 리스트와 배치 등을 참고하여 내 나름대로 디자인을 해봤다.잘 만들어진 디자인 시스템을 이용해서 제작하는 게 좋을 것 같다고 판단하여 Material Design을 사용하기로 결정했다. 구글 디자인 시스템인 Material Design에서 제공하는 UI 컴포넌트에 최대한 맞춰서 설계하고자 했고 가능한 단순하게 구성하려고 노력을 많이 했다. 근데 막상 다 만들고 보니까 단순한데 복잡(?)한 느낌이 좀 들었다.프로그래밍모바일 UI/UX 디자인을 마치고 본격적으로 개발을 진행했다. 이때는 서버 담당 인원들과 회의를 진행하면서 API 설계 방식에 대한 회의를 최대한 많이 진행해서 API를 연결하는 데 지장이 가지 않도록 했다. 그리고 서버 담당 인원들의 진행속도에 맞춰서 개발을 진행했다.Android 설계 방식에 관해 얘기를 해보자면 22년 여름으로 거슬러 올라간다.  당시 여름에 처음 나갔던 해커톤에서 팀원이 설정한 프로젝트 구조를 통해 아키텍처 컴포넌트를 처음으로 경험해봤다. 당시에 ViewModel , LiveData , Coroutine 등을 몰라서 코딩하는 시간보다 해당 개념들을 이해하는 데 시간을 많이 소비했다.또한 프로젝트를 Ui , Data 층으로 분류해서 관리하는 법도 처음 경험했다. 이전까지는 액티비티나 프래그먼트에 모든 코드를 때려박았으니  View 와 ViewModel 이 무엇인지, Data 층에서 Repository , DataSource 가 무엇인지 몰랐다. 이것도 최대한 이해하려고 발버둥을 쳐봤는데 결국 한 10%만 조금 이해하고 팀원이 먼저 작성한 코드를 보면서 그대로 따라 하는 식으로 어떻게든 코딩을 했다. 결국, 미완성으로 제출하고 마무리했다.​​  새로운 목표 - 해커톤 대회에서 사용했던 설계 방식을 스스로 1부터 100까지 해보자해커톤 대회를 마치고 대회에서 처음 써봤던 개념들을 차근차근 학습하면서 각 개념의 역할을 이해하고자 했고 이때 새로운 목표를 세웠다. 해당 목표를 완수하기 위해서 마침 혼자서 앱 개발을 진행해야 했던 캡스톤 프로젝트로 도전했다.결과는 성공적이었다. 해커톤 때는 팀원이 작성한 예시코드를 단순히 따라서 만드는 식으로 진행했기 때문에 코딩해도 내가 사용하는 라이브러리나 구조에 대한 이해가 전혀 안 됐다. 하지만 캡스톤 프로젝트에서는 내가 직접 프로젝트를 생성하고 세팅부터 마무리까지 하니까 이전에는 보이지 않던 이유들이 보이기 시작했던 것 같다.덕분에 DI Retrofit ViewModel LiveData  등등.. 이런 여러 라이브러리의 역할을 이해할 수 있었다. 물론 해당 라이브러리들을 완벽하게 이해한 것은 절대 아니다. 역할과 다른 라이브러리와 연결되는 흐름 정도만 조금 이해했다고 할 수 있는 정도가 되겠다.퀄리티를 높이기 위한 생성형 AI 적용캡스톤 프로젝트의 가장 중요한 부분이고 가장 잘한 선택이었다고 말할 수 있다. 기존에 기획했던 목표치 개발을 무사히 완료하고 오류를 검토하는 단계로 넘어갔는데 한 가지 고민이 생겼다. “여기서 좀 더 보완하거나 강화할만한 요소가 있을까?”그런데 서버 담당이었던 팀원이 챗 GPT API 얘기를 꺼냈다. 나는 그걸 듣고 AI 챗봇 기능을 생각했고 바로 해당 인원과 얘기를 해서 GPT API 적용이 가능한 조건의 상황인지 파악했다. 이게 적용하기만 하면 여행지 정보를 찾는 과정 자체가 굉장히 단순해져서 AI API 연결이 가능하다면 하면 무조건 추가하고 싶은 마음이 컸다.그래서 로직 흐름 작성 및 간단한 테스트를 진행해본 결과, 충분히 적용 가능하다는 결론이 나왔다. 나는 바로 AI 챗봇 느낌으로 구현하는 계획을 진행했다. 적용 방법은 다음과 같다.0. 서버에서 관리하는 장소 데이터들을 GPT에 제공하여 학습시키기.1. 사용자가 질문을 입력하면 해당 질문에 대한 문자열을 서버로 전송해서 서버에서 GPT API를 호출한다. 2. 해당 호출의 결과는 서버로 다시 전송될 것이고 서버는 이 결과를 클라이언트에 최종 전달한다. 3. 클라이언트(Android)는 서버로부터 받은 결과물을 화면에 출력한다.​​UI는 흔히 볼 수 있는 챗봇 UI 느낌으로 제작했다. 사용자가 질문을 입력하면 답변을 띄우기 전까지 프로그래스 바를 이용해서 사용자 요청이 정상적으로 처리되고 있음을 나타냈다. 프로그래스 바에 사용된 이미지 파일은 로티(Lottie)에서 가져왔다.리사이클러 뷰를 기반으로 아이템을 동적 추가하는 방식으로 설계를 했다. 그래서 사용자가 처음에 챗봇 페이지에 들어가면 빈 공간이 나오고 질문에 대한 답변이 추가되면 위에서 아래로 쌓인다. 질문이 많아지면 스크롤을 해서 볼 수 있도록 스크롤 뷰도 추가했다.사진에 나오는 강릉 경포해변, 라마다 호텔앤스위트, 서울남대문은 실제로 해당 앱에서 제공하는 여러 장소 중 하나다. 이런 식으로 사용자가 여러 과정 필요없이 챗봇을 이용해서 바로 요약된 답변을 받아 볼 수 있다.결과결과는 최고학점인 A+ 을 받았다. 다 팀원들이 모두 열심히 참여해준 덕이다 :)기업 멘토님의 평가여태 맡았던 팀 중에서 가장 잘한 팀이라는 칭찬을 받았다. 뭔가 기획한 서비스가 대단한 것도 아니고 유사 서비스를 이길 수 있는 강력한 무기가 있는 것도 아니어서 이 정도 칭찬을 들을 정돈가 싶었다. 그래도 기획한 부분을 깔끔하게 완료했고 오히려 기존 기획에서 AI챗봇을 추가한 부분에 대해서 좋게 봐주신 것 같다.교수님들 평가기획 관련해서 여러 질문을 해주셨다. 엄청나게 깊은 질문은 아니고 그냥 이 서비스를 기획한 이유라던가 다른 서비스와의 차이점 같은 간단한 질문이었다.개발 관련 질문도 나왔는데 AI에 관한 내용이었다. 챗봇 기능을 위해 사용한 챗 GPT의 버전이 무엇이며 해당 기술의 정보 신뢰성에 대한 질문을 받았다. 교수님들이 봤을 때는 GPT API가 항상 우리가 원하는 답을 주는 것도 아니고 거짓된 정보도 제공할 수 있기 때문에 이에 대해서 기술적인 해결시도가 있었는지를 알고 싶어서 물어보신 것 같다.우리 팀도 이 부분을 몰랐던 것은 아니다. 이를 어느 정도 해결하기 위해서는 1차로 좀 더 비싸고 성능 좋은 GPT API를 사용해야 한다. 그리고 2차는 우리가 기술적으로 설계를 탄탄하게 해서 사용자에게 신뢰성 있는 정보를 제공하는 것이다. 하지만 우리에겐 돈도 많이 없었고 챗봇 기능을 거의 캡스톤 막바지에 추가했기 때문에 기능을 리뷰할 시간도 많이 없었다. 그래서 교수님들의 질문에 대해선 이 부분을 솔직하게 말씀드렸다.프로젝트를 마무리하며 좋았던 점우선 팀장으로서 팀원들을 이끌고 프로젝트를 하는 경험은 처음이었는데 팀원으로서 프로젝트에 참여했을 때와는 다르게 신경써야 하는 범위가 매우 컸다. 팀장이라 직접 노션에 협업 페이지를 만들고 회의, 팀원 케어, 보고서 작성, 일정 조율을 주도적으로 했는데 협업 능력치가 이전보다 성장한 것 같아서 이 부분에 대해선 굉장히 만족한다.그리고 서비스 기획부터 완성 발표까지 처음과 끝을 다 경험해서 나중에 기획자와 디자이너의 협업 기회가 생기면 잘할 수 있겠다는 자신감이 생겼다. 기획과 디자인의 고충을 이번 프로젝트로 뼈저리게 느꼈다…마지막으로 팀 분위기가 처음부터 끝까지 열정적이어서 매우 좋았다. 같이 으쌰으쌰하는 분위기라 나도 열심히 참여했고 다른 팀원들도 열심히 참여했다. 팀장으로서 팀 분위기를 좋게 하려고 연예인 매니저 빙의해서 케어를 했는데 팀원들이 잘 받아주고 잘 참여해줘서 너무나도 고마웠다.프로젝트를 마무리하며 아쉬웠던 점챗봇 AI 기능을 개선할 시간이 부족했던 게 너무 아쉬웠다. 프로젝트 막바지에 챗봇 기능을 추가해서 뭔가 개선할 수 있는 시간이 좀 부족했던 것 같다. AI 기술을 처음 다뤄서 굉장히 재밌게 개발했는데 나중에 AI 기술을 다뤄볼 기회가 또 생기면 그때는 제대로 만들어보고 싶다.또 다른 아쉬운 점은 기업이랑 협력해서 과제를 수행하는 방식인데 우리 팀은 기업으로부터 도움을 받은 게 별로 없었다는 것이다. 초반 기획에는 화상회의를 통해서 기획에 대한 여러 피드백을 받을 수 있어서 좋았다. 하지만 멘토로 참여했던 기업 대표이사님이 기획자 위치라 기획이 완료된 이후의 과정에서는 우리끼리 모든 걸 정하고 진행할 수밖에 없었다.UI/UX, 기술적인 설계에 대한 도움이 가장 필요했는데 해당 피드백은 어려울 것 같다는 답변을 받아서 우리가 직접 검토하면서 진행을 했다. 만드는 건 문제가 되지 않았지만, 문제점 없이 만들었는지에 대한 점검은 우리 수준에서 어려웠던 것 같다.​두 번째 이야기 - GDSC, 2년의 마침표21년에 합격해서 시작했던 구글 학생 개발자 클럽인 GDSC  활동을 드디어 23년 6월 중순에 마무리했다. 약 2년의 기간 동안 다양한 활동들을 했었는데 나에게 정말 좋은 추억으로 남았다. 이 활동을 통해서 개발자라는 목표를 더욱 돈독히 다지게 됐으니 말이다.시작은 군대에서 우연히 보게 된 영상으로부터나는 원래 군대에 가기 전까지는 개발자가 되는 것을 원하지 않았다. 과는 컴퓨터공학부였지만 단순히 고등학교 성적에 맞춰서 선택해서 들어온 학과고 이 때문에 목표의식이 없는 채로 1학년을 마무리했다. 그리고는 그 상태 그대로 입대를 했다. 훈련소에서 새벽 불침번을 하면서 혼자 미래에 대한 생각을 해봤는데 뭔가 스스로 변화가 필요하다는 것을 느꼈다.그래서 훈련소를 수료하고 자대에 가자마자 평생 해보지도 않았던 헬스를 시작했다. 제대로 해보고 싶어서 유튜브로 운동 영상을 찾아봤고 벌크업을 위해서 식사량을 엄청나게 늘렸다. 그 결과, 말랐던 몸이 건강한 근육질로 바뀌었고 특급전사까지 달성하는 쾌거를 이루었다. 아마 이때를 기점으로 새로운 것에 도전하고 성취하고자 하는 가치관이 만들어진 것 같다.이때 이후로 군대에서 할 수 있는 여러 큰 도전을 해본 것 같다. 평생 남들 밑에서 조용히 지내던 내가 팀의 리더인 분대장을 자원해서 팀을 이끄는 일도 하고 공도 제대로 차본 적 없는 내가 족구에 도전해서 대대 족구 대회를 우승하는 경험도 했다. 내가 뭔가를 시작하면 끝을 봐야 하는 성격이라 덕분에 결과가 모두 좋게 나온 것 같다.손을 대는 것마다 성과가 엄청나니까 진로에 대한 자신감도 생기게 되었다. 그래서 이왕 컴퓨터공학부로 입학했으니 전공을 살리기로 마음을 먹고 유튜브에 개발자 관련 영상을 찾아보기 시작했다.그렇게 영상을 보던 중에 눈에 띄는 제목의 한 영상을 발견했다. Interactive Developer 라는 멋있는 이름이 달린 채널이었다. 디자이너와 개발자를 동시에 수행하는 구글 직원이었는데 궁금해서 그 사람이 올린 본인 포트폴리오 영상을 봤다.  미적인 영감을 프로그래밍으로 구현하는 모습을 보고 감탄을 했다. 코딩의 대단함을 이때 많이 느꼈던 것 같다.  출처 - jongmin kim blog그리고 군대에 있던 20년도에 ＇하트시그널3＇이라는 프로그램이 유행했다. 딱히 개인 시간에 할 게 없어서 한 번 봤는데 남자 출연자 중에서 금융 관련 스타트업에서 일하는(현재 퇴사) 개발자가 있었다. 개발자로서 어떤 사람인지 호기심에 유튜브 검색을 해봤는데 엄청난 인물이었다. 실력은 당연하고 직업 가치관이 굉장히 멋있었다. 이런 멋있는 가치관과 직업에 대한 애정에 반해서 개발자라는 직업에 좀 더 흥미를 붙이게 된 것 같다.  출처 - 아무튼 출근  출처 - eo 천인우​이를 통해 전역 후에 개발 역량을 높이는 방법을 생각해봤다. 혼자서 개발 공부를 하는 것보다는 동아리나 학회에 들어가서 잘하고 열심히 하는 사람들 밑에서 공부하는 게 성장하는 데 유리할 것 같다는 생각을 했다. 그래서 대학생 커뮤니티인 에브리타임에서 동아리나 학회 모집 공고를 챙겨보기 시작했고 거기서 GDSC 모집 글을 발견했다. 커리큘럼도 괜찮았고 구글 후원의 행사도 다양해서 여기 아니면 안 된다는 마음으로 지원을 넣었고 운 좋게 합격해서 활동을 시작하게 되었다.21-22 개발 새내기의 도전GDSC에 합격한 후, 다양한 사람들과 다양한 활동들을 경험했다. 들어가자마자 안드로이드 개발 공부를 팀 스터디 형식으로 진행했다. 팀 스터디 자체를 처음 해보고 안드로이드 개발도 처음 해보는 거여서 같이 하는 사람들한테 민폐 안 끼치려고 정말 열심히 했다.안드로이드에 어느 정도 익숙해졌을 때 구글에서 전 세계 대학생들을 상대로 여는 솔루션 챌린지 대회에 참가했다. 이 대회가 내 첫 프로젝트였다. 이때 세 명이 함께 한팀을 이루고 채식주의자를 위한 레시피 정보 제공 애플리케이션을 개발했다. 프로젝트가 처음이었던 나는 깃허브 사용도 어색해서 이것저것 팀장한테 물어보면서 겨우겨우 내 코드를 메인 브랜치에  merge 했던 기억이 난다.그리고 안드로이드 스튜디오로 뷰를 제작할 때 코드타이핑을 하지 않고 레이아웃 도구를 이용해서 뷰를 마우스로 배치하는 짓을 저질렀다. 또한, 이것도 모자라.. 액티비티에 네트워킹, 데이터, 뷰와 관련된 모든 코드를 때려 박는 짓을 저질렀다. 덕분에 내가 작성한 액티비티 코드는 담당자인 내가 봐도 파악을 못 하는 경지에 도달했다.유지보수는 1도 안 되고 어딘가 오류가 발생하면 액티비티 전역이 빨간불 걸리고… 확장하려니 기존코드를 또 수정해야 하고… 정말 답도 없었다. 심사하려고 이 코드를 봤던 구글 개발자분들에게 죄송할 따름이다. 그래도 이런 경험을 통해 소프트웨어 아키텍처가 필요한 이유를 알게 되었다.완전 초보인 상태로 프로젝트를 끝낸 이후에는 다양한 사람들과 스터디도 하고 해커톤도 나가고 MT도 갔다. 프로젝트 이외에도 다양한 활동을 한 덕분에 소통, 협업, 개발 능력치를 올릴 수 있었다. 여기서 인연이 되어 지금도 연락하고 지내는 사람들도 꽤 있다. 그만큼 구성원들도 활동 내용도 매우 만족스러운 활동이었다.22 - 23 새로운 도전구성원으로서 약 1년의 활동을 끝내고 혼자 머릿속으로 회고를 진행해봤다. 개발과 협업을 모두 경험해봤는데 뭔가 개발보다는 협업이 더 어려운 것 같다는 생각을 했다. 그래서 협업 능력을 키우기 위한 고민을 하고 있었는데 때마침 GDSC에서 구성원으로 같이 활동한 친구가 다음 기수 리드로 활동하게 돼서 코어 멤버를 뽑아야 하는데 해볼 생각 있느냐고 제안이 왔다.코어 멤버로 활동하게 되면 일반 멤버로 활동할 때와 다르게 조직 운영 및 기획과 소통을 할 일이 많으므로 내가 원하는 부분을 얻을 수 있을 것 같아 면접을 보고 코어 멤버로 2회차 활동을 시작했다. 코어 멤버로서 리드와 회의를 진행하면서 여러 중요한 것들을 결정하고 진행했다. 이 과정에서 회의를 정말 많이 한 것 같다.대회 기획 및 운영가장 기억에 남는 활동은 대회를 기획하고 운영하는 일이었다. 22년에 교내에서 알고리즘 경진 대회를 기획했는데 내가 맡은 역할은 다음과 같다.1. 굿즈 디자인 및 주문 관리2. 홍보 포스터 제작3. 홍보 현수막 제작4. 문제 제작 및 검토5. 대회 현장 감독 및 운영      굿즈 디자인 및 주문 관리    회의 결과로 에코백, 렌즈 클리너, 스티커를 대회 굿즈로 결정했다. 에코백 안에 렌즈 클리너와 스티커를 넣어서 대회 참가자들에게 제공하면 깔끔할 거 같아서 구성을 위와 같이 했다. 생각보다 스티커 디자인이 어려워서 여기에 시간을 많이 썼다. 나머지는 이전부터 생각한 게 있어서 빨리 끝낼 수 있었다.            홍보 포스터와 현수막 제작    홍보 포스터와 현수막을 제작하는 과정은 즐거웠다. 평소 디자인에 관심이 많아서 직접 포스터와 현수막을 제작하고 싶다는 마음이 컸다. 그래서 기획 회의에서 이를 말했고 내가 제작을 담당하게 되었다. 구글에서 다양한 포스터 디자인을 참고하여 디자인 콘셉트를 잡았고 해당 틀 안에서 여러 가지를 제작하고 비교하여 가독성이 좋은 쪽으로 수정을 진행했다.        ​\t        문제 제작 및 검토    문제 출제는 백준을 참고했는데 DP 문제 하나를 참고해서 살짝 틀었다. 이게 우리 학교 학우들의 수준을 잘 몰라서 난이도 조정에서 많은 고민을 했다. 고민한 끝에,  DP 를 이용하여 팰린드롬인 수열을 카운트하는 방식으로 제작했다. 난이도는 백준 기준으로 골드3이었다.    내가 만든 문제 이외에도 다른 문제들도 평균적으로 골드 중간급 이상이어서 충분히 해볼 만한 수준이었다. 실제로 대회 참가자 중에서 꽤 많은 인원이 절반 이상 문제를 해결했다. 이래서 문제 검토 때 교수님이 높지 않은 난이도에 대한 우려를 보이신 것 같다. 내 생각에는 다음 대회부터는 난이도를 조금 더 높이면 딱 알맞을 것 같다.        대회 현장 감독 및 운영    대회 당일에 현장 스태프로 참여하여 감독관 역할을 수행했다. 비기너 트랙은 챌린저 트랙보다 문제 난이도가 쉬워서 문제를 다 푼 사람이 두 세 명 정도 나왔다. 챌린저 트랙에서 올 클리어는 나오지 않았지만 반 이상 해결한 사람들은 꽤 있었다. 현장 운영을 하면서 갑작스러운 오류와 질문이 발생했지만, 운영진들이 최대한 빠르게 해결하여 무사히 대회를 끝낼 수 있었다.        그런데 대회가 끝나고 지인을 통한 문제 오류를 제보받았는데 실제로 확인해보니 오류가 존재했다. 지인이 해당 문제의 오류 때문에 시간을 많이 할애해서 단순히 넘어갈 문제가 아니라고 판단을 했다. 그래서 급하게 운영진들에게 이를 알렸고 해당 문제로 피해를 받았을 가능성이 높은 인원들을 추려서 사죄의 메시지와 적절한 보상안을 준비했다. 정말 다행이었던 것은 해당 문제 오류로 참가자 순위를 업데이트했을 때 당일 순위와 같아서 등수 변동에 대한 문제는 없었다는 거다. 정말 대참사가 날 뻔해서 당시에 문제가 해결될 때까지 엄청나게 긴장을 했던 기억이 난다.    운영진들끼리 대회 관련 이슈가 완전히 끝나고 회고하는 시간을 가질 때 다들 이 부분을 문제점으로 뽑았다. 운영진들이 아무래도 대회 준비 이외에도 하는 일이 많다 보니 각자가 맡은 문제만 검수하는 방식으로 진행했었는데 이게 잘못된 선택이었던 것 같다. 아무리 바빠도  시간을 내서라도 운영진 모두가 전체 문제에 대한 검토를 세세하게 해야 했는데 너무 안일했다. 그래서 나중에 대회를 준비하게 될 다음 기수들이 우리와 같은 실수를 반복하지 않도록 문제점, 보완해야 할 점, 추가해야 할 점 등을 정리해서 참고할 수 있도록 따로 드라이브에 정리하는 것으로 마무리했다. 다음에 대회를 기획하고 운영할 기회가 또 생긴다면 이런 부분에서 실수가 나오지 않도록 신경을 써야겠다.      일반 멤버였을 때는 배울 수 없던 소중한 경험들일반 멤버로 GDSC 를 활동했을 때는 주변 일반 멤버들을 보고 배운 게 많았다면 코어 멤버는 코어와 리드와의 소통이 많다 보니 그 사람들의 리더쉽과 다양한 협업 가치관을 배울 수 있었다. 다들 책임감을 가지고 맡은 일을 열심히 해내는 모습을 보고 나도 덩달아 열심히 하게 된 것 같다.그리고 코어로 활동하는 이상, 일반 멤버들이 잘 따라올 수 있도록 신경 쓰는 건 필수라고 생각해서 고민이 있는 멤버가 있으면 최대한 도움을 주려고 했다. 실제로 23년 초에 프로젝트를 하던 시기에 한 멤버가 실력 문제로 프로젝트 이탈에 대한 고민을 나에게 꺼냈었다. 나도 일반 멤버로 활동했을 때 비슷한 고민을 겪어봤고 극복한 경험이 있어서 그 친구에게 걱정하지 말고 믿고 따라와 주면 좋겠다는 식으로 얘기했다. 다행히 해당 멤버는 포기하지 않고 끝까지 잘 마무리를 했고 지금은 코어 멤버로 제2의 활동을 하고 있다.코어 멤버로 약 1년 동안 활동하면서 프로젝트도 그렇고 조직을 운영하는 것도 그렇고 결국엔 서로가 서로를 잘 이끌어주는 게 가장 중요하다고 느꼈다. 나는 아직 이런 부분에서 부족한 점이 여전히 많지만 2년간의 GDSC 활동을 통해 이전보다는 훨씬 성장했다고 생각한다.첫 개발 커뮤니티 활동을 GDSC로 시작한 것은 나에게 있어 최고의 선택이었고 이것은 내 대학 생활에서 가장 큰 변환점이었던 것 같다. 23년 이후에 우리 학교의 GDSC 챕터에서 활동하는 사람들 모두 좋은 기억을 얻고 갔으면 좋겠다.​세 번째 이야기 - 해커톤 최우수상23년 최고의 순간을 뽑으라면 여름에 열린 교내 해커톤 대회에서 최우수상을 받은 이 스토리를 주저 없이 고를 것이다. 나에게 있어서 단순히 운이 좋아서 얻은 결과가 아닌 22년의 실패를 극복하기 위해서 오랫동안 준비해온 노력의 결실이다. 이 스토리를 제대로 이해하기 위해서는 22년 교내 해커톤 대회 때 이야기부터 풀어야 한다.첫 해커톤의 시작은 GDSC 졸업 회식에서22년 GDSC 마지막 날, 수료를 기념하기 위해 학교 근처에서 단체로 회식하고 있었다. 밥을 먹다가 GDSC로 친해진 형이 나한테 해커톤 대회에 참가하자는 제안을 했다. 대충 상황을 물어봤는데 형을 포함해서 세 명은 확정이고 나만 들어오면 팀 빌딩이 완성되는 상황이었다. 형을 제외한 나머지 두 명도 GDSC 멤버였으며 나보다 선배인 형들이었다.제안을 받고 나서 고민을 했다. 이미 확정된 세 명의 형들은 나보다 경험도 많고 잘하는 사람들이지만, 나는 이때 프로젝트 경험이 한 번뿐이고 깃허브도 제대로 다룰 줄 모르는 상태였다. 그래서 하루 동안 빠르게 개발을 해야 하는 해커톤에서 내가 과연 잘할 수 있을지 의문이었다. 그래도 이렇게 우연히 찾아온 기회를 무섭다고 거절하면 다음은 없을 것 같아서 큰마음을 먹고 제안을 승낙했다.처음 경험해본 합숙해커톤 팀이 결성됐던 GDSC 수료 기념 회식 이후, 우리는 해커톤 공지에서 코로나 키워드가 대회 주제와 관련이 있다는 힌트를 보고 세부 주제를 유추해봤다. 다같이 고민을 해본 결과, 코로나로 인해서 바뀐 삶에 최적화된 서비스를 만드는 게 대회에서 제시할 주제인 것 같다는 결론을 냈다. 코로나 라는 키워드에서 낼 수 있는 주제가 한정적이라 우리가 유추한 주제가 완전히는 아니더라도 어느정도는 맞을 것 같다는 확신을 했다.그 다음에는 우리가 생각한 세부 주제를 가지고 각자가 생각하는 서비스 기획안을 얘기하는 시간을 가졌다. 처음에는 뭔가 그럴듯한 아이디어가 나오지 않아서 골머리를 앓았다. 계속된 기획 회의에 서로 지쳐가던 마당에 한 명이 출장이 잦고 출장과 동시에 여행을 즐기는 직장인들 대상으로 근무지 및 여행지 추천 애플리케이션을 만들어보는 게 어떻겠냐는 제안을 했다. 나 포함해서 다른 팀원들도 괜찮은 반응이어서 해당 아이디어를 구체화하기로 결정했다.기획의 가닥이 잡혔을 시기에 GDSC 수료 기념 MT 일정이 있었는데 팀원 한 명이 MT 일정 전날에 다 같이 모여서 기획 구체화를 어느 정도 진행하고 다음날에 MT 일정에 참여하는 것은 어떠냐는 제안을 했다. 팀원 전원이 동의했고 바로 MT 전날에 1박으로 유스호스텔에 모여서 팀원들끼리 서비스 이름과 와이어 프레임, DB 등에 대해 논의하는 시간을 가졌다.이때 나는 프로젝트를 체계적으로 진행해본 경험이 없어서 서버와 프론트 사이의 얘기를 이해하지 못했다. 나와 같이 안드로이드를 담당한 팀원 한 명과 서버를 담당한 팀원 한 명은 고학년에 경험도 있어서 둘이 DB에 관한 이야기와 API 명세서와 같은 이야기를 술술 나눴다. 당연히 나는 이때 당시에 DB 개념은 아예 모르고 API 명세서라는 것도 처음 들어봐서 둘의 대화를 옆에서 멀뚱히 보기만 했다.나도 뭔가 도움이 되고 싶은데 지켜보기만 하는 게 미안해서 충분히 할 수 있는 서비스 이름이랑 UI/UX, 아이콘 제작이라도 열심히 참여했다. 나는 이때 대부분 시간을 모바일 UI/UX 제작에 투자했던 것 같다. UI/UX 회의를 할 때 비로소 팀에 이바지를 한다는 마음이 들어서 조금 안심이 됐다. 모바일 파트는 UI/UX 회의를 진행하고 서버 파트는 따로 서버와 관련된 회의를 진행했다. 새벽까지 각자 여러 작업을 진행하고 합숙을 마무리했다.합숙을 하면서 내가 도움될 수 있는 부분은 적었지만, 확실히 같이 모여서 작업을 하니까 효율이 엄청나게 좋았다. 그리고 개발 이외에도 산책하거나 같이 밥 먹으면서 노닥거리기도 했는데 이게 팀 분위기를 좋게 만든 것 같다. 여러모로 프로젝트 진행에 많은 도움이 되는 것 같다.처음보는 라이브러리와 구조합숙을 끝내고 대회가 시작되기 전에 팀원 형이 대회에 사용할 기술스택들을 설명해줬는데 AAC, Coroutine, Retrofit2 등 모두 다 처음 보는 라이브러리였다. 심지어 프로젝트 구조도 단순히 액티비티에 코드를 작성하는 것이 아닌 ui 층과 data 층으로 나누어서 ui 층에는 ViewModel을, data 층에는 Repository, DataSource 을 사용하는 방식이었다. 라이브러리도 그렇고 처음 보는 구조에 뇌정지가 왔지만, 대회가 곧 열리기 때문에 팀원이 제공해준 강의를 빠르게 들으면서 대회 전까지 최대한 프로젝트에 사용될 라이브러리와 구조에 관한 공부를 했다.대망의 대회 당일대회 당일, 대망의 대회 세부 주제가 발표됐는데 우리가 예상했던 주제와 어느 정도 일치했다. 그래서 우리는 어느 정도 주제를 예측해서 준비했던 기획을 그대로 사용하기로 했고 바로 구체화를 시작했다. 내가 맡은 파트는 게시글 작성 기능이었는데 여러 Fragment 를 이용해서 사진 첨부, 텍스트 작성, 장소 태그 추가 등 다양한 작업을 구현해야 했다.하지만 시작부터 쉽지 않았다. 기본적인 안드로이드 컴포넌트에 대한 개념도 제대로 알지 못한 상태에서 아키텍처 컴포넌트와 Retrofit 을 Coroutine 에 맞춰서 설계하려 하니까 작은 것조차 구현하는 데 많은 시간을 썼다. 여기서 1차로 집중력이 흐트러졌다.시간은 계속 흘러가는데 코딩도 못하고 계속 라이브러리와 구조에 대한 이해와 파악만 계속하고 있으니 자괴감이 엄청났다. 이런 일이 있을까 봐 대회 전까지 열심히 강의 들으면서 공부했는데 단기간에 이해하기에는 복잡하고 큰 범위의 내용이었던 것 같다. 솔직히 지금 생각해도 이제 걸음마를 뗀 안드로이드 초보가 한 달도 안되는 기간에 아키텍처와 AAC 라이브러리들을 전부 이해한다는 게 말이 안 됐다.그래도 어떻게든 내가 맡은 파트는 끝내야 한다는 생각에 같은 팀원이 먼저 올린 코드를 보면서 단순히 따라 하는 식으로 급하게 코드를 작성했다. 물론 스스로 고민하고 코드를 작성하는 것이 맞지만 하루 만에 끝내야 하는 해커톤이기 때문에 어쩔 수 없던 선택이었다.결국 단순 따라 하는 방식으로 댓글 기능과 검색 기능을 구현하는 데 성공했다. 그러고 나서 게시글 작성 기능 구현을 바로 시작하여  뷰에서 사용자의 데이터를 받아서 저장하는 것까지 완료했는데 그다음에서 문제가 발생했다. 사용자가 등록한 사진, 게시글 문구, 장소를 서버에 전송해서 게시글 등록에 대한 요청을 처리해야 하는데 통신 에러가 났다.status 코드가 500번대로 계속 떠서 로그로 확인했는데 멀티파트 형태로 서버에 전송되어야 하는 게 null 로 전송이 되는 것을 확인했다. 처음에는 Retrofit2 의 Request 의 양식이 잘못된 줄 알고 둘의 코드를 여러 방식으로 수정을 해봤다. 내가 맞춰서 설계하려 라이브러리에 대한 경험이 없어서 구글링으로 여러 코드를 합치다 보니 분명히 요청 방식에 대한 맞춰서 설계하려 관련 코드가 잘못된 것이라 생각을 해서 해당 판단을 한 것이다.그런데 아무리 코드를 수정해도 오류가 해결되지 않아서 계속 몇 시간 동안 해당 오류와 승강이를 벌였다. 앞서 댓글 기능과 검색 기능을 구현하는 데 체력과 정신을 쏟아서 판단이 흐린 상태로 어떻게든 통신 오류를 해결하고자 했는데 결국 아침까지 해결하지 못했다.다른 안드로이드 것조차 맡은 팀원은 마감 전까지 급하게 구현하지 못한 기능들을 최대한 구현하려고 나머지 힘을 쥐어짜 내고 있는데 정작 나는 오류 하나 해결하지 못해서 아무것도 못 하는 상황이 매우 비참했고 다른 팀원들에게 너무 미안했다.결국 마감 시간이 다가와서 해결하지 못한 오류는 포기하고 구현한 것만 제출하기로 했다. 나는 깃허브에 지금까지 작업물을 제출하고 나머지 팀원들은 발표자료를 만들기로 하고 마지막 업무를 진행했는데 여기서 또 내가 대참사를 냈다. 대회 깃허브 페이지에 작업물을 잘못된 방법으로 push 하는 바람에 혼자서 10분 동안 삽질을 했다. 결국, 옆에서 발표 자료 만들던 팀원이 도와줘서 마감 직전에 겨우 제출할 수 있었다.정말 참담했다. 게시글 작성 기능 오류를 해결하지 못해서 깃허브라도 제대로 하고 싶었는데 이것조차 제대로 하지 못한 내 모습이 너무 부끄러웠다. 그래도 팀원들은 괜찮으니까 발표까지 잘 마무리하자며 격려해줘서 혼란스러웠던 감정을 잘 추스르고 무사히 발표를 마무리했다.다사다난했던 22년 첫 해커톤 종료대회를 마무리하고 집에 오는 길에 수많은 감정을 느꼈다. 여태까지 새로운 것에 도전하면 목표보다 높은 결과를 내서 나름의 자신감 있는 태도로 해커톤에 임했는데 처음부터 끝까지 제대로 해낸 게 없어서  내가 해온 것들에 대한  희의감을 느꼈다.그래도 얻은 것도 많았다. 이때 스스로에 대한 객관화를 제대로 할 수 있었고 프로젝트 설정부터 열심히 도와준 안드로이드 팀원 덕분에 안드로이드의 중요 라이브러리와 아키텍처라는 것을 알게 되어 좀 더 넓은 시선을 가지게 되었다.대회 결과는 일주일 뒤에 발표됐는데 우수상으로 생각보다 굉장히 만족스러운 결과를 얻었다. 우수상을 받아서 다행이란 마음이 들었지만, 한편으론 내가 게시글 기능 구현을 잘 마무리하고 다른 기능까지 더 개발해서 완성도를 높였으면 결과가 더 좋았을 거라는 아쉬움이 들었다. 지금도 이때의 우수상은 기획부터 개발까지 내가 크게 이바지한 부분이 많이 없다고 생각해서 내가 아닌 다른 팀원들이 이끌어낸 성과라고 생각한다.실패를 극복하기 위한 노력해커톤을 끝내고 팀원 중 한 명이 대회 때 못다 한 개발을 마무리하는 것이 어떠냐는 제안에 팀원들이 동의해서 바로 재개발에 착수했다. 나는 이번에야말로 저번에 끝내 해결하지 못했던 오류를 해결하겠다는 의욕으로 다시 오류를 찾기 시작했다. 그래도 대회 때와 달라진 점이 있다면 대회가 끝나고 내가 많이 부족했음을 인정하고 부족한 부분들을 공부했기 때문에 프로젝트 구조와 라이브러리가 익숙해졌다는 것이다.이 덕분에 대회 때 능숙하게 해내지 못한 로직의 흐름 이해가 잘 되어 내 발목을 붙잡았던 오류의 원인을 찾을 수 있었다. 원인은 생각보다 단순했다. 대회에서 레트로핏 라이브러리와 관련한 오류라고 생각을 해서 오류를 쉽게 찾지 못했는데 이 때문이 아니라 프래그먼트의 생명주기와 관련된 문제였다. 프래그먼트의 생명주기에 따라 유저 데이터가 초기화될 수 있다는 점을 간과하고 단순히 통신 관련 코드를 잘못 작성한 거라고 생각을 했던 것이다.그래서 테스트를 위해서 임시로 여러 프래그먼트 전역에서 사용할 수 있는 싱글톤 객체를 만들어서 해당 객체에 유저 데이터를 저장하고 서버 통신을 해봤는데 정상적으로 응답을 받는 것에 성공했다. status 코드가  200  이 나온 로그를 보고 참으로 허무함을 느꼈다. 가장 근본적인 것부터 시작해서 오류의 원인을 찾았어야 했는데 숲을 보지 않고 나무만 본 결과가 이런 건가 싶었다.결국 막혔던 오류를 무사히 해결하고 게시글 작성 기능 구현을 완성해서 그동안 쌓였던 앙금이 조금은 풀린 느낌을 받았다. 이후에도 계속 개발을 진행하면서 회의도 했는데 팀원 두 명의 일정 문제로 아쉽게 추가 개발은 마무리되었다. 그래도 이때를 기점으로  안드로이드 공부의 방향성을 잡아서 안드로이드로 홀로서기를 시작한 계기가 되었다. 오히려 큰 실패가 더욱더 열심히 하게 되는 원동력이 된 것 같다.해당 원동력으로 해커톤이 끝나고 9월부터는 좀 더 폭넓은 시선을 가지고 싶어서 GDSC 코어 멤버로서의 활동을 시작했고 23년부터는 해커톤 때의 프로젝트 경험을 살려서 본격적으로 홀로 프로젝트 개발을 진행하는 경험을 쌓았다.운명처럼 다시 찾아온 그 해커톤 대회운명인 건지 우연인 건지, 23년 6월에 GDSC 코어 멤버로서의 활동이 끝나가던 시점에 첫 교내 해커톤 대회를 같이 했던 팀원 한 명이 이번에도 같이 해커톤 대회를 할 생각이 있는지 나에게 물어봤다. 처음 제안을 받았을 때 이전 해커톤 대회의 아픈 기억이 떠올라서 다시 경험하고 싶지 않은 마음에 거절하려고 했다.게다가 첫 해커톤 시절과는 다르게 이때는 GDSC 코어 멤버라서 할 수 있는 해커톤 운영진 경험을 하고 싶어서 해당 대회의 기획 및 운영을 하는 쪽으로 리드와 얘기가 어느 정도 됐던 상황이다. 그래서 굳이 하고 싶었던 운영진 자리를 포기하고 대회에 참가할 필요가 없던 상황이기도 했다.그런데 문득 이번 대회를 운영진으로 마무리하게 되면 이전 대회 때의 실패를 만회하지 못한 채로 졸업하게 되는데 그렇게 되면 나중에 가서 두고두고 후회할 것 같았다. 그때를 기점으로 개인적인 기술 스택 공부와 프로젝트 리드 및 협업 경험을 쌓았기 때문에 23년의 대회는 단순히 허황한 도전이 아닌 충분히 준비된 도전이라 판단이 되어 과감히 운영진을 포기하고 참가자로 노선을 틀었다.다시 시작된 해커톤, 시작부터 변수 발생?이번에도 6월에 대회가 열렸다. 종강하고 바로 대회가 바로 열려서 사실상 대회 힌트에 맞춰서 미리 기획을 조금이라도 짜낼 시간이 거의 없었다. 그래서 우리 팀은 대회 공지에 나온 힌트에 맞춰서 주제를 유추하는 회의를 진행했고 가장 괜찮은 하나를 대회에 들고갔다.그런데 대회가 시작되고 주제를 발표했는데 우리가 준비했던 주제와 전혀 연관성이 없는 변수가 발생했다. 그래서 우리는 대회 오프닝이 끝나고 작업 공간에 모여서 재빨리 대회 주제에 맞는 아이디어를 구상했다. 대회 주제가 2023 트렌드 코리아에서 선정한 올해의 키워드를 기반으로 대학생들에게 도움이 되는 서비스를 만드는 것이었는데 쉽게 아이디어가 나오지 않았다.위기를 기회로 바꾸다팀원들이 여러 아이디어를 얘기하고 있던 그때 문득 대학생들끼리 자주 하는 밥약 이 떠올랐다. 대학생 커뮤니티인 에브리타임에서 심심치 않게 같이 밥 먹을 사람을 구하는 글이 올라오는 걸 볼 수 있는데 나는 이 부분을 서비스로 구체화하면 괜찮지 않느냐는 생각을 했다.해당 생각에 대해 여러 가지 이유가 있었는데 먼저 우리 학교의 위치상 교통이 좋지 않고 폐쇄적이어서 기숙사나 근방에 자취하는 학생들은 공휴일이 낀 휴일이나 명절이 아닌 이상 다른 지역으로 이동하지 않는 성향이 있다. 그러다 보니 우리 학교 근처를 한정으로 한 로컬 서비스가 있으면 신선한 맛이 있을 거라 생각했다.두 번째 이유는 다른 팀과 기획이 겹치고 싶지 않은 마음이 있었다. 대학생들을 위한 서비스가 주요 주제였기 때문에 분명히 대부분 팀이 문서나 일정과 관련된 카테고리를 다룰 거로 생각해서 우리 팀도 그런 주제를 기획한다면 압도적으로 잘 만들어야 입상 가능성이 생긴다. 따라서 우리 팀은 주제에서 벗어나지 않으면서 최대한 다른 팀과 겹치지 않은 주제로 기획하는 것이 유리하다고 판단을 했다.세 번째 이유는 우리 팀 구성원들의 실력에 대한 믿음이 있어서다. 밥약 매칭 서비스의 모든 기능을 고작 하루에 전부 구현하는 것은 절대 불가능하다. 그렇다면 주요 기능들에 대한 완성도 있는 UI/UX에 초점을 맞추고 이를 빠르게 개발할 수 있어야 한다. 내 기준에서는 우리 팀원들이 이를 충분히 해낼 수 있는 경험과 실력이라고 생각이 들었다. 나를 포함해서 안드로이드 파트를 맡은 또 다른 팀원 둘 다 UI/UX 디자인 경험이 있고 레퍼런스도 많아서 다른 팀들과 비교했을 때 충분히 경쟁력 있는 모바일 화면을 만들 자신이 있었다.나의 아이디어로 대회 입상에 도전하다나는 밥약 매칭 서비스가 충분히 경쟁력 있다고 판단이 돼서 팀원들에게 곧바로 해당 기획에 대해 설명을 했다. 이를 듣고 팀원들이 처음에는 장난 섞인 웃음을 보였다가 이내 생각에 잠기더니 생각보다 괜찮을 것 같다는 반응을 보였다. 그래서 나는 여러 케이스를 설명하면서 내 기획에 대한 어필을 했다. 뭔가 그때를 돌아보면 내 기획이 충분히 통할 거라는 자신이 있었던 것 같다. 진지하게 고민을 하던 팀원들은 내 기획을 받아들였고 우리는 해당 기획으로 본격적인 구체화를 시작하게 되었다.개발 과정기획 확정을 하고 휴게실에서 팀원들끼리 밥을 먹으며 구체적인 설계 방법을 얘기했다. 거기서 어느 정도 틀을 잡은 뒤에 작업 공간으로 돌아와서 서버팀은 데이터베이스와 API 구현을 하고 안드로이드 파트는 UI/UX 디자인을 했다. 참고할만한 UI/UX 레퍼런스를 여러 개 모아서 직관적이고 단순한 콘셉트로 디자인을 진행했다. 안드로이드 파트가 두 명이다 보니 서로 절반씩 나눠서 작업했다.디자인 작업이 거의 다 끝나갈 무렵에 서버팀에서 일부 API가 완성되어서 디자인 마무리를 하고 바로 코딩을 시작했다. 제한된 시간 내에 빨리 개발을 해야 하므로 나에게 익숙한 구조와 코드를 사용했다. 그래도 이전 해커톤 때와는 다르게 안드로이드 개발에 대한 경험이 쌓인 상태라 작업에 속도를 붙일 수 있었다.아침이 지나고 개발 막바지를 향해 달려가고 있을 때 매칭된 화면의 개발을 담당한 안드로이드 팀원이 특정 오류를 잡지 못해서 개발이 잠시 멈추는 상황이 발생했다. 아무래도 매칭 화면이 가장 핵심인 부분인지라 굉장히 긴장되는 상황이었다. 어떤 오류인지 파악하기 위해서 같이 오류를 살펴봤는데 쉽게 원인을 찾지 못했다. 그래도 팀원이 꼭 해결하겠다는 의지가 눈에 보여서 나는 팀원을 믿고 내가 하던 개발을 마저 진행했다.하지만 끝내 해당 팀원이 대회 마감 전까지 오류를 해결하지 못하여 우리는 매칭 화면은 단순히 제작한 UI를 보여주는 것으로 방향을 틀고 작업물을 제출했다. 해당 팀원은 죄책감에 나를 포함한 팀원들에게 계속 미안하다는 말을 계속했던 것 같다. 이때 뭔가 이전 데이터베이스와 때의 내 모습이 떠올랐는데 그때의 나도 내가 맡은 파트는 스스로 해결해야 한다는 마음으로 끝까지 오류와 싸웠지만 결국 해결하지 못하고 팀원들에게 미안하다는 말만 했다. 아마 이 친구도 나와 비슷한 심정이지 않았을까 하는 생각이 들었다. 그래서  다른 감정보다는 오히려 내가 맡은 파트 때문에 팀원을 더 도와주지 못한 것에 대한 미안함이 컸다.결과물 발표 시간그래도 매칭 화면을 빼고는 나머지 주요 기능들은 구현을 해서 시연 영상과 발표 자료를 잘 준비하여 발표 강의실에 들어갔다. 첫 번째 팀의 발표를 시작으로 다른 팀들의 발표를 보면서 우리 팀의 결과물을 비교해봤는데 생각보다 할만하다는 생각이 들었고 우리 팀의 발표를 맡은 서버 인원들도 똑같은 반응을 보였다. 이 덕분에 우리 팀이 발표를 좀 더 자신감 있게 할 수 있었던 것 같다.우리팀의 발표가 끝나고 심사위원들의 반응을 살폈는데 예상보다 반응이 좋아서 조금 놀랐다. 기획의 허점을 찌르는 질문이 심사평의 주가 될 줄 알았는데 그것보다는 흥미와 호기심에 기반을 둔 여러 긍정적인 질문들이 더 많았다. 안 그래도 이전 팀들의 대부분 심사평이 좋지 않아서 우리 팀도 긴장하면서 심사평을 기다렸는데 정말 다행이었다. 이게 반응이 생각보다 좋아서 오히려 너무 기획이 터무니없어서 부정적인 재미를 느낀 게 아니겠느냐는 생각도 들었다. 그래도 우리는 최대한 긍정적인 방향으로 생각하기로 하고 대회를 마무리했다.가장 예쁜 꽃은 우여곡절 끝에 피는 꽃대회가 끝나고 약 일주일 뒤에 그렇게 기다리던 슬랙 공지가 떴다. 우리 팀 명이었던 초록깡통 이 시상 대상팀에 속한 걸 보고 속으로 얼마나 소리를 지른 지 모르겠다. 내가 낸 기획안이 대회에서 통했다는 생각에 기쁨이 배가 된 것 같다. 팀원들끼리도 자축하면서 고생했다는 말을 나눴다.다음날 시상식에 팀원들이 모두 일정이 있어서 일정이 너른 내가 참여했다. 수상팀 발표는 우수상부터 대상 순으로 진행이 됐는데 나는 우수상이 세 팀이나 있어서 우리 팀이 초반에 우수상으로 호명될 줄 알았다. 대상과 최우수상은 각각 한 팀만 해당이 돼서 이걸 우리 팀이 수상하는 건 어렵다고 생각했다.그런데 예상치 못한 반전이 일어났다. 수상팀을 차례대로 발표하는데 초반 우수상 세 팀에 우리 팀이 없어서 엄청나게 당황했다. 우수상을 받을 줄 알았는데 우수상을 넘어서 최소한 최우수상은 확정이고, 크게는 대상까지 기대할 수 있는 상황이 됐다. 하지만 아쉽게도 우리 팀은 대상까진 닿지 못했고 최우수상을 받았다. 그래도 우리 팀은 최고의 결과로 받아들였다. 대상 팀의 작업물은 다른 팀들과 비교했을 때 급이 너무 높아서 이 팀이 시상 대상팀에 속한 걸 보는 순간 대상을 받을 거라고 팀원 모두 예상을 했었다. 그래서 우리는 아웃라이어 느낌의 대상팀을 제외하면 비슷비슷한데 그중에서 우리가 최고인 거 아니냐며 장난스럽게 긍정적인 합리화를 했다.최우수상 판넬을 들고 집으로 복귀하는 버스에 탔는데 감회가 새로웠다. 1년 전만 해도 혼자서 제대로 해낸 것 없이 대회를 마무리하고 비참한 심정으로 집에 가는 버스를 탔었는데 1년 후에 같은 대회에 다시 나가서 이번에는 내가 직접 아이디어를 내고 그 아이디어로 최우수상이라는 결과를 냈으니 도파민이라는 게 이런 건가 싶었다.누군가에게는 교내 공모전 수상이 특별하게 느껴지지 않을 수도 있다. 오히려 그걸로 이렇게까지 기뻐할 정도인지 의문을 품을 수도 있다. 하지만 나에게 있어서 교내 해커톤 대회는 내가 한 번 제대로 실패를 겪은 기억하기 싫은 트라우마였고 나는 이를 극복하기 위해서 스스로 같은 대회에 다시 나가 직접 트라우마를 부쉈다. 그래서 큰 대외 공모전도 아닌 단순하고도 단순한 교내 공모전 수상에 행복을 느끼는 거다.2023년 말에 화제가 되었던 롤드컵 우승팀인 T1의 정글러 오너(Oner)선수가 이런 말을 했다.  출처 - 이포커스 유튜브 채널 썸네일 캡처나는 이 말을 굉장히 좋아한다. 내 해커톤 경험처럼, 그리고 오너 선수가 22년에 준우승을 하고 23년엔 결국 우승을 한 것처럼 끝까지 가면 결국엔 해낸다는 게 이런 게 아닐까 싶다. 평생은 모르겠는데 그래도 오랫동안 이 경험을 잊지 못할 것 같다.마지막으로 이런 경험을 할 수 있게 이끌어준 팀원들에게도 매우 고맙다는 말을 또 한 번 이 글을 통해 전하고 싶다. 수상 기념 팀 회식 사진을 끝으로 이 에피소드에 대한 이야기를 마치겠다.2023 총정리이렇게 2023년에 있었던 큼직한 여러 일화를 다뤘는데 23년은 특히 협업 능력치가 이전보다 크게 성장한 해였다. 다양한 사람들과 프로젝트를 하면서 가장 크게 깨달은 게 있다면 성공적인 프로젝트를 위해서는 많은 소통과 좋은 분위기가 필요하다는 것이다. 여태까지 협업하면서 항상 좋은 결과를 낸 사람들을 보면 뛰어난 개발 실력은 물론이고 팀 자체의 분위기를 좋게 만드는 긍정적인 에너지가 있었는데 나도 아직은 많이 부족하지만 그런 사람으로 발전하는 것이 내년 목표라고 할 수 있겠다.반대로 아쉬운 점도 있었다. 협업 관련 경험은 기회가 많았고 실제로 커뮤니티도 하고 대회도 나가고 프로젝트도 했는데 그에 반해서 기술적 성장은 많이 이뤄내지 못했다. 23년 초반에는 혼자서 안드로이드 아키텍처 컴포넌트와 관련된 라이브러리와 소프트웨어 아키텍처를 연습해보는 시간을 가졌고 여름에 있었던 해커톤에서는 기획과 협업 위주로 수행하다 보니 좀 더 나은 코드를 위해 고민을 하는 시간이 없었다.그래서 하반기에 기술적 발전을 도모하기 위해  UMC라는 대학생 연합동아리를 통해 다른 학교 학생들과 프로젝트를 할 기회를 잡았는데 아쉽게도 안드로이드 파트는 나를 포함해서 전원이 초보자라 단순히 동작 구현에만 초점을 맞춘 개발을 했다. 실제로 이때 Koin 대신에 좀 더 제대로 된 DI 인 Hilt 와 안드로이드에 종속된 LiveData 대신에 코틀린에서 제공하는 Flow 와 같은 써보지 않았던 기술을 경험해보고 싶었는데 다른 팀원들이 나보다 훨씬 경험이 적어서 내가 기존에 사용했던 방식을 팀원들에게 알려주고 실제로 적용하는 걸 옆에서 코치하는 구실을 했다. 팀원들이 최대한 빠르게 이해할 수 있게 아이패드 드로잉 앱으로 동작 흐름에 따른 라이브러리 작용을 그려가면서 알려주기도 했다.2024년 목표23년에는 많은 협업 경험을 해봤기 때문에 24년에는 나의 기술적 공백기를 깨고 싶은 마음이 크다. 그래서 쉽지는 않지만 가능하다면 좀 더 규모가 있는 대외활동에 참여해서 안드로이드에 대한 이해를 높이는 것이 첫 번째 목표다. 마음에 두고 있는 대외 개발 동아리가 두 곳이 있는데 둘 다 들어가기 쉽지 않은 곳이라 열심히 준비해야 할 것 같다.두 번째 목표는 본격적인 이력서 작성을 통해 서류와 면접을 대비하는 것이다. 아직 인턴 경험이 없어서 실제 회사에 면접을 본 경험이 없다. 이제 졸업을 앞두고 있고 본격적으로 취업 시장에 뛰어들 타이밍이기 때문에 일단 도전해본다는 마음가짐으로 임할 생각이다. 여기서 운 좋게 인턴 기회가 생긴다면 네 발로 길 자신 있다. (제발요)세 번째 목표는 앱스토어에 등록할 개인 프로젝트를 해보는 것이다. 여태까지 프로젝트는 여러 번 해봤지만, 앱스토어 출시까지 간 적은 없어서 이번에는 꼭 해보고 싶다. 현재 생각해놓은 간단한 기획이 있긴 한데 좀 더 안드로이드에 관한 공부를 진행하고 늦어도 하반기 전에는 완성하는 것이 목표다.마지막으로는 대학교의 마지막 학기를 잘 마무리하는 것이다. 개인적으로 대학에 입학하면서 대학생으로서 이루고 싶은 버킷리스트가 있었는데 작년을 끝으로 모두 이뤄냈다. 그래서 이제는 학교생활에 대한 미련 없이 행복하게 졸업할 수 있을 것 같다. 그러므로 남은 한 학기를 잘 마무리하고 싶다.​이로써 23년의 회고는 모두 끝이 났다. 2024년에 목표한 것들을 꼭 이루고 뿌듯한 마음으로 24년 회고를 작성할 날을 기대하며 여기서 글을 마치겠다."
  },
  
  {
    "title": "(프로그래머스 | Kotlin) - 무인도 여행",
    "url": "/posts/KotlinAlgorithm13/",
    "categories": "CS, 알고리즘 문제",
    "tags": "Kotlin, Algorithm, 알고리즘, 프로그래머스",
    "date": "2023-12-07 12:00:00 +0900",
    





    
    "snippet": "해결 방법그래프 탐색을 이용해서 X 가 아닌 영역들을 찾아서 합산한다. BFS 혹은 DFS 를 사용하면 되는데 나는 DFS 를 사용해서 풀었다. maps 의 모든 원소를 반복문으로 돌면서 X 가 아니면서 방문하지 않은 곳을 시작점으로 두고 DFS 를 돌린다.그리고 DFS 를 돌면서 방문한 점들은 모두 방문 처리(true)를 한다. 전형적인 DFS BF...",
    "content": "해결 방법그래프 탐색을 이용해서 X 가 아닌 영역들을 찾아서 합산한다. BFS 혹은 DFS 를 사용하면 되는데 나는 DFS 를 사용해서 풀었다. maps 의 모든 원소를 반복문으로 돌면서 X 가 아니면서 방문하지 않은 곳을 시작점으로 두고 DFS 를 돌린다.그리고 DFS 를 돌면서 방문한 점들은 모두 방문 처리(true)를 한다. 전형적인 DFS BFS 문제라서 그래프 탐색 알고리즘만 작성할 수 있으면 어렵지 않게 풀 수 있는 문제다.​전체 코드class Solution {    fun solution(maps: Array&lt;String&gt;): IntArray {        val answer = ArrayList&lt;Int&gt;()        val isVisited = Array(100) { BooleanArray(100) }        for(i in 0..maps.lastIndex) {            for(j in 0..maps[0].lastIndex) {                if(maps[i][j] != 'X' &amp;&amp; !isVisited[i][j]) {                    isVisited[i][j] = true                    answer.add(rec(Point(i, j, maps[i][j] - '0'), maps, isVisited))                }            }        }        return if(answer.isEmpty()) intArrayOf(-1) else answer.sorted().toIntArray()    }    private fun rec(        s: Point,        maps: Array&lt;String&gt;,        isVisited: Array&lt;BooleanArray&gt;    ): Int {        var answer = s.days        val dirX = listOf(0, 1, 0, -1)        val dirY = listOf(1, 0, -1, 0)        for(i in 0..3) {            val nxtX = s.x + dirX[i]            val nxtY = s.y + dirY[i]            if(nxtX in maps.indices &amp;&amp; nxtY in maps[0].indices &amp;&amp; maps[nxtX][nxtY] != 'X' &amp;&amp; !isVisited[nxtX][nxtY]) {                isVisited[nxtX][nxtY] = true                answer += rec(Point(nxtX, nxtY, maps[nxtX][nxtY] - '0'), maps, isVisited)            }        }        return answer    }    data class Point(        val x: Int,        val y: Int,        val days: Int    )}"
  },
  
  {
    "title": "(프로그래머스 | Kotlin) - 메뉴 리뉴얼",
    "url": "/posts/KotlinAlgorithm12/",
    "categories": "CS, 알고리즘 문제",
    "tags": "Kotlin, Algorithm, 알고리즘, 프로그래머스, 카카오 코딩테스트",
    "date": "2023-12-05 12:00:00 +0900",
    





    
    "snippet": "해결 방법가장 간단한 해결 방법은 orders 의 모든 원소들을 course 내의 희망 개수에 맞춰 단품메뉴 조합을 만드는 것이다. 예를 들어서 1번 예시를 보면 orders 의 첫 번째 원소는 ABCFG, course 의 첫 번째 원소는 2 다.이를 토대로 ABCFG 에서 두 개로 구성된 조합을 모두 꺼내서 map 에 카운트를 증가시킨다. 마찬가지로...",
    "content": "해결 방법가장 간단한 해결 방법은 orders 의 모든 원소들을 course 내의 희망 개수에 맞춰 단품메뉴 조합을 만드는 것이다. 예를 들어서 1번 예시를 보면 orders 의 첫 번째 원소는 ABCFG, course 의 첫 번째 원소는 2 다.이를 토대로 ABCFG 에서 두 개로 구성된 조합을 모두 꺼내서 map 에 카운트를 증가시킨다. 마찬가지로 orders 의 나머지 원소들도 두 개로 구성된 조합을 모두 만들어서 map 에 카운트를 증가시킨다. 이렇게 해서 course 에서 2 에 대한 작업이 끝나면 나머지 3 4 도 동일하게 처리한다.이제 map 에는 course 에서 희망한 단품메뉴 조합 수를 토대로 제작한 조합들이 key 값으로, 해당 조합이 등장한 횟수를 카운트한 값이 value 로 존재한다. 2 개로 구성된 조합도 많을테고, 3 개, 4 개의 조합 수도 많을 것이다.이제 그중에서 등장 횟수가 가장 많은 조합만 꺼내면 된다.  2 개 조합에서 가장 많은 등장을 한 조합은 AC , 3 개 조합에서 가장 많은 등장을 한 조합은 CDE , 4 개 조합은 최대 등장 횟수가 동일한 ACDE BCFG .​정렬된 결과값이 필요하기 때문에 orders 의 모든 원소들을 정렬result 도 정렬되어야 하고, result 내 원소들도 정렬되어야 한다. 따라서 시작할 때 orders 의 모든 원소들을 정렬시키는 것이 좋다. 그래야 부분 조합을 구할 때도 정렬된 조합으로 만들어져서 정렬과 관련된 작업을 하지 않아도 된다.orders.map { it.toSortedSet().joinToString(\"\") }.forEach { order -&gt;    course.forEach { menuCnt -&gt;        rec(0, menuCnt, order)    }}여기서 배열이나 조합과 같은 컬렉션의 원소들을 모두 합친 형태의 문자열로 만들고 싶으면 jotinToString 을 사용하자. 해당 메서드를 사용하면 컬렉션의 각 원소들을 더하기 연산으로 붙이는 작업을 할 필요가 없다.​course 별 등장 빈도가 가장 높은 조합을 꺼내서 result 에 추가  원하는 조합 수에 해당되는 key 값들만 필터링  그중에서 최대 등장값 구하기 (없으면 쓰레기값 넣기)  주문 횟수가 최소 2개 이상이면서 최대 등장값인 조합 필터링course.forEach { menuCnt -&gt;    val filtered = m.filter { it.key.length == menuCnt }    val max = filtered.maxByOrNull { it.value }?.value ?: Int.MAX_VALUE    answer.addAll(filtered.filter { it.value &gt; 1 &amp;&amp; it.value == max }.keys)}​부분 조합을 구하기 위해 재귀 함수 이용백트래킹을 응용해서 원하는 개수의 부분 조합을 구한다. 조합이 완성될 때마다 map 에 해당 조합을 새로 등록하거나 카운트를 증가시킨다.private fun rec(    start: Int,    targetLength: Int,    order: String,    tmp: MutableList&lt;Char&gt; = mutableListOf(),) {    if(tmp.size == targetLength) {        with(tmp.joinToString(\"\")) {            if(!m.containsKey(this)) { m[this] = 0 }            m[this] = m[this]!! + 1        }        return    }    for(i in start..order.lastIndex) {        tmp.add(order[i])        rec(i+1, targetLength, order, tmp)        tmp.removeLast()    }}​전체 코드class Solution {    private val m = mutableMapOf&lt;String, Int&gt;()    fun solution(orders: Array&lt;String&gt;, course: IntArray): Array&lt;String&gt; {        val answer = ArrayList&lt;String&gt;()        orders.map { it.toSortedSet().joinToString(\"\") }.forEach { order -&gt;            course.forEach { menuCnt -&gt;                rec(0, menuCnt, order)            }        }        course.forEach { menuCnt -&gt;            val filtered = m.filter { it.key.length == menuCnt }            val max = filtered.maxByOrNull { it.value }?.value ?: Int.MAX_VALUE            answer.addAll(filtered.filter { it.value &gt; 1 &amp;&amp; it.value == max }.keys)        }        return answer.sorted().toTypedArray()    }    private fun rec(        start: Int,        targetLength: Int,        order: String,        tmp: MutableList&lt;Char&gt; = mutableListOf(),    ) {        if(tmp.size == targetLength) {            with(tmp.joinToString(\"\")) {                if(!m.containsKey(this)) { m[this] = 0 }                m[this] = m[this]!! + 1            }            return        }        for(i in start..order.lastIndex) {            tmp.add(order[i])            rec(i+1, targetLength, order, tmp)            tmp.removeLast()        }    }}"
  },
  
  {
    "title": "(프로그래머스 | Kotlin) - 2차원 동전 뒤집기",
    "url": "/posts/KotlinAlgorithm11/",
    "categories": "CS, 알고리즘 문제",
    "tags": "Kotlin, Algorithm, 알고리즘, 프로그래머스",
    "date": "2023-11-23 12:00:00 +0900",
    





    
    "snippet": "해결 방법이 문제는 특정 행, 혹은 열을 뒤집어서 원하는 형태를 만드는 게 핵심이다. 어떤 행, 혹은 열을 뒤집는 순서가 중요한 것이 아니다. 어떤 행, 혹은 열의 상태를 어떻게 할 것인지(뒤집거나 그대로 두거나)가 중요하다.  M X N  형태에서 특정 열과 행의 상태를 결정하는 방식으로 로직을 짜면 된다.​뒷면, 앞면의 상태값을 비트로 표현해보자문...",
    "content": "해결 방법이 문제는 특정 행, 혹은 열을 뒤집어서 원하는 형태를 만드는 게 핵심이다. 어떤 행, 혹은 열을 뒤집는 순서가 중요한 것이 아니다. 어떤 행, 혹은 열의 상태를 어떻게 할 것인지(뒤집거나 그대로 두거나)가 중요하다.  M X N  형태에서 특정 열과 행의 상태를 결정하는 방식으로 로직을 짜면 된다.​뒷면, 앞면의 상태값을 비트로 표현해보자문제 마지막에 보면 0 은 동전의 앞면, 1 은 동전의 뒷면을 의미한다. 그렇다면  0 1 을 비트 연산으로 처리해보자. 예를 들어서 2 X 2 형태라고 가정해보자. 행과 열은 각각 2개고 다음과 같이 표현할 수 있다.두 개면 모두 앞면인 경우와 모두 뒷면 경우, 한쪽은 앞면 한쪽은 뒷면인 경우가 존재한다. 이를 비트 형식으로 표현하면 다음과 같이 표현할 수 있다.  예를 들어서 행에서 00 은 첫 번째 행, 두 번째 행 모두 앞면인 상태를 의미한다.행 -&gt;00 01 10 11 열 -&gt; 00 01 10 11​시프트 연산을 응용하여 모든 경우의 수(완전 탐색)를 꺼내 처리해보자비트 00 은 십진수로  0 을 의미한다. 비트 01 은 1 이다. 비트 10 은 2 이다. 비트 11 은 3 이다. 즉, 0 부터 3 까지 반복문을 통해서 나올 수 있는 동전판의 모든 경우를 꺼내서 타겟과 일치하는지 검사할 수 있다.for(i in 0 until (1 shl 2))// 1 shl 2 =&gt; 2^2를 의미한다.여기서 행과 열의 비트를 합쳐서 하나의 반복문으로 처리한다. 이렇게 하면 2X2 형태에서 나올 수 있는 경우의 수를 하나의 비트식으로 표현할 수 있다.예를 들어서 2X2 형태에서 모든 행은 뒷면이고 모든 열은 앞면인 경우라면 1100, 반대로 모든 행은 앞면이고 모든 열이 뒷면이라면 0011 이다. 맨 앞의 두 개가 열의 상태값이고 뒤의 두 개가 행의 상태값이다.이렇게 0000 부터 1111 까지 모든 조합을 꺼내서 원본과 비교하여 뒤집거나 그대로 두는 코드를 작성하면 된다.for( i in 0 until (1 shl col+row))// col =&gt; 행의 크기// row =&gt; 열의 크기// 2X2형태라면 (1 shl 4) =&gt; 2^4가 된다.// 0000 ~ 1111 까지 루프​비트 연산을 이용하여 처리하자for( i in 0 until (1 shl col+row))// 2X2크기라고 가정해당 반복문을 동작시키면 0000 부터 1111 까지 나오는데 현재 1010 차례라고 가정해보자. 그리고 원본이 1100 라고 하자. 앞의 두 개는 열의 상태값을 의미하고 뒤의 두 개는 행의 상태값을 의미한다.행부터 살펴보면 2^1 부분의 값이 다르다. 반면에  2^0 부분은 서로 0 이기 때문에 뒤집을 필요가 없다. 따라서 값이 다른  2^1 부분은 뒤집어야 함을 의미하므로 이 부분은 뒤집어주면 된다.첫 번째 행의 인덱스는 0, 두 번째 행의 인덱스는 1 이다. 첫 번째 행의 상태값을 의미하는 비트 위치는 2^0 , 두 번째 행은 2^1 이다. 따라서 두 번째 행을 뒤집으면 된다. 이 개념을 코드로 옮기면 다음과 같다.  XOR 비트 연산을 사용하면 뒤집는 동작을 쉽게 처리할 수 있다.​행을 처리하는 코드for(c in 0 until col) {    if(b and (1 shl c) != 0) {        flipCounter++        tmp[c] = tmp[c].map { it xor 1 }.toIntArray()    }}열을 처리하는 코드for(r in 0 until row) {    if(b and (1 shl r + col) != 0) {        flipCounter++        for(i in 0..tmp.lastIndex) { tmp[i][r] = tmp[i][r] xor 1 }    }}  열의 경우에는 2^2 부터 검사를 해야 하기 때문에 (1 shl r+col) 로 AND 처리를 해줘야 한다.​마지막은 target 과 비교하여 동일한지 검사한다.if(tmp.contentDeepEquals(target)) { answer = min(answer, flipCounter) }​전체 코드import kotlin.math.*class Solution {    fun solution(beginning: Array&lt;IntArray&gt;, target: Array&lt;IntArray&gt;): Int {        val col = beginning.size        val row = beginning[0].size        var answer = Int.MAX_VALUE        for(b in 0 until (1 shl col+row)) {            val tmp = Array(col) { i -&gt; IntArray(row) { j -&gt; beginning[i][j] } }            var flipCounter = 0            for(c in 0 until col) {                if(b and (1 shl c) != 0) {                    flipCounter++                    tmp[c] = tmp[c].map { it xor 1 }.toIntArray()                }            }            for(r in 0 until row) {                if(b and (1 shl r + col) != 0) {                    flipCounter++                    for(i in 0..tmp.lastIndex) { tmp[i][r] = tmp[i][r] xor 1 }                }            }            if(tmp.contentDeepEquals(target)) { answer = min(answer, flipCounter) }        }        return if(answer == Int.MAX_VALUE) -1 else answer    }    }"
  },
  
  {
    "title": "(프로그래머스 | C++) - 방금그곡",
    "url": "/posts/KotlinAlgorithm10/",
    "categories": "CS, 알고리즘 문제",
    "tags": "Kotlin, Algorithm, 알고리즘, 프로그래머스, 카카오 코딩테스트",
    "date": "2023-11-23 12:00:00 +0900",
    





    
    "snippet": "해결 방법문제에서 주어진 조건을 가지고 시킨 것만 잘 수행하면 된다. musicinfos 에서는 \"12:00,12:14,HELLO,CDEFGAB\" 형식의 문자열을 원소로 가지고 있다. 이 문자열을 잘 분해해서 처리해야 하는데 순서는 다음과 같다.      문자열을 , 기준으로 split 한 배열을 생성한다.  [\"12:00\", \"12:14\", \"HEL...",
    "content": "해결 방법문제에서 주어진 조건을 가지고 시킨 것만 잘 수행하면 된다. musicinfos 에서는 \"12:00,12:14,HELLO,CDEFGAB\" 형식의 문자열을 원소로 가지고 있다. 이 문자열을 잘 분해해서 처리해야 하는데 순서는 다음과 같다.      문자열을 , 기준으로 split 한 배열을 생성한다.  [\"12:00\", \"12:14\", \"HELLO\", \"CDEFGAB\"]    vector&lt;string&gt; split(string str, char splitChar) {    vector&lt;string&gt; result;    istringstream iss(str);    string buffer;    while(getline(iss, buffer, splitChar)) {        result.push_back(buffer);    }    return result;}   for(string info: musicinfos) {    vector&lt;string&gt; infoList = split(info, ',');}            # 이 붙은 음을 하나로 합치기 위해서 알파벳 소문자로 변환해준다. 예를 들어서 C# 이 있다면 c 이렇게 하나의 문자로 바꿔준다. 이렇게 해야 ABC 를 찾아야 하는데 ABC# 에서 C# 을 C 로 착각해서 ABC 가 있는 것으로 인식하는 변수를 방지할 수 있다.    string convertSharpToLowercase(string str) {    int i = 0;    while(i &lt; str.length()) {        if(str[i] == '#') {            char lowercase = tolower(str[i-1]);            str.replace(i-1, 2, string(1, lowercase));            continue;        }        i++;    }    return str;}            실행시간을 정수형으로 구한다.  12:00, 12:14 의 수행시간은 총 14분이다.    int getPlaytimeWithString(string start, string end) {    int startForMinute = stoi(start.substr(0,2)) * 60 + stoi(start.substr(3));    int endForMinute = stoi(end.substr(0,2)) * 60 + stoi(end.substr(3));    return endForMinute - startForMinute;}            실행시간 크기만큼 악보를 재구성한다. 예를 들어서  CDEFGAB 이게 기본 악보인데 1분당 1개의 음을 구성하므로 14분으로 재구성하면 CDEFGABCDEFGAB 이다.    string getMelodyDuringPlaytime(string melodyOrigin, int playtime) {    string melodyDuringPlaytime = \"\";    if(melodyOrigin.length() &lt;= playtime) {        melodyDuringPlaytime = melodyOrigin;        for(int i = 0; i &lt; playtime - melodyOrigin.length(); i++) {            melodyDuringPlaytime += melodyOrigin[i%melodyOrigin.length()];        }    }    else {        for(int i = 0; i &lt; playtime; i++) {            melodyDuringPlaytime += melodyOrigin[i];        }    }    return melodyDuringPlaytime;}            재구성한 악보에서 m 에 해당되는 구간이 있는지 찾는다. 이런 방식으로 musicinfos 의 모든 음악들을 비교하면 된다.    bool isValid(string userMelody, string playtimeMelody) {    return playtimeMelody.find(userMelody) != string::npos;}      전체 코드#include &lt;string&gt;#include &lt;vector&gt;#include &lt;sstream&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;string&gt; split(string str, char splitChar) {    vector&lt;string&gt; result;    istringstream iss(str);    string buffer;    while(getline(iss, buffer, splitChar)) {        result.push_back(buffer);    }    return result;}int getPlaytimeWithString(string start, string end) {    int startForMinute = stoi(start.substr(0,2)) * 60 + stoi(start.substr(3));    int endForMinute = stoi(end.substr(0,2)) * 60 + stoi(end.substr(3));    return endForMinute - startForMinute;}string convertSharpToLowercase(string str) {    int i = 0;    while(i &lt; str.length()) {        if(str[i] == '#') {            char lowercase = tolower(str[i-1]);            str.replace(i-1, 2, string(1, lowercase));            continue;        }        i++;    }    return str;}string getMelodyDuringPlaytime(string melodyOrigin, int playtime) {    string melodyDuringPlaytime = \"\";    if(melodyOrigin.length() &lt;= playtime) {        melodyDuringPlaytime = melodyOrigin;        for(int i = 0; i &lt; playtime - melodyOrigin.length(); i++) {            melodyDuringPlaytime += melodyOrigin[i%melodyOrigin.length()];        }    }    else {        for(int i = 0; i &lt; playtime; i++) {            melodyDuringPlaytime += melodyOrigin[i];        }    }    return melodyDuringPlaytime;}bool isValid(string userMelody, string playtimeMelody) {    return playtimeMelody.find(userMelody) != string::npos;}string solution(string m, vector&lt;string&gt; musicinfos) {    string targetTitle = \"(None)\";    int targetPlaytime = -1;    for(string info: musicinfos) {        vector&lt;string&gt; infoList = split(info, ',');        int playtime = getPlaytimeWithString(infoList[0], infoList[1]);        if(playtime &lt;= targetPlaytime) continue;        string melodyOrigin = convertSharpToLowercase(infoList[3]);        string melodyDuringPlaytime = getMelodyDuringPlaytime(melodyOrigin, playtime);        if(isValid(convertSharpToLowercase(m), melodyDuringPlaytime)) {            targetPlaytime = playtime;            targetTitle = infoList[2];        }    }    return targetTitle;}"
  },
  
  {
    "title": "(프로그래머스 | Kotlin) - 전력망을 둘로 나누기",
    "url": "/posts/KotlinAlgorithm9/",
    "categories": "CS, 알고리즘 문제",
    "tags": "Kotlin, Algorithm, 알고리즘, 프로그래머스",
    "date": "2023-11-21 12:00:00 +0900",
    





    
    "snippet": "해결 방법특정 전선이 끊어지면 하나의 트리는 두 개의 그룹으로 나뉘게 된다. 따라서 두 개의 그룹 각각, DFS 혹은 BFS 를 이용해서 그룹 내 노드의 개수를 카운트한다. 나는 BFS 를 이용해서 노드의 개수를 구했다.그리고 탐색 시작점은 제거한 전선과 연결된 노드로 지정했다. 첫 번째 입출력 예제 그림에서 4 와  7 이 연결된 전선을 끊은 경우를...",
    "content": "해결 방법특정 전선이 끊어지면 하나의 트리는 두 개의 그룹으로 나뉘게 된다. 따라서 두 개의 그룹 각각, DFS 혹은 BFS 를 이용해서 그룹 내 노드의 개수를 카운트한다. 나는 BFS 를 이용해서 노드의 개수를 구했다.그리고 탐색 시작점은 제거한 전선과 연결된 노드로 지정했다. 첫 번째 입출력 예제 그림에서 4 와  7 이 연결된 전선을 끊은 경우를 보여주는데 이때 생긴 두 개의 그룹에서 탐색 시작점은 4,  7 이 된다. 4 에서 탐색을 시작하면 6개, 7 에서 탐색을 시작하면 3개가 카운드된다.따라서 모든 전선에 대해서 위 방법을 적용시켜 비교해야 한다. 예제에서 전선 정보가 담긴 wires 을 줬기 때문에 이 배열의 각 원소(전선)에 대해서 트리를 두 개로 나누고 각 트리마다 송전탑 개수를 BFS 로 구한다.​전체 코드import kotlin.math.*class Solution {    private val node = Array(101) { arrayListOf&lt;Int&gt;() }    fun solution(n: Int, wires: Array&lt;IntArray&gt;): Int {        var answer = Int.MAX_VALUE        val isChecked = Array(101) { Array(101) { false } }        wires.forEach {            node[it[0]].add(it[1])            node[it[1]].add(it[0])        }        for(a in 1..n) {            node[a].forEach { b -&gt;                if(!isChecked[a][b] &amp;&amp; !isChecked[b][a]) {                    answer = min(answer, abs(bfs(a, Pair(a, b)) - bfs(b, Pair(a, b))))                    isChecked[a][b] = true                    isChecked[b][a] = true                }            }        }        return answer    }    private fun bfs(s: Int, blockSet: Pair&lt;Int, Int&gt;): Int {        var towerCounter = 0        val isVisited = Array(101) { false }        val q = ArrayDeque&lt;Int&gt;()        q.add(s)        isVisited[s] = true        while(!q.isEmpty()) {            val cur = q.first()            q.removeFirst()            towerCounter++            node[cur].forEach { n -&gt;                if(!isVisited[n] &amp;&amp; blockSet != Pair(cur, n) &amp;&amp; blockSet != Pair(n, cur) ) {                    isVisited[n] = true                    q.add(n)                }            }        }        return towerCounter    }    }"
  },
  
  {
    "title": "(프로그래머스 | Kotlin) - 호텔 대실",
    "url": "/posts/KotlinAlgorithm8/",
    "categories": "CS, 알고리즘 문제",
    "tags": "Kotlin, Algorithm, 알고리즘, 프로그래머스",
    "date": "2023-11-21 12:00:00 +0900",
    





    
    "snippet": "해결 방법이 문제의 핵심은 그리디 알고리즘을 이용하는 것이다. 우선 문제에서 예약 시작 시간과 종료 시간이 여러 개 담긴 배열을 줬으므로 해당 예약 시작 시간을 기준으로 배열을 정렬시킨다. 그리고 정렬된 배열을 가지고 반복문을 돌려서 현재 원소의 예약 시작 시간보다 10분 더 적은 종료 시간이 있는 방 번호를 찾는다.예를 들어서 현재 예약이 잡힌 방의...",
    "content": "해결 방법이 문제의 핵심은 그리디 알고리즘을 이용하는 것이다. 우선 문제에서 예약 시작 시간과 종료 시간이 여러 개 담긴 배열을 줬으므로 해당 예약 시작 시간을 기준으로 배열을 정렬시킨다. 그리고 정렬된 배열을 가지고 반복문을 돌려서 현재 원소의 예약 시작 시간보다 10분 더 적은 종료 시간이 있는 방 번호를 찾는다.예를 들어서 현재 예약이 잡힌 방의 갯수를 n 개라고 가정하자. 그럼 방의 번호는 현재 1 번부터 n 번까지 존재한다. 정렬된 배열의 반복문을 돌렸을 때 가장 좋은 예약 방법은 기존에 존재하는 방에 예약을 거는 것이다. 그렇게 하기 위해선 현존하는 방들 중에서 마지막으로 예약된 시간대의 종료 시간이 현재 원소의 시작 시간보다 10분 더 적어야 한다.그래서 모든 방을 탐색해서 예약이 가능한 방을 찾으면 해당 방의 예약 현황을 업데이트(마지막 예약의 종료 시간)한다. 업데이트가 완료되면 다음 원소로 넘어가서 이전과 똑같은 작업을 한다.만약 예약 가능한 방이 존재하지 않는다면 현존하는 방으로는 예약을 할 수 없다는 뜻이므로 이때는 방을 새로 생성한다. 현존하는 방의 갯수가 n 개라면 이때 방을 새로 생성해서 n + 1 개가 된다.​설명왜 종료 시간이 아닌 시작 시간을 기준으로 배열을 정렬시켜야 하는가?종료 시간을 기준으로 정렬을 했다 가정해보자. 다음 예시는 임의로 만들어본 예시다. 해당 그림은 예약 종료 시간을 기준으로 위에서 아래로 오름차순 정렬을 한 상태를 나타낸다.여기서 설명했던 해결 방법대로 예약 시간들을 배치하면 다음과 같다. 해당 결과로 방이 세 개 생성된다. 뭔가 이상하지 않은가? 뭔가 듬성듬성 배치되어 방이 세 개나 사용됐다.12:14 ~ 12:34 시간대를 첫 번째 방이 아닌 두 번째 방에 배치하고 11:20 ~ 14:20 시간대를 첫 번째 방에 배치하면 방을 세 개로 사용하지 않고 두 개만 가지고 모든 예약 처리를 할 수 있다. 이런 반례가 있어서 종료 시간을 기준으로 정렬하는 것은 옳지 않다.​전체 코드class Solution {    fun solution(bookTime: Array&lt;Array&lt;String&gt;&gt;): Int {        val bookTimeMinute = bookTime            .map { arrayOf(it[0].toMinute(), it[1].toMinute()) }            .sortedBy { it[0] }        val availableTime = ArrayList&lt;Int&gt;()        for(t in bookTimeMinute) {            var renewedRoom: Int? = null            for((roomNumber, lastTime) in availableTime.withIndex()) {                if(lastTime &lt;= t[0]) {                    availableTime[roomNumber] = t[1]+10                    renewedRoom = roomNumber                    break                }            }            renewedRoom ?: availableTime.add(t[1]+10)        }        return availableTime.size    }    private fun String.toMinute(): Int {        val sum: Int        this            .split(':')            .map { it.toInt() }            .let { sum = it[0] * 60 + it[1] }        return sum    }}"
  },
  
  {
    "title": "(프로그래머스 | Kotlin) - 매칭 점수",
    "url": "/posts/KotlinAlgorithm7/",
    "categories": "CS, 알고리즘 문제",
    "tags": "Kotlin, Algorithm, 알고리즘, 프로그래머스",
    "date": "2023-11-19 21:00:00 +0900",
    





    
    "snippet": "해결 방법정말 보자마자 머리가 지끈거리는 문제였다. 카카오 코테 문제를 풀어보면서 문자열 처리 로직을 많이 작성했었는데 설마 html 형식을 통째로 주는 건 상상도 못했다. 필요한 건 크게 url, 키워드, 외부 링크, 이렇게 세 가지다.여기서 문제는 해당 세 가지를 구하기 위해서 정규식을 사용해야 하는데 나는 정규식을 사용할 때 항상 검색해서 복붙한...",
    "content": "해결 방법정말 보자마자 머리가 지끈거리는 문제였다. 카카오 코테 문제를 풀어보면서 문자열 처리 로직을 많이 작성했었는데 설마 html 형식을 통째로 주는 건 상상도 못했다. 필요한 건 크게 url, 키워드, 외부 링크, 이렇게 세 가지다.여기서 문제는 해당 세 가지를 구하기 위해서 정규식을 사용해야 하는데 나는 정규식을 사용할 때 항상 검색해서 복붙한 게 전부여서 식을 어떻게 작성해야 하는지 몰랐다. 그래서 검색을 해서 몇몇 정규식을 참고했다.1. 현재 페이지의 URL\"(&lt;meta property=\\\"og:url\\\" content=\\\"(\\\\S*)//(\\\\S*)\\\"/&gt;)\"페이지의 url 을 구할 때 중요한 점은 문제에서 준 양식과 정확히 일치해야 한다는 것이다. 보니까 url 부분을 포함해서 조금이라도 양식에 벗어나는 예제가 있는 것 같다.2. html 페이지 내 키워드 수\"[^a-zA-Z]\"키워드 갯수는 알파벳이 아닌 문자로 둘러싸인 키워드를 찾으면 되므로 알파벳이 아닌 문자를 기준으로 split 해서 키워드 갯수를 구하는 방식으로 구현했다.3. 외부링크 갯수\"&lt;a href=\\\"https://(.+?)\\\"&gt;\"현재 페이지의 url 구하는 것처럼 외부 링크 태그 양식을 정확히 지켜야 한다. 외부링크는 여러 개 존재할 수 있기 때문에 하나만 find 하면 안되고 findAll 해야 한다.​전체 코드위의 세 가지를 구현하기 위해 필요한 정규식만 만들줄 알면 나머지는 구현하는 데 크게 어렵지 않다.class Solution {    fun solution(word: String, pages: Array&lt;String&gt;): Int {        var answer = 0        var maxScore = -1.0        val pageInfo = ArrayList&lt;WebInfo&gt;()        val pageIndex = mutableMapOf&lt;String, Int&gt;()        pages.forEach { html -&gt;            getSelfUrl(html)?.let { selfUrl -&gt;                val keyword = getKeywordCount(html.lowercase(), word.lowercase())                val extLink = getLinkCount(html)                pageIndex[selfUrl] = pageInfo.size                pageInfo.add(WebInfo(selfUrl, keyword, extLink, mutableSetOf(), pageInfo.size))            }        }        pageInfo.forEach { webInfo -&gt;            webInfo.extLink.forEach { extLink -&gt;                if(pageIndex.containsKey(extLink)) {                    pageInfo[pageIndex[extLink]!!].linker.add(webInfo.url)                }            }        }        pageInfo.forEachIndexed { i, webInfo -&gt;            var webScore = webInfo.basic.toDouble()            webInfo.linker.forEach { linker -&gt;                webScore += pageInfo[pageIndex[linker]!!].getSingleLinkScore()            }            if(maxScore &lt; webScore) {                maxScore = webScore                answer = i            }        }        return answer    }    private fun getSelfUrl(html: String): String? {        var urlTag: String? = null        Regex(\"(&lt;meta property=\\\"og:url\\\" content=\\\"(\\\\S*)//(\\\\S*)\\\"/&gt;)\")            .find(html)            ?.value            ?.let {                urlTag = it.split(\" \")[2].split(\"\\\"\")[1]            }        return urlTag    }    private fun getKeywordCount(html: String, keyword: String): Int {        return html            .split(Regex(\"[^a-zA-Z]\"))            .filter { it == keyword }            .size    }    private fun getLinkCount(html: String): MutableSet&lt;String&gt; {        val linker = mutableSetOf&lt;String&gt;()        Regex(\"&lt;a href=\\\"https://(.+?)\\\"&gt;\")            .findAll(html)            .forEach { linkTag -&gt;                linker.add(linkTag.value.split(\" \")[1].split(\"\\\"\")[1])            }        return linker    }    data class WebInfo(        val url: String,        val basic: Int,        val extLink: MutableSet&lt;String&gt;,        val linker: MutableSet&lt;String&gt;,        val index: Int    ) {        fun getSingleLinkScore(): Double {            return if (extLink.size == 0) 0.0 else basic.toDouble() / extLink.size        }    }}​참조외부링크 정규식 참고키워드 갯수와 페이지 URL 정규식 참고"
  },
  
  {
    "title": "(프로그래머스 | Kotlin) - 수식 최대화",
    "url": "/posts/KotlinAlgorithm6/",
    "categories": "CS, 알고리즘 문제",
    "tags": "Kotlin, Algorithm, 알고리즘, 프로그래머스",
    "date": "2023-11-15 12:00:00 +0900",
    





    
    "snippet": "해결 방법뭔가 풀이 방법이 다양할 것 같은 문제인데 나는 재귀를 이용해서 해결했다. 연산 기호가 최대 세 개인데 연산 우선순위를 리스트로 표현했다. 예를 들어서 표현식에서 사용된 연산 기호가 * - , 2개라면 만들 수 있는 우선순위 조합은 2개, [[*, -], [-, *]]  이렇게 리스트로 표현이 가능하다. 인덱스가 클수록 연산 우선순위가 높다는...",
    "content": "해결 방법뭔가 풀이 방법이 다양할 것 같은 문제인데 나는 재귀를 이용해서 해결했다. 연산 기호가 최대 세 개인데 연산 우선순위를 리스트로 표현했다. 예를 들어서 표현식에서 사용된 연산 기호가 * - , 2개라면 만들 수 있는 우선순위 조합은 2개, [[*, -], [-, *]]  이렇게 리스트로 표현이 가능하다. 인덱스가 클수록 연산 우선순위가 높다는 뜻이다.이런 식으로 만들 수 있는 연산 우선순위를 모두 만들고 모든 경우에 대해 식을 계산하고 결과값을 비교해서 가장 큰 값을 리턴하면 문제 해결이 가능하다. 그런데 문제는 식을 계산하는 방법이다. 여기서 풀이 방법이 다양하게 갈릴 것 같은데 내가 푼 방법은 다음과 같다.​1. 나올 수 있는 연산 우선순위 조합 모두 구하기\"100-200*300-500+20\" 예제를 예시로 생각해보자. 사용된 연산자는 * - + 총 세 개, 나올 수 있는 연산 우선순위 조합은 총 여섯 개다. 우선 이 여섯 개를 구하는 알고리즘을 짜야 한다. 이는 순열 알고리즘을 이용해서 구하면 된다.제네릭 함수, 리스트 확장함수, 연산자 함수를 응용한 깔끔한 순열 알고리즘이다. 자세한 원리는 링크를 통해서 확인하면 된다. 개인적으로 가장 깔끔한 순열 알고리즘인 것 같다.private fun &lt;T&gt; permutation(sub: List&lt;T&gt;, fin: List&lt;T&gt; = listOf()): List&lt;List&lt;T&gt;&gt; {    return if(sub.isEmpty()) listOf(fin)    else sub.flatMap { permutation(sub - it, fin + it) }}permutation(listOf('*', '-', '+'))// [*, +, -]// [*, -, +]// [+, *, -]// [+, -, *]// [-, *, +]// [-, +, *]​2. 재귀를 이용한 식 계산permutation(existingOperator.toList()).forEach {    answer = max(answer, abs(rec(expression, it.toList())))}rec : 식을 계산한 결과값을 반환하는 재귀 함수이고 계산할 식이 담긴 문자열과 연산 우선순위 정보를 인자로 넘긴다. 그리고 계산 결과의 절대값으로 비교를 해야 하므로 abs 로 감싸준다. 이렇게 메인 함수에서 틀을 잡는다.다음은 rec 함수 구현 부분이다. permutation 결과값의 첫 번째 값이 [*, +, -] 이므로  rec 함수로 넘기는 인자는 \"100-200*300-500+20\" , [*, +, -] 다. 연산자 우선순위 리스트의 인덱스가 높을수록 연산 우선순위가 높다고 설정했기 때문에 - -&gt; + -&gt; *  순서로 계산을 처리한다.해당 순서로 계산을 처리하기 위해선 연산 우선순위가 낮은순으로 연산자를 기준으로 split 을 하고, split 의 결과값으로 만들어진 리스트 내의 모든 식의 결과값들을 현재 기준이 되는 연산자로 계산을 해주면 된다. 글만 봐서는 바로 이해가 되지 않으니 예시를 살펴보자.​1. 연산 우선순위가 가장 낮은 연산자는 * 이므로 이 연산자를 기준으로 split 을 한다\"100-200*300-500+20\" -&gt; [\"100-200\", \"300-500+20\"]식이 두 개로 분리가 됐다. \"100-200\" 을 A 라 하고 \"300-500+20\" 을 B 라고 한다면 A * B 가 rec 함수의 반환값이 된다. 따라서 A B 를 먼저 계산을 해야 한다. 여기서 rec 함수를 이용해서 A B 의 결과값을 받아오면 된다. 그리고 *  연산자를 기준으로 분리된 식들이기 때문에 이제 처리해야 할 연산자는 + -  둘뿐이다.​2. split 으로 분리된 식들의 결과값을 rec 재귀호출로 구한다.따라서 A = rec(\"100-200\", [\"+\", \"-\"])  , B = rec(\"300-500+20\", [\"+\", \"-\"]) 이 된다. 이제 재귀호출로  A B 를 구하는 rec 함수를 살펴보자.  * 연산자를 기준으로 처리했을 때와 마찬가지로 이번에는 + 연산자를 기준으로 split 한다.A -&gt; \"100-200\" -&gt; [\"100-200\"]B -&gt; \"300-500+20\" -&gt; [\"300-500\", \"20\"]이제 - 연산자에 해당되는 식만 남았다. 이것들도 rec 함수를 재귀호출하여 계산 결과를 구한다. 각각 rec(\"100-200\", [\"-\"]) rec(\"300-500\", [\"-\"]) rec(\"20\", [\"-\"]) 를 C D E 라고 하면 A = C , B = D + E 가 된다. 그리고 마지막에는 A * B 가 최종 반환된다.​정리  연산 우선순위대로 식을 계산하기 위해서는 연산 우선순위가 가장 낮은 연산자부터 해당 연산자를 기준으로 식을 split 한다. split 을 하면 분리된 식들로 구성된 리스트가 반환된다.  분리된 식들의 계산 결과를 rec 함수를 재귀호출하여 구한다.  분리된 식들의 계산 결과들을 현재 split  기준이 되는 연산자로 계산하여 반환한다.  결국 가장 낮은 연산 우선순위의 연산자부터 가장 큰 우선순위의 연산자 순서로 split 및 재귀호출을 하게 되면 결국 재귀호출의 특성 때문에 계산 순서가 연산 우선순위가 가장 높은 연산자에서 가장 낮은 연산자 순으로 처리가 된다.​rec 함수 코드private fun rec(expression: String, splitOperators: List&lt;Char&gt;): Long {    var sum: Long    getNextSplitOperatorIndex(expression, splitOperators)?.let { i -&gt;        val splitOperator = splitOperators[i]        val splitExpression = expression.split(splitOperator)        sum = rec(splitExpression.first(), splitOperators.subList(i + 1, splitOperators.size))        splitExpression.subList(1, splitExpression.size).forEach {            sum = splitOperator calculate Pair(sum, rec(it, splitOperators.subList(i + 1, splitOperators.size)))        }        return sum    }    return expression.toLong()}private fun getNextSplitOperatorIndex(expression: String, splitOperators: List&lt;Char&gt;): Int? {    var i = 0    while(i &lt; splitOperators.size &amp;&amp; !expression.contains(splitOperators[i])) { i++ }    return if (i == splitOperators.size) null else i}​연산 우선순위를 고려한 rec 함수 처리 과정​전체 코드fun solution(expression: String): Long {    var answer: Long = 0    val existingOperator = mutableSetOf&lt;Char&gt;()    listOf('*', '+', '-').forEach {        if (expression.contains(it)) { existingOperator.add(it) }    }    permutation(existingOperator.toList()).forEach {        answer = max(answer, abs(rec(expression, it.toList())))    }    return answer}private fun rec(expression: String, splitOperators: List&lt;Char&gt;): Long {    var sum: Long    getNextSplitOperatorIndex(expression, splitOperators)?.let { i -&gt;        val splitOperator = splitOperators[i]        val splitExpression = expression.split(splitOperator)        sum = rec(splitExpression.first(), splitOperators.subList(i + 1, splitOperators.size))        splitExpression.subList(1, splitExpression.size).forEach {            sum = splitOperator calculate Pair(sum, rec(it, splitOperators.subList(i + 1, splitOperators.size)))        }        return sum    }    return expression.toLong()}private fun getNextSplitOperatorIndex(expression: String, splitOperators: List&lt;Char&gt;): Int? {    var i = 0    while(i &lt; splitOperators.size &amp;&amp; !expression.contains(splitOperators[i])) { i++ }    return if (i == splitOperators.size) null else i}private fun &lt;T&gt; permutation(sub: List&lt;T&gt;, fin: List&lt;T&gt; = listOf()): List&lt;List&lt;T&gt;&gt; {    return if(sub.isEmpty()) listOf(fin)    else sub.flatMap { permutation(sub - it, fin + it) }}private infix fun Char.calculate(pair: Pair&lt;Long, Long&gt;): Long {    return when (this) {        '*' -&gt; pair.first * pair.second        '+' -&gt; pair.first + pair.second        '-' -&gt; pair.first - pair.second        else -&gt; throw IllegalArgumentException()    }}"
  },
  
  {
    "title": "Kotlin Generic (1) 제네릭 클래스와 함수, 그리고 변성",
    "url": "/posts/Kotlin-Generic/",
    "categories": "CS, 프로그래밍 언어",
    "tags": "Kotlin, Java, Generic, 제네릭",
    "date": "2023-11-09 12:00:00 +0900",
    





    
    "snippet": "Kotlin도 Java의 제네릭 기능을 제공한다.  “Classes in Kotlin can have type parameters, just like in Java:” - Kotlin 공식 문서코틀린의 클래스는 자바와 마찬가지로 타입 파라미터를 가질 수 있습니다. 제네릭을 사용함으로써 컴파일 타임에 타입 안전성을 관리할 수 있고 여러 타입에 대응하여 ...",
    "content": "Kotlin도 Java의 제네릭 기능을 제공한다.  “Classes in Kotlin can have type parameters, just like in Java:” - Kotlin 공식 문서코틀린의 클래스는 자바와 마찬가지로 타입 파라미터를 가질 수 있습니다. 제네릭을 사용함으로써 컴파일 타임에 타입 안전성을 관리할 수 있고 여러 타입에 대응하여 코드를 재사용하는 이점을 얻을 수 있습니다.코틀린 역시  &lt;&gt; 기호를 이용한 제네릭 기능을 제공합니다. 다음 Box 클래스는 제네릭을 사용하여 만들어졌기 때문에  Int , String, Float 등의 다양한 타입을 가질 수 있습니다.class Box&lt;T&gt;(t: T) {    var value = t}val boxInt: Box&lt;Int&gt; = Box&lt;Int&gt;(1)val boxString: Box&lt;String&gt; = Box&lt;String&gt;(\"empty\")val boxFloat: Box&lt;Float&gt; = Box&lt;Float&gt;(2.0F)위의 예시를 통해서 제네릭(Generic)은 단순히 하나의 타입으로 고정하는 것이 아닌 다양한 타입을 수용할 수 있는 하나의 일반화(Generalization)된 타입 파라미터라고 할 수 있습니다.위의 예제에서는 타입 파라미터 정의를 T 로 했는데 이는 제네릭을 사용할 때 무조건 T 를 사용해야 한다는 뜻이 아닙니다. 제네릭에서 사용되는 기호는 정해진 것이 아닌 사용자가 직접 정의합니다. 그래서 상황에 따라 네이밍을 하면 됩니다.            유형      의미                  &lt;T&gt;      Type              &lt;E&gt;      Element              &lt;K&gt;      Key              &lt;V&gt;      Value              &lt;N&gt;      Number      ​타입 안전성제네릭을 사용하지 않은 클래스의 경우는?Animal 추상 클래스가 있고, 해당 추상 클래스의 구현체인 Tiger,  Lion 이렇게 두 개의 클래스가 존재하는 상황이라고 가정하겠습니다. 동물의 정보와 관련된 클래스를 정의했으므로 이제 동물들을 관리하는 동물원, Zoo 클래스를 정의합니다.abstract class Animalabstract class Mammalia: Animal()class Tiger: Mammalia()class Lion: Mammalia()class Zoo {    private val animals = mutableListOf&lt;Animal&gt;()    fun getLast(): Animal {        return animals.last()    }    fun getFirst(): Animal {        return animals.first()    }    fun add(animal: Animal) {        animals.add(animal)    }}메인 함수에서 호랑이를 동물원에 추가하고 다시 꺼내오는 작업을 했을 때 Tiger로 받으려면 다운캐스팅이기 때문에 변환 타입을 명시해야 합니다.val zoo = Zoo()zoo.add(Tiger())val tiger: Tiger = zoo.getLast() as Tiger그런데 동물 리스트에서 데이터를 꺼내올 때 해당 데이터가 무조건 Tiger 라는 보장이 없습니다. 데이터를 삽입할 때 Tiger 가 아닌 Lion 을 넣을수도 있기 때문입니다. 그래서 as? 를 이용하거나 엘비스 연산자 ?: 를 이용해서 예외에 대응하는 방법이 있습니다만…​제네릭 클래스로 수정하자제네릭을 이용한다면 타입 미스매치 발생을 방지하고 코드 가독성도 좋게 만들 수 있습니다. 동물들을 관리하는 Zoo 클래스에 타입 파라미터 T 를 정의하여 수정하면 클래스 생성부터  Tiger 타입 지정이 가능합니다.이렇게 제네릭 클래스로 만들면 컴파일 타임에 타입 오류를 찾아낼 수 있고 Tiger 를 관리하는 동물원 Zoo 로 관리가 가능합니다. 그래서 as 를 사용해서 캐스팅할 타입을 명시하지 않아도 깔끔하고 안전하게 데이터를 가져올 수 있습니다.class Zoo&lt;T&gt; {    private val animals = mutableListOf&lt;T&gt;()    fun getLast(): T {        return animals.last()    }    fun getFirst(): T {        return animals.first()    }    fun add(animal: T) {        animals.add(animal)    }}val zoo = Zoo&lt;Tiger&gt;()zoo.add(Tiger())val tiger: Tiger = zoo.getLast()​변성변성(Variance)변성(Variance)은 제네릭 클래스끼리의 상속 관계를 나타내는 개념입니다. 변성은 크게 공변, 반공변, 무공변 이렇게 세 가지로 나눌 수 있는데 해당 세 가지의 정의는 다음과 같습니다.            유형      의미                  공변(Covariance)      Tiger 가 Mammalia 의 서브타입이라면 Zoo&lt;Tiger&gt; 는 Zoo&lt;Mammalia&gt; 의 서브타입이다.              반공변(Contravariance)      Tiger 가 Mammalia 의 서브타입이라면 Zoo&lt;Mammalia&gt; 는 Zoo&lt;Tiger&gt; 의 서브타입이다.              무공변(Invariance)      공변도 아니고 반공변도 아닌 상태      ​제네릭 클래스는 기본적으로 무공변동물원 예시 코드를 조금 수정하겠습니다. 다음과 같이 Tiger Lion 의 상위타입인 Mammalia 를 타입 파라미터로 가지는 제네릭 클래스를 생성해서 거기에 Tiger Lion 클래스를 add 해보겠습니다.val zooWithMammalia = Zoo&lt;Mammalia&gt;()zooWithMammalia.add(Tiger())zooWithMammalia.add(Lion())Mammalia 를 타입 파라미터로 가지는 Zoo&lt;Mammalia 의 add 메서드는 파라미터가 animal: Mammalia 로 설정이 되고 여기에 인자로 Tiger , Lion 이 온다면 서로 상속 관계이기 때문에 컴파일 및 실행에 문제가 없습니다.fun add(animal: T) { // animal: Mammalia    animals.add(animal)}이렇게 단일 동물을 다른 동물원에 추가하는 데 문제가 발생하지 않지만 동물원 자체를 다른 동물원에 합치는 경우는 어떨까요? 다음과 같이 동물원 자체를 합치는 메서드를 추가로 작성해보겠습니다.fun mergeOtherZoo(zoo: Zoo&lt;T&gt;) {    this.animals.addAll(zoo.animals)}그리고 Zoo&lt;Mammalia&gt; 에 Zoo&lt;Tiger&gt; 를 병합시켜보겠습니다. 결과는 단일 동물을 추가할 때와 달리 타입 미스매치가 발생합니다.val zooWithTigers = Zoo&lt;Tiger&gt;()val zooWithMammalia = Zoo&lt;Mammalia&gt;()zooWithTigers.add(Tiger())zooWithMammalia.mergeOtherZoo(zooWithTigers) // Type mismatch 발생분명 Zoo&lt;Mammalia&gt; 에 Tiger() 를 추가하는 것은 문제가 없었는데 Zoo&lt;Tiger&gt; 를 추가하는 것에는 문제가 발생합니다. 이는 제네릭 클래스는 기본적으로 무공변 상태이기 때문에 아무런 관계가 없는  Zoo&lt;Mammalia&gt; 와 Zoo&lt;Tiger&gt; 는 병합 시도시 오류가 발생할 수밖에 없는 겁니다.​공변으로 전환이를 해결하기 위해서는 무공변인 상태를 공변으로 전환해야 합니다. 전환하는 방법은 간단합니다. 병합하는 메서드의 타입 파라미터 왼쪽에 out 이라는 키워드를 추가하면 됩니다. 이 결과로 본인의 하위타입을 수용할 수 있고 타입 미스매치 오류가 사라지면서 정상 실행이 됩니다.fun mergeOtherZoo(zoo: Zoo&lt;out T&gt;) {    this.animals.addAll(zoo.animals)}​공변으로 전환시 주의할 점무공변 상태에서 공변으로 전환을 하면 제네릭 클래스 간 상속 관계가 생겨서 인자로 넘길 수 있게 되지만 주의할 점이 있습니다. 만약에 mergeOtherZoo 메서드 내부 코드가 반대로 인자로 받은 동물원에 기존 동물원을 합치는 경우면 어떻게 될까요?타입 미스매치가 발생하게 됩니다. out 을 사용한 시점에서 인자로 받는 zoo 는 자신을 인자로 필요로 한 클래스의 서브 타입일 수 있기 때문에 하위타입에 상위타입의 데이터를 넣는 동작은 타입 안전성을 해칠 수 있습니다.fun mergeOtherZoo(zoo: Zoo&lt;out T&gt;) {    zoo.animals.addAll(this.animals)\t\t}  out 키워드를 이용해서 공변 상태로 전환할 때는 파라미터인  zoo  가 본인의 데이터를 넘겨주는 쪽으로 동작을 처리하면 됩니다.​반공변으로 전환out 을 이용해서 공변 상태로 만들었을 때는 zoo 가 this 의 하위 타입이 되는 것이 가능하므로 zoo 에 this 데이터를 가져가는 동작은 타입 안전성을 해칠 수 있습니다. 이러한 동작을 처리하려면 공변이 아닌 반공변으로 설정하는 것이 좋습니다.반공변은 말 그대로 공변의 반대입니다. 여기서는 서브타입이었던 클래스가 반대로 상위타입이 됩니다. 그래서 공변이었을 때 불가능했던 파라미터 zoo 에 this 의 데이터를 가져가는 동작이 반공변에선 가능합니다.fun mergeOtherZoo(zoo: Zoo&lt;in T&gt;) {    zoo.animals.addAll(this.animals)}  in 키워드를 이용해서 반공변 상태로 전환할 때는 파라미터인 zoo 가 this 의 데이터를 소비하는 쪽으로 동작을 처리하면 됩니다.​변성 선언 위치변성 선언은 파라미터에서 설정하는 것 이외에도 클래스 전체를 설정하는 것도 가능합니다. 만약에 클래스 전체를 공변하게 만들고 싶거나 반공변하게 만들고 싶다면 다음과 같이 클래스 헤더에 설정하면 됩니다. 이렇게 하면 예시로 사용했던 mergeOtherZoo 메서드 파라미터로 Zoo 클래스를 받을 필요가 없어집니다.class Zoo&lt;out T&gt; {}class Zoo&lt;in T&gt; {}// 클래스 자체를 공변 설정하지 않았을 때fun mergeOtherZoo(zoo: Zoo&lt;T&gt;) {    this.animals.addAll(zoo.animals)}// 파라미터로 클래스가 아닌 리스트로 수정fun mergeOtherZoo(zoo: List&lt;T&gt;) {    this.animals.addAll(zoo)}공변 설정만약 클래스를 out (공변) 설정했다면 다음 두 메서드에서 오류가 발생합니다.fun add(animal: T) {    animals.add(animal)}fun mergeOtherZoo(zoo: List&lt;T&gt;) {    this.animals.addAll(zoo)}// Type parameter T is declared as 'out' but occurs in 'in' position in type T다음과 같이 메서드 파라미터에 공변을 설정했을 때를 보면 zoo 가 데이터를 넘겨주는 역할을 해야 한다고 언급했습니다. 그래서 클래스 자체를 공변으로 설정했다면 내부 메서드도 전부 데이터를 넘기는(getter) 동작으로 설정해야 합니다. 그래서 getLast() getFirst() 는 별다른 오류가 없는 겁니다.fun mergeOtherZoo(zoo: Zoo&lt;out T&gt;) {    zoo.animals.addAll(this.animals)\t\t}반공변 설정이번엔 클래스를 in (반공변) 설정했다면 다음 두 메서드에서 오류가 발생합니다.fun getLast(): T {    return animals.last()}fun getFirst(): T {    return animals.first()}// Type parameter T is declared as 'in' but occurs in 'out' position in type T이번엔 공변으로 설정했을 때와 달리 getter 역할을 수행하는 메서드에서 오류가 발생했습니다. 메서드 파라미터에 in 반공변을 설정했을 때를 보면 zoo 가 데이터를 넘기는 것이 아닌 오히려 데이터를 받는 입장인 것을 알 수 있습니다. 그래서 이때는 클래스 내 메서드는 데이터를 받는 쪽으로 처리하면 됩니다.fun mergeOtherZoo(zoo: Zoo&lt;in T&gt;) {    zoo.animals.addAll(this.animals)}​강제 변성위의 예시를 보면 알 수 있듯이, 제네릭은 타입 안전성을 굉장히 신경을 씁니다. 그래서 in 혹은 out 으로 했을 때 안전성을 해칠 수 있는 타입 파라미터를 오류 메세지를 보여주는 것으로 막습니다. 그런데 이를 무시하고 강제로 설정을 해야 하는 경우가 있을 수 있습니다.그래서 코틀린은 @UnsafeVariance 라는 어노테이션을 제공합니다. 타입 파라미터에 붙여서 사용하면 변성 설정으로 인해 발생할 수 있는 위험성을 감수하고 강제로 실행시킬 수 있습니다.만약에 클래스 자체를 out 으로 설정했다면 add mergeOtherZoo 메서드의 타입 파라미터에서 오류가 발생합니다. 이때 이 어노테이션을 사용하면 강제로 실행할 수 있습니다. 물론 런타임에 발생된 오류에 대한 처리는 어노테이션을 설정한 개발자의 몫입니다.fun add(animal: @UnsafeVariance T) {    animals.add(animal)}fun mergeOtherZoo(zoo: List&lt;@UnsafeVariance T&gt;) {    this.animals.addAll(zoo)}​범위 지정타입으로 받을 수 있는 범위 제한지금까지 동물원을 예시로 설명을 드렸습니다. 그런데 다음과 같이 동물이랑 전혀 상관없는 Int 를 타입으로 넘겨도 객체 생성에 문제가 없습니다. 그래서 넘기는 타입 파라미터의 범위를 지정해줘야 합니다.&lt;T: Animal&gt; 이런 식으로 범위를 지정하면 됩니다. 설정하면 Animal  범위 내의 타입들만 넘길 수 있습니다.fun main() {    val zooWithNotAnimal = Zoo&lt;Int&gt;() // 오류 없음}class Zoo&lt;T&gt; {}fun main() {    val zooWithNotAnimal = Zoo&lt;Int&gt;() // Type argument is not within its bounds.}class Zoo&lt;T: Animal&gt; {}​제네릭 클래스뿐만 아니라 제네릭 함수도 있다.예시로 사용한 동물원은 제네릭 클래스입니다. 제네릭 클래스는 클래스 이름 오른쪽에 타입을 지정합니다. 반면에 클래스가 아닌 함수를 제네릭으로 정의할 때는 fun 키워드와 함수 이름 사이에 타입 파라미터를 넣어줘야 합니다.fun List&lt;T&gt;.isNone(): Boolean {    return this.isEmpty()}// 틀린 코드: Unresolved reference: Tfun &lt;T&gt; List&lt;T&gt;.isNone(): Boolean {    return this.isEmpty()}// 맞는 코드: fun 키워드 다음에 타입 파라미터를 적어줘야 함제네릭 함수를 잘만 활용하면 유틸성 함수들을 마구 찍어낼 수 있습니다. 코틀린 자체에서 제공하는 여러 유용한 확장함수들도 제네릭 함수로 정의되어 제공됩니다. 대표적으로 Collection 과 관련된 파일을 보면 유용한 기능의 함수가 제네릭으로 정의되어 있는 것을 알 수 있습니다.​마무리지금까지 예시를 통해서 제네릭을 이용한 클래스와 함수가 어떻게 정의되고 어떤 특징을 가지고 있는지 설명을 해봤습니다. 단순히 하나의 클래스나 함수를 제네릭으로 정의함으로써 코드 재사용성을 높일 수 있고 변성을 통한 타입 안전성도 얻을 수 있다는 것을 알았습니다.설명을 위해 사용된 코드는 단순히 제네릭의 특징을 직관적으로 보여주기 위해서 굉장히 단순하고 허술하게 작성을 했으니 이 점 이해해주시면 감사하겠습니다. 혹시라도 틀린 내용이 있어서 알려주신다면 바로 수정하겠습니다. 감사합니다 :)혹시 괜찮은 코틀린 강의를 찾고 계시다면 하나 추천드리겠습니다. 개인적으로 굉장히 만족하면서 들었던 강의입니다.인프런 - 코틀린 고급편​참조Wikipedia 변성인프런 - 코틀린 고급편"
  },
  
  {
    "title": "Android BuildConfig 적용 안되는 현상",
    "url": "/posts/Android-BuildConfig/",
    "categories": "Android, 이슈",
    "tags": "Android, BuildConfig",
    "date": "2023-11-01 12:00:00 +0900",
    





    
    "snippet": "빌드를 다시 해봐도 BuildConfig 가 없음BuildConfig 는 보통 노출되면 안되는 값을 저장할 때 사용되곤 합니다. 그래서 프로젝트를 몇번 해봤다면 해당 기능을 사용해봤을 겁니다. 보통 서버 주소나 API 키와 같은 중요한 값들을 로컬 프로퍼티에 저장을 하고 재빌드를 해서 BuildConfig 를 참조하게 됩니다. 그런데 재빌드를 했음에도...",
    "content": "빌드를 다시 해봐도 BuildConfig 가 없음BuildConfig 는 보통 노출되면 안되는 값을 저장할 때 사용되곤 합니다. 그래서 프로젝트를 몇번 해봤다면 해당 기능을 사용해봤을 겁니다. 보통 서버 주소나 API 키와 같은 중요한 값들을 로컬 프로퍼티에 저장을 하고 재빌드를 해서 BuildConfig 를 참조하게 됩니다. 그런데 재빌드를 했음에도 불구하고 BuildConfig 가 참조되지 않는 경우가 있었을 겁니다.AGP 8.0 부터 BuildConfig 는 기본으로 적용되지 않음빌드 퍼포먼스 향상을 위해서 그래들 플러그인 8.0 버전부터는 BuildConfig 생성이 되지 않도록 변경됐습니다.Android 공식문서 내용 발췌  Starting with AGP 8.0, the default values for these flags have changed to improve build performance. To get help adjusting your code to support some of these changes, use the AGP Upgrade Assistant (Tools &gt; AGP Upgrade Assistant). The Upgrade Assistant guides you through updating your code to accommodate the new behavior or setting flags to preserve the previous behavior.            Flag      New default value      Previous default value      Notes                  android.defaults.buildfeatures.buildconfig      false      true      AGP 8.0 doesn’t generate BuildConfig by default. You need to specify this option using the DSL in the projects where you need it.      Medium : Android Developers 내용 발췌  If you call the BuildConfig class from your module code, you need to enable buildConfig in the android {} block in your module’s build.gradle.kts file. Otherwise, the BuildConfig file isn’t automatically generated anymore.​BuildConfig 사용을 명시해야 사용 가능따라서 그래들 플러그인 버전이 8.0 이상이라면 해당 기능을 사용하기 위해서 그래들 파일에 직접 명시를 해줘야 합니다. ViewBinding DataBinding 을 사용하기 위해서 그래들 파일에 명시해주는 거랑 똑같다고 보시면 됩니다.// Module build.gradle.ktsandroid {  buildFeatures {    buildConfig = true  }}​참조Android 공식문서Medium : Android Developers"
  },
  
  {
    "title": "Android 구글 로그인 구현하기",
    "url": "/posts/Android-Google-Login/",
    "categories": "Android, 라이브러리",
    "tags": "Android, 소셜 로그인, 구글, Google Login",
    "date": "2023-10-31 22:00:00 +0900",
    





    
    "snippet": "사전 준비안드로이드에서 구글 로그인을 구현하기 위해서는 준비해야 될 게 몇 가지가 있습니다. 구글 클라우드에 들어가서 OAuth 클라이언트 아이디를 만들고 그 과정에서 본인의 앱을 등록해야 합니다. 그러므로 구체적으로 무엇을 먼저 준비해야 하는지 알아보겠습니다.  파이어베이스에 앱을 등록해서 관리하는 것까지 할 예정이니 파이어베이스 과정이 필요없다면 ...",
    "content": "사전 준비안드로이드에서 구글 로그인을 구현하기 위해서는 준비해야 될 게 몇 가지가 있습니다. 구글 클라우드에 들어가서 OAuth 클라이언트 아이디를 만들고 그 과정에서 본인의 앱을 등록해야 합니다. 그러므로 구체적으로 무엇을 먼저 준비해야 하는지 알아보겠습니다.  파이어베이스에 앱을 등록해서 관리하는 것까지 할 예정이니 파이어베이스 과정이 필요없다면 해당 부분은 스킵하세요!​1. 구글 클라우드에서 클라이언트 아이디 생성      구글 클라우드에 들어가서 오른쪽 상단의 콘솔 을 클릭합니다.        API 및 서비스로 들어갑니다. (만약 프로젝트가 없다면 새 프로젝트부터 만들고 시작)        왼쪽에 메뉴가 다섯 가지가 존재하는데 거기서 사용자 인증 정보를 클릭합니다.        + 사용자 인증 정보 만들기 를 눌러서 OAuth 클라이언트 ID 를 클릭해서 아이디를 생성합니다. 여기서 애플리케이션 유형을 선택할 수 있는데 웹 애플리케이션, Android 이 두 개를 각각 만들어야 합니다.      ​2. SHA-1 값 찾기웹 애플리케이션 유형은 그냥 생성하면 되므로 Android 유형 만드는 방법을 중점으로 알아보겠습니다. 여기서는 중요한 게 패키지 이름과 SHA-1 인증서 디지털 지문 입니다. 패키지 이름은 본인 프로젝트의 패키지 이름을 그대로 적으면 됩니다.인증서 디지털 지문은 그래들 태스크를 이용해서 찾을 수 있습니다. 그래들 태스크는 다음과 같이 두 가지 방법으로 실행할 수 있습니다. 태스크를 실행시켰다면 gradle signingreport 를 입력해서 실행시키면 됩니다. 그러면 터미널 창에서 SHA1 을 확인할 수 있습니다.      안드로이드 스튜디오 오른쪽 메뉴를 클릭한 다음, 터미널 아이콘을 클릭해서 그래들 태스크를 실행합니다.    안드로이드 스튜디오 오른쪽 상단의 검색 아이콘을 눌러 Gradle Task 를 검색해서 그래들 태스크를 실행합니다.  \t​파이어베이스에 앱 등록하기파이어베이스에 가서 프로젝트를 새로 만드시고 프로젝트에 들어가서 앱 추가를 해주세요. 당연히 안드로이드로 해주시면 됩니다. 그러면 구글 클라이언트 아이디 생성할 때와 똑같이 패키지 이름과 SHA-1 값을 요구할 겁니다. 동일하게 작성하고 완료하면 됩니다. 다 만들면 google-services.json 파일을 다운받을 수 있을텐데 이거를 프로젝트 폴더 내 app 에 붙여넣기 해주세요.​의존성 추가그래들 앱 수준 -  Module:app 에서 추가해야 하는 의존성 및 플러그인입니다.plugins {    id(\"com.google.gms.google-services\") // &lt;- 추가}dependencies {    implementation(platform(\"com.google.firebase:firebase-bom:32.3.1\"))    implementation(\"com.google.firebase:firebase-auth-ktx\")    implementation(\"com.google.android.gms:play-services-auth:20.7.0\")}그래들 프로젝트 수준 - Project:{본인 프로젝트명} 에서 추가해야 하는 플러그인입니다.plugins {    id(\"com.google.gms.google-services\") version \"4.4.0\" apply false // &lt;- 추가}​구글 아이디 토큰 발급하기이제 코드를 작성할 단계입니다. 파이어베이스에 로그인 유저 관리를 하기 위해서는 먼저 구글 아이디 토큰이란 것을 받아와야 합니다. 아이디 토큰을 이용해서 파이어베이스에 연결하기 때문에 이 작업을 먼저 처리해야 합니다.      GoogleSignInOptions 을 생성합니다. 저는 아이디 토큰 요청, 이메일 요청만 추가했지만 다른 옵션이 더 필요하다면 추가하면 됩니다. 여기서 requestIdToken 에 넘기는 인자가 웹 클라이언트 유형으로 만들었던 클라이언트 아이디 값입니다.    private val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)    .requestIdToken(BuildConfig.GOOGLE_CLIENT_ID)    .requestEmail()    .build()            GoogleSignInClient 을 생성합니다.    val googleSignInClient = GoogleSignIn.getClient(this, gso)            사용자가 구글 로그인을 요청했을 때 결과를 처리하는 코드를 작성    val googleLogInRequest =    registerForActivityResult(ActivityResultContracts.StartActivityForResult()) {        if (it.resultCode == RESULT_OK) {            val task = GoogleSignIn.getSignedInAccountFromIntent(it.data)            try {                val account = task.getResult(ApiException::class.java)                account?.let { user -&gt;                    user.idToken?.let { idToken -&gt;                        Timber.d(\"Get Account idToken! : ${account.idToken}\")                    }                }            } catch (e: ApiException) {                Timber.d(e)            }        }    }            사용자가 구글 로그인 버튼을 클릭했을 때 이벤트를 처리하는 코드 작성    _binding.btnRequestGoogleLogin.setOnClickListener {    googleLogInRequest.launch(googleSignInClient.signInIntent)}      ​파이어베이스에 연결하기아이디 토큰을 받았다면 이제 해당 토큰을 가지고 파이어베이스에 연결을 해야 합니다. 그러기 위해서 먼저 파이어베이스 auth 를 생성합니다.class MainActivity : AppCompatActivity() {    private lateinit var auth: FirebaseAuth    override fun onCreate(savedInstanceState: Bundle?) {\t\t\t\t// ...        auth = Firebase.auth    }}그리고 아이디 토큰을 가지고 파이어베이스에 연결을 시도합니다.private fun handleGoogleIdToken(idToken: String) {    val firebaseCredential = GoogleAuthProvider.getCredential(idToken, null)    auth.signInWithCredential(firebaseCredential)        .addOnCompleteListener(this) {            if(it.isSuccessful) {                // 정상 완료            }        }}​정리지금까지 구글 로그인 연결을 위해 필요한 과정들을 알아봤습니다. 최종적으로 구한 아이디 토큰이나 파이어베이스 auth 가 가지고 있는 값들을 프로젝트에 연결된 서버에 전송하여 유저 등록을 하게 됩니다. 지금까지의 코드를 간단하게 정리한 예시를 끝으로 마치겠습니다. 감사합니다.class MainActivity : AppCompatActivity() {    private val viewModel: GoogleLoginViewModel by viewModel()    private lateinit var _binding: ActivityMainBinding    private lateinit var auth: FirebaseAuth    private val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)        .requestIdToken(BuildConfig.GOOGLE_CLIENT_ID)        .requestEmail()        .build()    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        _binding = DataBindingUtil.setContentView(this, R.layout.activity_main)        setContentView(_binding.root)        _binding.vm = viewModel        auth = Firebase.auth        val googleSignInClient = GoogleSignIn.getClient(this, gso)        val googleLogInRequest =            registerForActivityResult(ActivityResultContracts.StartActivityForResult()) {                if (it.resultCode == RESULT_OK) {                    val task = GoogleSignIn.getSignedInAccountFromIntent(it.data)                    try {                        val account = task.getResult(ApiException::class.java)                        account?.let { user -&gt;                            user.idToken?.let { idToken -&gt;                                Timber.d(\"Get Account idToken! : ${account.idToken}\")                                handleLoginResponse()                                viewModel.googleLoginByToken(idToken)                            }                        }                    } catch (e: ApiException) {                        Timber.d(e)                    }                }            }        _binding.btnRequestGoogleLogin.setOnClickListener {            googleLogInRequest.launch(googleSignInClient.signInIntent)        }        _binding.btnRequestGoogleSignOut.setOnClickListener {            googleSignInClient.signOut().addOnCompleteListener {                if(it.isComplete) {                    viewModel.googleSignOut()                    toast(\"Complete sign out!\")                }                else { toast(\"Failure sign out!\") }            }        }    }    private fun handleLoginResponse() {        viewModel.account.observe(this) { _binding.accountInfo = it }    }    private fun handleGoogleIdToken(idToken: String) {        val firebaseCredential = GoogleAuthProvider.getCredential(idToken, null)        auth.signInWithCredential(firebaseCredential)            .addOnCompleteListener(this) {                if(it.isSuccessful) {                    // 정상 완료                }            }    }}​참조Android용 로그인Android에서 Google로 인증"
  },
  
  {
    "title": "(프로그래머스 | Kotlin) - 카드 짝 맞추기",
    "url": "/posts/KotlinAlgorithm5/",
    "categories": "CS, 알고리즘 문제",
    "tags": "Kotlin, Algorithm, 알고리즘, 프로그래머스",
    "date": "2023-10-28 22:00:00 +0900",
    





    
    "snippet": "해결 방법이 문제의 핵심은 그냥 구현, 또 구현, 그리고 또 구현이다. 막 엄청 수준이 높은 알고리즘을 요구하는 것이 아닌 기본적인 알고리즘 여러 개를 가지고 복잡한 구현을 요구한다. 그래서 이 문제를 풀면서 굉장한 피로감을 느꼈다… 나같은 경우에는 백트래킹, 너비 우선 탐색, 그리디 이 세 가지를 중심으로 구현을 진행했다. 해당 알고리즘을 사용한 이...",
    "content": "해결 방법이 문제의 핵심은 그냥 구현, 또 구현, 그리고 또 구현이다. 막 엄청 수준이 높은 알고리즘을 요구하는 것이 아닌 기본적인 알고리즘 여러 개를 가지고 복잡한 구현을 요구한다. 그래서 이 문제를 풀면서 굉장한 피로감을 느꼈다… 나같은 경우에는 백트래킹, 너비 우선 탐색, 그리디 이 세 가지를 중심으로 구현을 진행했다. 해당 알고리즘을 사용한 이유는 다음과 같다.1. 최소 탐색을 위해서는 가능한 뒤집는 순서 조합을 모두 구해서 계산해야 한다.만약 보드판 위에 1 2 3 이렇게 세 종류의 카드가 존재한다면 가능한 뒤집는 순서의 갯수는 6가지다. 이 6가지 순서쌍에서 최소 탐색을 할 수 있는 순서쌍이 존재하기 때문에 모든 순서쌍을 계산해서 최소값을 찾는 방식으로 진행한다.  1 -&gt; 2 -&gt; 3  1 -&gt; 3 -&gt; 2  2 -&gt; 1 -&gt; 3  2 -&gt; 3 -&gt; 1  3 -&gt; 1 -&gt; 2  3 -&gt; 2 -&gt; 1  private fun setPermutation(p: ArrayList&lt;Int&gt;, isVisited: Array&lt;Boolean&gt;) {      if(p.size == image.size) {          permutation.add(p.toIntArray())          return      }      image.forEach { imageCode -&gt;          if(!isVisited[imageCode]) {              isVisited[imageCode] = true              p.add(imageCode)              setPermutation(p, isVisited)              p.removeLast()              isVisited[imageCode] = false          }      }  }2. 같은 종류의 카드가 2개씩 있는데 이 2개의 뒤집는 순서도 고려해야 한다.카드가 1 2 3 이렇게 있으면 한 개씩 세 장을 의미하는 게 아니라 실제로는 각 종류별로 2개씩 총 6장의 카드가 보드판에 존재한다. 따라서 각 종류별로 2장을 어떤 순서로 뒤집을 건지도 고려해야 한다. 이 부분은 예를 들어서 특정  n번 카드 두 장을 각각 a b 라고 가정하자. 그럼 a -&gt; b b -&gt; a 이렇게 두 가지 경우에서 더 작은 이동값을 가지는 경우를 택한다.  private fun getMinimumMove(cursor: Pair&lt;Int,Int&gt;, target: Int, board:  Array&lt;IntArray&gt;): Point {      val a = position[target][0]      val b =  position[target][1]      val moveFromAtoB = bfs(cursor, a, board) + bfs(a, b, board) + 2      val moveFromBtoA = bfs(cursor, b, board) + bfs(b, a, board) + 2      return when(min(moveFromAtoB, moveFromBtoA)) {          moveFromAtoB -&gt; Point(b.first, b.second, moveFromAtoB)          else -&gt; Point(a.first, a.second, moveFromBtoA)      }  }3. 보드판 위에서 특정 위치의 카드를 찾는 방법은 BFS를 이용한다.카드를 뒤집기 위해서는 현재 위치에 있는 커서가 카드가 있는 곳으로 최소의 움직임으로 이동해야 한다. 따라서 이를 위해 BFS를 이용하여 구현했다. 대충 함수 헤더가 어떤지 설명하자면 fun bfs(curr: Pair&lt;Int,Int&gt;, target: Pair&lt;Int,Int&gt;) 이런 느낌이다.private fun bfs(cursor: Pair&lt;Int,Int&gt;, target: Pair&lt;Int,Int&gt;, board:  Array&lt;IntArray&gt;): Int {    val q = ArrayDeque&lt;Point&gt;()    val col = listOf(0,1,0,-1)    val row = listOf(1,0,-1,0)    val isVisited = Array(4) { Array(4) {false} }    q.add(Point(cursor.first, cursor.second, 0))    isVisited[cursor.first][cursor.second] = true    while(!q.isEmpty()) {        val curr = q.first()        q.removeFirst()        if(curr.x == target.first &amp;&amp; curr.y == target.second) {            return curr.cnt        }        for(i in 0..3) {            val nextCol = curr.x+ col[i]            val nextRow = curr.y + row[i]            if(-1 &lt; nextCol &amp;&amp; nextCol &lt; 4 &amp;&amp; -1 &lt; nextRow &amp;&amp; nextRow &lt; 4 &amp;&amp; !isVisited[nextCol][nextRow]) {                q.add(Point(nextCol, nextRow, curr.cnt+1))                isVisited[nextCol][nextRow] = true            }        }        for(i in 0..3) {            var nextCol = curr.x            var nextRow = curr.y            while(true) {                nextCol += col[i]                nextRow += row[i]                if(3 &lt; nextCol || nextCol &lt; 0 || 3 &lt; nextRow || nextRow &lt; 0) {                    nextCol -= col[i]                    nextRow -= row[i]                    break                }                if(board[nextCol][nextRow] &gt; 0) { break }            }            if(isVisited[nextCol][nextRow]) { continue }            q.add(Point(nextCol, nextRow, curr.cnt+1))            isVisited[nextCol][nextRow] = true        }    }    return 0}설명순서 1.백트래킹을 이용해서 순열을 구한다. 중복 순열이 필요한 것은 아니므로 방문한 번호에 대해서는 재방문을 허용하지 않도록 isVisited 와 같은 논리형 변수를 만들어서 처리한다. 순열이 한쌍 완성될 때마다 만들어둔 permutation 배열에 저장한다.순서 2.n 번 카드 2장(a b )이 있고 a -&gt; b b -&gt; a  를 각각 구해야 한다. 이를 bfs 로 구하려면 a -&gt; b 를 현재 커서 -&gt; a  a -&gt; b 이렇게 나눠서 계산해야 하고 b -&gt; a 도 마찬가지다. 그리고 두 장의 카드에 도달했을 때 뒤집는 행동도 카운트해야 하니까 a 뒤집을 때 한 번, b 뒤집을 때 한 번 해서 총 2를 더하는 것도 잊지 말아야 한다. 이렇게 계산을 끝내고 값이 더 적은 결과값을 반환하면 된다.순서 3.보통 bfs 문제들은 동, 서, 남, 북 이렇게 네 방향으로 한 칸씩 움직이면서 목표 지점을 향한다. 그런데 이 문제는 컨트롤을 누른채로 움직이는 것도 있어서 이것도 추가로 고려를 해줘야 한다. 따라서 해당 부분에 대한 로직도 같이 작성한다.for(i in 0..3) {    var nextCol = curr.x    var nextRow = curr.y    while(true) {        nextCol += col[i]        nextRow += row[i]        if(3 &lt; nextCol || nextCol &lt; 0 || 3 &lt; nextRow || nextRow &lt; 0) {            nextCol -= col[i]            nextRow -= row[i]            break        }        if(board[nextCol][nextRow] &gt; 0) { break }    }    if(isVisited[nextCol][nextRow]) { continue }    q.add(Point(nextCol, nextRow, curr.cnt+1))    isVisited[nextCol][nextRow] = true}전체 코드class Solution {    private val position = Array(7) { arrayListOf&lt;Pair&lt;Int,Int&gt;&gt;() }    private val permutation = ArrayList&lt;IntArray&gt;()    private val image = arrayListOf&lt;Int&gt;()    fun solution(board: Array&lt;IntArray&gt;, r: Int, c: Int): Int {        board.forEachIndexed { i, l -&gt;            l.forEachIndexed { j, value -&gt;                if (value != 0 &amp;&amp; position[value].size == 0) { image.add(value) }                position[value].add(Pair(i, j))            }        }        var answer: Int = 4*4*2*image.size        setPermutation(arrayListOf(), Array(7){false})        permutation.forEach { l -&gt;            var cursor = Pair(r,c)            var sum = 0            val tmpBoard = Array(4) { IntArray(4) }            for(i in 0..3) { for(j in 0..3) { tmpBoard[i][j] = board[i][j] } }            l.forEachIndexed { i, imageCode -&gt;                val result =  getMinimumMove(cursor, l[i], tmpBoard)                sum += result.cnt                cursor = Pair(result.x, result.y)                tmpBoard[position[imageCode][0].first][position[imageCode][0].second] = 0                tmpBoard[position[imageCode][1].first][position[imageCode][1].second] = 0            }            answer = min(answer, sum)        }        return answer    }    private fun getMinimumMove(cursor: Pair&lt;Int,Int&gt;, target: Int, board:  Array&lt;IntArray&gt;): Point {        val a = position[target][0]        val b =  position[target][1]        val moveFromAtoB = bfs(cursor, a, board) + bfs(a, b, board) + 2        val moveFromBtoA = bfs(cursor, b, board) + bfs(b, a, board) + 2        return when(min(moveFromAtoB, moveFromBtoA)) {            moveFromAtoB -&gt; Point(b.first, b.second, moveFromAtoB)            else -&gt; Point(a.first, a.second, moveFromBtoA)        }    }    private fun bfs(cursor: Pair&lt;Int,Int&gt;, target: Pair&lt;Int,Int&gt;, board:  Array&lt;IntArray&gt;): Int {        val q = ArrayDeque&lt;Point&gt;()        val col = listOf(0,1,0,-1)        val row = listOf(1,0,-1,0)        val isVisited = Array(4) { Array(4) {false} }        q.add(Point(cursor.first, cursor.second, 0))        isVisited[cursor.first][cursor.second] = true        while(!q.isEmpty()) {            val curr = q.first()            q.removeFirst()            if(curr.x == target.first &amp;&amp; curr.y == target.second) {                return curr.cnt            }            for(i in 0..3) {                val nextCol = curr.x+ col[i]                val nextRow = curr.y + row[i]                if(-1 &lt; nextCol &amp;&amp; nextCol &lt; 4 &amp;&amp; -1 &lt; nextRow &amp;&amp; nextRow &lt; 4 &amp;&amp; !isVisited[nextCol][nextRow]) {                    q.add(Point(nextCol, nextRow, curr.cnt+1))                    isVisited[nextCol][nextRow] = true                }            }            for(i in 0..3) {                var nextCol = curr.x                var nextRow = curr.y                while(true) {                    nextCol += col[i]                    nextRow += row[i]                    if(3 &lt; nextCol || nextCol &lt; 0 || 3 &lt; nextRow || nextRow &lt; 0) {                        nextCol -= col[i]                        nextRow -= row[i]                        break                    }                    if(board[nextCol][nextRow] &gt; 0) { break }                }                if(isVisited[nextCol][nextRow]) { continue }                q.add(Point(nextCol, nextRow, curr.cnt+1))                isVisited[nextCol][nextRow] = true            }        }        return 0    }    private fun setPermutation(p: ArrayList&lt;Int&gt;, isVisited: Array&lt;Boolean&gt;) {        if(p.size == image.size) {            permutation.add(p.toIntArray())            return        }        image.forEach { imageCode -&gt;            if(!isVisited[imageCode]) {                isVisited[imageCode] = true                p.add(imageCode)                setPermutation(p, isVisited)                p.removeLast()                isVisited[imageCode] = false            }        }    }    data class Point(        val x: Int,        val y: Int,        val cnt: Int    )}"
  },
  
  {
    "title": "(프로그래머스 | C++) - 숫자 블록",
    "url": "/posts/KotlinAlgorithm4/",
    "categories": "CS, 알고리즘 문제",
    "tags": "Kotlin, Algorithm, 알고리즘, 프로그래머스",
    "date": "2023-10-16 20:00:00 +0900",
    





    
    "snippet": "해결 방법이 문제의 핵심은 가장 큰 약수를 구하는 데 있다.  문제에서 블록의 번호가 n 이고 해당 블록은 n*2 n*3 … 이렇게 설치를 한다. 이것은 곧 약수가 됨을 의미한다. 예를 들어서 구간 10 에 설치될 블록의 번호 무엇일까? 바로  5 다. 왜 이렇게 나오는 것일까? 구간이 가지고 있는 약수들 중에서 본인을 제외한 가장 큰 숫자가 설치될 ...",
    "content": "해결 방법이 문제의 핵심은 가장 큰 약수를 구하는 데 있다.  문제에서 블록의 번호가 n 이고 해당 블록은 n*2 n*3 … 이렇게 설치를 한다. 이것은 곧 약수가 됨을 의미한다. 예를 들어서 구간 10 에 설치될 블록의 번호 무엇일까? 바로  5 다. 왜 이렇게 나오는 것일까? 구간이 가지고 있는 약수들 중에서 본인을 제외한 가장 큰 숫자가 설치될 블록 번호이기 때문이다.10 의 약수는 1, 2, 5, 10 인데 약수 1 부터 살펴보면 1*10 = 10 인 것을 알 수 있고 n=1 로 표현이 가능하다. 그래서 처음에는 구간 10 에 1 블록이 설치된다.  그 다음 블록 번호는 2 다. 마찬가지로 2*5=10 인 것을 알 수 있고 n=2 로 표현이 가능하다. 따라서 이미 설치된 1 블록에 2 블록을 덮어씌운다. 그 다음 블록 번호 3 4 는 특정 숫자를 곱해서 10 을 만들 수 없으므로 패스한다. 이런 방식으로 진행을 하면 5 가 5*2=10 이므로 구간 10 에 마지막으로 설치되는 블록 번호는 5 임을 알 수 있다. 결국 구간이 가진 본인 제외, 가장 큰 약수가 해당 구간에 설치될 블록의 번호다.      특정 숫자에 대해서 가장 큰 약수를 반환하는 메서드를 정의한다.    int GetMostDivisor(int num) {    if(num == 1) return 0;    vector&lt;int&gt; divisor(1, 1);           for(int i=2; i&lt;=sqrt(num); i++) {        if(num%i == 0) {            if(num/i &lt;= MAX_BLOCK_NUM) return num/i;            divisor.push_back(i);        }       }    return divisor.back();}            begin ~ end 범위의 반복문을 통해 본인 제외 가장 큰 약수를 저장한다.    for(int i=begin; i&lt;end+1; i++) {    answer[i-begin] = GetMostDivisor(i);}      설명순서 1.가장 큰 약수를 구하려면 가장 작은 수부터 나눠서 확인하면 된다. 이때 문제 조건인 블록 최대값 10,000,000 이 넘어가지 않는다면 해당 결과값이 된다. 아니라면 따로 약수 후보들을 배열에 저장해놓고 반복문이 끝나면 해당 배열에서 최대값을 리턴하면 된다.순서 2.각 구간의 시작과 끝을 반복문으로 돌면서 answer 에 저장하면 간단하게 끝난다.전체 코드#include &lt;string&gt;#include &lt;vector&gt;#include &lt;math.h&gt;#include &lt;iostream&gt;using namespace std;const int MAX_BLOCK_NUM = 10000000;int GetMostDivisor(int num) {    if(num == 1) return 0;    vector&lt;int&gt; divisor(1, 1);        for(int i=2; i&lt;=sqrt(num); i++) {        if(num%i == 0) {            if(num/i &lt;= MAX_BLOCK_NUM) return num/i;            divisor.push_back(i);        }       }    return divisor.back();}vector&lt;int&gt; solution(long long begin, long long end) {    vector&lt;int&gt; answer(end-begin+1, 0);        for(int i=begin; i&lt;end+1; i++) {        answer[i-begin] = GetMostDivisor(i);    }    return answer;}"
  },
  
  {
    "title": "(프로그래머스 | Kotlin) - 이모티콘 할인행사",
    "url": "/posts/KotlinAlgorithm3/",
    "categories": "CS, 알고리즘 문제",
    "tags": "Kotlin, Algorithm, 알고리즘, 프로그래머스",
    "date": "2023-10-11 20:00:00 +0900",
    





    
    "snippet": "해결방법이 문제의 핵심은 emoticons 배열에 담겨 있는 이모티콘들의 할인율을 배정하는 것이다. 각 이모티콘은 각각 10, 20, 30, 40 퍼센트로 네 가지 할인율을 가질 수 있다. 따라서 각 이모티콘은 네 가지 중에서 하나의 할인율을 가진다. emoticons 의 최대 길이가 7 이므로 나올 수 있는 이모티콘들의 할인율의 경우의 수는 최대 4...",
    "content": "해결방법이 문제의 핵심은 emoticons 배열에 담겨 있는 이모티콘들의 할인율을 배정하는 것이다. 각 이모티콘은 각각 10, 20, 30, 40 퍼센트로 네 가지 할인율을 가질 수 있다. 따라서 각 이모티콘은 네 가지 중에서 하나의 할인율을 가진다. emoticons 의 최대 길이가 7 이므로 나올 수 있는 이모티콘들의 할인율의 경우의 수는 최대 4^7 개다.나올 수 있는 최대 경우의 수가 4의 7승이라면 모든 경우를 탐색해도 지장이 없는 크기다. 따라서 완전 탐색을 통해 문제에서 요구하는 최대 효율을 가진 경우의 수(최대 효율을 내는 할인율 조합)를 찾을 수 있다. 완전 탐색을 위해서 모든 경우의 수를 구해야 하므로 백트래킹을 이용하여 나올 수 있는 모든 할인율 조합을 배열에 저장한다.모든 할인율 조합을 구했다면 하나씩 꺼내서 users 를 통해 결과값을 도출해본다. 결과값은 문제 조건대로 이모티콘 구독자 수가 많은 게 우선이고 그 다음은 이모티콘 판매액이다. 따라서 현재 계산 시점에서 나온 결과값과 이전에 계산했던 결과값 중에서 최대 효율을 내는 값과 비교하여 둘 중에 더 좋은 효율을 가진 결과값으로 업데이트하는 방식으로 해결한다. 해결 순서는 다음과 같다.      주어진 이모티콘 배열의 사이즈에 맞는 구할 수 있는 모든 할인율 조합을 구한다.    max 는 주어진 이모티콘 배열의 사이즈를 의미한다.    private fun setRatePermutation(count: Int){    if(count == max){        ratePermutation.add(tempPermutation.copyOf().toIntArray())        return    }    for(i in rate.indices){        tempPermutation[count] = rate[i]        setRatePermutation(count + 1)    }}        main 함수에서 먼저 할인율 조합을 저장한다.    this.max = emoticons.sizesetRatePermutation(0)            할인율 조합을 반복문으로 돌려 각 할인율 조합에 대한 users 배열을 계산해서 result 를 갱신한다.    for(p in ratePermutation) {    var selling = 0    var subscriberCounter = 0    for(user in users) {        var boughtSum = 0        for((i,price) in emoticons.withIndex()) {            if(p[i] &gt;= user[0]) {                boughtSum += ((100-p[i])*0.01*price).toInt()            }        }        if(boughtSum &gt;= user[1]) { subscriberCounter++ }        else{ selling += boughtSum }    }    if(answer[0] &lt; subscriberCounter || (answer[0]==subscriberCounter) &amp;&amp; answer[1] &lt; selling) {        answer[0] = subscriberCounter        answer[1] = selling    }}      설명순서 1.백트래킹을 이용한다. 여기서 할인율은 각 이모티콘마다 서로 다른 값으로 배정돼야 하는 것이 아니므로 중복값을 허용하도록 설계해야 한다. 이모티콘이 4개 있으면 할인율이  10, 20, 30, 40 일수도 있고, 10, 10, 10, 10 일수도 있다. 이렇게 구한 경우의 수가 최대(emoticons 사이즈가 7일 때) 약 16000 ~ 17000개다. 굉장히 값이 작아서 충분히 완전 탐색할 수 있는 크기다.순서 2.users 배열에 대한 계산은 그냥 문제에서 하라는 것만 하면 문제없이 결과값을 구할 수 있다. 결과값이 나왔다면 현재 최대값(1. 최대한 많은 이모티콘 구독자 수 2. 높은 판매액)과 비교해서 최대값을 갱신하면 된다. 최대값을 새로 갱신해야 하는 경우는 다음과 같다.      결과값([이모티콘 구독자 수, 이모티콘 판매액])의 이모티콘 구독자 수가 현재 최대값의 이모티콘 구독자 수보다 많을 경우    이모티콘 구독자 수가 결과값과 현재 최대값이 서로 같은데 판매액의 결과값이 더 많은 경우  전체 코드class Solution {    private var max = 7    private val tempPermutation = Array(max) {0}    private val ratePermutation = ArrayList&lt;IntArray&gt;()    private val rate = listOf(10, 20, 30, 40)    fun solution(users: Array&lt;IntArray&gt;, emoticons: IntArray): IntArray {        val answer = Array(2) {0}        this.max = emoticons.size        setRatePermutation(0)        for(p in ratePermutation) {            var selling = 0            var subscriberCounter = 0            for(user in users) {                var boughtSum = 0                for((i,price) in emoticons.withIndex()) {                    if(p[i] &gt;= user[0]) {                        boughtSum += ((100-p[i])*0.01*price).toInt()                    }                }                if(boughtSum &gt;= user[1]) { subscriberCounter++ }                else{ selling += boughtSum }            }            if(answer[0] &lt; subscriberCounter || (answer[0]==subscriberCounter) &amp;&amp; answer[1] &lt; selling) {                answer[0] = subscriberCounter                answer[1] = selling            }        }        return answer.toIntArray()    }        private fun setRatePermutation(count: Int){        if(count == max){            ratePermutation.add(tempPermutation.copyOf().toIntArray())            return        }        for(i in rate.indices){            tempPermutation[count] = rate[i]            setRatePermutation(count + 1)        }    }}"
  },
  
  {
    "title": "(프로그래머스 | Kotlin) - 억억단을 외우자",
    "url": "/posts/KotlinAlgorithm2/",
    "categories": "CS, 알고리즘 문제",
    "tags": "Kotlin, Algorithm, 알고리즘, 프로그래머스",
    "date": "2023-10-10 16:00:00 +0900",
    





    
    "snippet": "해결 방법이 문제의 핵심은 약수의 개수를 구하는 데 있다.  특정 숫자의 약수 개수를 알아야 등장 빈도를 알 수 있기 때문이다. 예를 들어서 숫자 4 를 예시로 들어보겠다. 억억단 예시 사진을 보면 해당 숫자가 세 번 등장하는데 그 이유가 구구단, 1단부터 e 단까지를 행렬로 표현해서 1X4 4X1 2X2 이렇게 나오기 때문이다.그럼 여기서 대충 약수...",
    "content": "해결 방법이 문제의 핵심은 약수의 개수를 구하는 데 있다.  특정 숫자의 약수 개수를 알아야 등장 빈도를 알 수 있기 때문이다. 예를 들어서 숫자 4 를 예시로 들어보겠다. 억억단 예시 사진을 보면 해당 숫자가 세 번 등장하는데 그 이유가 구구단, 1단부터 e 단까지를 행렬로 표현해서 1X4 4X1 2X2 이렇게 나오기 때문이다.그럼 여기서 대충 약수와 관련이 있다는 것을 눈치챌 수 있다. 4 의 약수는 총 세 개, 1, 2, 4 이다. 가운데를 기준으로 특정 위치에 있는 숫자는 자신의 반대쪽에 있는 숫자와 곱을 하면 4 가 된다. 그래서 원래는 4 가 두 개가 나오는 것이 맞지만 억억단은 행과 열 둘 다 구구단이 존재하기 때문에 동일 숫자 곱(2X2)을 제외하고 각각 2배를 해줘야 한다. 따라서  1, 4 는 1X4 4X1 이렇게 두 가지가 된다.이런 특징을 이용해서 숫자  e 까지의 등장 빈도를 배열에 저장하고 이 배열을 이용해 result 를 구하면 되는데 문제는 등장 빈도를 구하는 속도가 빨라야 한다. 나같은 경우에는 처음에  제곱근을 이용한 약수 개수를 구하는 알고리즘을 이용해서 시도했었는데 시간 초과가 됐었다. 그래서 배수를 이용한 약수 개수 구하는 알고리즘으로 변경하여 제출했더니 통과가 됐다. 따라서 이 문제는 약수 개수를 구하는 알고리즘만 잘 짜면 그 뒤는 무난하게 풀 수 있다. 해결 순서는 다음과 같다.      e 까지 각 숫자의 등장 빈도를 배열에 저장한다.    for (i in 1..e) {    for (j in 1..e / i) {        counter[i*j]++    }}            starts 배열 내 원소들을 하나씩 방문하여 result 를 구한다.    getResult 는 i ~ j 사이에서 빈도가 가장 높은 수와 빈도 값을 배열에 담아 리턴하는 메서드이다.    private fun getResult(i: Int, j: Int, counter: Array&lt;Int&gt;): IntArray {    var maxCnt = 0    var numOfMaxCnt = 0    for(num in i .. j) {        if(counter[num] &gt; maxCnt) {            maxCnt = counter[num]            numOfMaxCnt = num        }    }    return intArrayOf(numOfMaxCnt, maxCnt)}        var prev = getResult(sortedStarts.last()[0], e, counter)answer[sortedStarts.last()[1]] = prev[0]   for(i in sortedStarts.lastIndex-1 downTo 0) {    val curr = getResult(sortedStarts[i][0], sortedStarts[i + 1][0], counter)    answer[sortedStarts[i][1]] = if (curr[1] &gt;= prev[1]) curr[0] else prev[0]       if(curr[1] &gt; prev[1]) {        answer[sortedStarts[i][1]] = curr[0]        prev = curr    }    else if(curr[1] == prev[1]) {        answer[sortedStarts[i][1]] = min(curr[0], prev[0])        prev = if(curr[0] &lt; prev[0]) curr else prev    }    else {        answer[sortedStarts[i][1]] = prev[0]    }}answer.toIntArray()        설명    순서 1.    이 부분은 위에서 설명했듯이 배수를 이용한 약수 개수 구하는 알고리즘을 사용해서 e 까지 빈도를 배열에 저장하면 된다.    순서 2.    이 부분은 풀이 방법이 사람마다 다를 수 있는데 나같은 경우에는 starts 를 정렬해놓고 내림차순으로 각 원소의 result 를 구하는 방법을 사용했다. 예를 들어서 문제 예시에서 준 starts 는 [1, 3, 7] 인데 이를 먼저 정렬한다. (근데 이미 정렬이 되어 있으므로 패스) 그리고  e 는 8 이다.    이제 starts 를 내림차순으로 반복문을 돌려서 7~8 -&gt; 3~8 -&gt; 1~8 이런 식으로 result 를 구한다. 그런데 7~8 을 먼저 계산을 하면 3~8 을 계산할 때 3~7 까지만 계산하면 된다. 7~8 부분은 이미 앞서 계산을 끝마쳤기 때문이다. 서로 두 결과값을 비교해서 빈도가 더 많은쪽을 설정해주면 된다. 만약 빈도가 서로 같다면 문제에서 내건 조건대로 숫자가 더 작은쪽을 설정해주면 된다. 이런 방식으로 계산을 하면은 마지막인 1~8 계산은 1~3 까지만 계산하고 앞서 계산한 3~8 값과 비교해서 값을 업데이트하면 된다.    전체 코드    import kotlin.math.*   class Solution {    fun solution(e: Int, starts: IntArray): IntArray {        val answer = Array(starts.size) {0}        val counter = Array(e+1) {0}        val sortedStarts = Array(starts.size) { Array(2) {0} }              for((i, num) in starts.withIndex()) {            sortedStarts[i][0] = num            sortedStarts[i][1] = i        }        sortedStarts.sortBy {it[0]}                   for (i in 1..e) {            for (j in 1..e / i) {                counter[i*j]++            }        }           return if(starts.size &lt; 2) {            intArrayOf(getResult(starts[0], e, counter)[0])        } else {            var prev = getResult(sortedStarts.last()[0], e, counter)            answer[sortedStarts.last()[1]] = prev[0]                           for(i in sortedStarts.lastIndex-1 downTo 0) {                val curr = getResult(sortedStarts[i][0], sortedStarts[i + 1][0], counter)                answer[sortedStarts[i][1]] = if (curr[1] &gt;= prev[1]) curr[0] else prev[0]                   if(curr[1] &gt; prev[1]) {                    answer[sortedStarts[i][1]] = curr[0]                    prev = curr                }                else if(curr[1] == prev[1]) {                    answer[sortedStarts[i][1]] = min(curr[0], prev[0])                    prev = if(curr[0] &lt; prev[0]) curr else prev                }                else {                    answer[sortedStarts[i][1]] = prev[0]                }            }            answer.toIntArray()        }       }       private fun getResult(i: Int, j: Int, counter: Array&lt;Int&gt;): IntArray {        var maxCnt = 0        var numOfMaxCnt = 0        for(num in i .. j) {            if(counter[num] &gt; maxCnt) {                maxCnt = counter[num]                numOfMaxCnt = num            }        }        return intArrayOf(numOfMaxCnt, maxCnt)    }}      "
  },
  
  {
    "title": "(프로그래머스 | Kotlin) - 요격 시스템",
    "url": "/posts/KotlinAlgorithm1/",
    "categories": "CS, 알고리즘 문제",
    "tags": "Kotlin, Algorithm, 알고리즘, 프로그래머스",
    "date": "2023-10-09 22:00:00 +0900",
    





    
    "snippet": "해결 방법문제를 해석하면 특정 구간이 여러 개 주어지고 그 구간들을 전부 관통할 수 있는 최소의 폭격 미사일 수를 구해야 한다. 문제에서 그리디 알고리즘 문제를 좀 풀어봤다면 예시로 던져준 사진을 보자마자 그리디 문제임을 알아챘을 것이다. 따라서 이 문제는 그리디 알고리즘을 이용해서 해결하면 된다. 해결 순서는 다음과 같다.      targets 내...",
    "content": "해결 방법문제를 해석하면 특정 구간이 여러 개 주어지고 그 구간들을 전부 관통할 수 있는 최소의 폭격 미사일 수를 구해야 한다. 문제에서 그리디 알고리즘 문제를 좀 풀어봤다면 예시로 던져준 사진을 보자마자 그리디 문제임을 알아챘을 것이다. 따라서 이 문제는 그리디 알고리즘을 이용해서 해결하면 된다. 해결 순서는 다음과 같다.      targets 내 특정 구간 i 에 대해서 targets[i][1] 을 기준으로 정렬한다.        첫 폭격 미사일 설치 위치를 targets[0][1] 로 설정한다.    var lastSpot = targets[0][1]            반복문을 통해 정렬된 targets 내의 모든 원소들을 차례로 돌면서 현재 원소의 시작 위치가 lastSpot 위치보다 같거나 크다면 해당 원소의 끝 위치가 다음 폭격 미사일의 설치 위치가 된다.    for(i in targets.indices) {    if(targets[i][0] &gt;= lastSpot) {        lastSpot = targets[i][1]        answer++    }}            3번 반복문 내의 조건문이 충족될 때마다 answer (설치해야 할 폭격 미사일 갯수) 를 증가시킨다.  설명순서 1.모든 원소는 시작과 끝 값을 가지고 있다. 여기서 끝 값을 기준으로 오름차순 정렬을 해주면 특정 원소 인덱스 i  다음부터 모든 원소들의 끝 값은 i 번째 원소의 끝 값보다 무조건 같거나 크다. 그래서 i+1 부터 끝 원소까지 차례로 탐색하면서 시작 위치 값이 i 위치의 끝 값보다 같거나 큰 원소가 나오면 해당 원소의 끝에 폭격 미사일을 설치하면 된다.순서 2.끝 좌표 기준으로 정렬된 상태라면 폭격 미사일을 특정 원소의 끝 좌표를 겨냥해서 설치하는 것이 최대한 많은 원소들을 관통할 확률을 높여준다. 문제 예시 사진처럼 직접 정렬된 형태로 그려놓고 시작 위치에 폭격 미사일을 설치하는 것과 끝 위치에 폭격 미사일 설치하는 것을 비교하면 무슨 말인지 이해할 수 있다.순서 3.문제 조건에서 조심해야 할 점은 시작, 혹은 끝 위치는 폭격이 불가능하다는 것이다. 그래서 특정 원소 i 의 끝 위치가 , i+1  의 시작 위치와 같다고 해도 i  끝 위치에 설치해서 하나로 두 개를 터트릴 수 없다는 뜻이다.그래서 2번에 설명한 끝 위치라는 것은 실제로 끝 값을 의미하는 것이 아닌 최대한 끝 값에 가까운 값으로 가정해서 코드를 작성한다. 배열은 끝 값이 저장되지만 머릿속으로는 끝 값에 가까운 값이라고 생각하면서 문제를 풀면 된다. 이런 이유로 반복문 내 조건문은 현재 원소의 시작 위치가 마지막으로 설치된 폭격 미사일 위치와 같아도 미사일을 새로 설치해야 한다.전체 코드class Solution {    fun solution(targets: Array&lt;IntArray&gt;): Int {        targets.sortBy {it[1]}        var answer= 1        var lastSpot = targets[0][1]        for(i in targets.indices) {            if(targets[i][0] &gt;= lastSpot) {                lastSpot = targets[i][1]                answer++            }        }        return answer    }}"
  },
  
  {
    "title": "Android Navigation에 대해서 알아보자",
    "url": "/posts/Android-Navigation/",
    "categories": "Android, 라이브러리",
    "tags": "Android, UI, 레이아웃, 네비게이션, JetPack",
    "date": "2023-05-05 00:00:00 +0900",
    





    
    "snippet": "Jetpack에서 제공하는 Navigation내비게이션(Navigation)은 안드로이드 Jetpack에서 제공하는 라이브러리 중 하나입니다. 내비게이션은 말 그대로 탐색을 지원하는 라이브러리며 기존의 방식보다 화면 전환을 쉽고 빠르고 유연하게 도와줍니다. 아마 안드로이드 앱 개발을 시작한 지 얼마 안 됐다면 꼭 알아야 하는 라이브러리 중 하나이지 않...",
    "content": "Jetpack에서 제공하는 Navigation내비게이션(Navigation)은 안드로이드 Jetpack에서 제공하는 라이브러리 중 하나입니다. 내비게이션은 말 그대로 탐색을 지원하는 라이브러리며 기존의 방식보다 화면 전환을 쉽고 빠르고 유연하게 도와줍니다. 아마 안드로이드 앱 개발을 시작한 지 얼마 안 됐다면 꼭 알아야 하는 라이브러리 중 하나이지 않을까 싶습니다. 그래서 이번 포스팅은 내비게이션 라이브러리가 무엇이고 왜 사용하며 어떻게 사용하는지 알아보겠습니다.​기존의 화면 전환 방식안드로이드에서 UI를 제공할 수 있는 창은 Activity 와 이에 종속되어서 부분 UI를 나타내는 Fragment 입니다. 그래서 안드로이드 앱 내에서 화면 전환이라 하면 보통 다음과 같이 세 가지가 있습니다.  Activity to Activity  Fragment to Fragment  Activity to Fragment액티비티와 액티비티 사이의 전환은 Intent 객체를 이용해서 구현합니다. 그리고 프래그먼트로의 이동은 fragmentManager 를 이용해서 beginTransaction 을 통해 구현하게 됩니다. 앱 프로젝트 규모가 작다면 상관없지만 규모가 큰 프로젝트라면 사용해야 될 화면도 많아질 것이고 복잡한 화면 전환 구성을 가지게 될 가능성이 높습니다.화면만 전환하면 끝일까요? 화면 전환에 데이터를 담아서 전송할 수도 있고 화면 전환 애니메이션도 적용할 수도 있습니다. 따라서 화면 전환은 많은 작업을 필요로 합니다.​그래서 하나로 합쳐드렸습니다~그래서 구글은 화면 전환에 필요한 라이브러리, 툴, 플러그인 등을 하나로 합쳐서 Navigation이라는 라이브러리를 만들었습니다. 기존에 인텐트 혹은 프래그먼트 매니저를 통한 화면 전환에서 내비게이션 XML 공간에서 쉽게 탐색구조를 구축하는 방식으로 전환된 것입니다.아래 사진과 같이 내비게이션 XML에서 기존에 가지고 있는 프래그먼트나 액티비티를 추가해서 원하는 탐색구조를 마우스로 연결해 주기만 하면 화살표가 생성되어 화면 전환 구조에 대한 직관적인 파악이 가능해집니다.​쉽고 깔끔한 프래그먼트로의 전환내비게이션 라이브러리를 사용했을 때 얻을 수 있는 장점은 프래그먼트 전환이 굉장히 쉬워집니다. 설명드린 대로 현재 생성한 프래그먼트들을 다 추가해서 연결하기만 하면 생성된 id 를 통해서 전환을 할 수 있는데 이 전환을 요청하는 코드도 굉장히 짧고 간단합니다.  그래서 이 라이브러리를 사용하면 프래그먼트를 실컷 생성해서 복잡한 탐색구조를 구축할 수 있습니다.​Single Activity이러한 장점 때문에 구글에서는 프래그먼트 전환 관리가 쉬운 네비게이션을 통해 단일 액티비티 구조를 권장합니다. 액티비티를 하나만 생성하고 나머지는 전부 프래그먼트로 채우라는 소리입니다. 단일 액티비티 구조를 주장하는 이유는 다음과 같습니다.  Activity 는 Fragment 에 비해 덩치가 큰 객체라 메모리, 속도 면에서 불리하다.  Fragment 는 Activity 에 비해 비교적 쉬운 데이터 공유, 유연한 UI 구축의 장점을 가지고 있다.​Navigation 대표 구성요소 세 가지Navigation Graph탐색구조를 구축할 수 있는 XML 리소스 파일입니다. 여기서 화면 전환, 애니메이션 등을 세팅할 수 있습니다.NavHost여러 프래그먼트를 담을 수 있는 하나의  컨테이너입니다. 이 컨테이너에서 여러 프래그먼트의 전환이 일어나게 됩니다.  탐색구조를 여러 개의 그룹으로 쪼개고 싶다면 NavHost 를 여러 개 만들어서 구축할 수도 있습니다.NavController각각의 NavHost 는 하나의  NavController 를 가지고 있습니다. 이 친구는 앱 내의 탐색을 관리하여 A에서 B로 전환해야 되는 상황이 발생하면 이를 인식하고 화면 전환을 수행합니다.findNavController().navigate(R.id.action)세 가지를 종합해보면?Navigation Graph를 통해서 탐색구조를 정의를 하여 전환이 필요할 때 NavController 에게 요청을 합니다. 그럼 컨트롤러는 이를 수행하고 NavHost 는 이를 인식하여 기존 프래그먼트에서 알맞은 프래그먼트로 교체하여 화면에 표시합니다.​Navigation 사용 방법0. Dependency 설정dependencies {  // 글 작성 기준으로 2.5.3 버전입니다.  def nav_version = \"2.5.3\"  implementation \"androidx.navigation:navigation-fragment-ktx:$nav_version\"  implementation \"androidx.navigation:navigation-ui-ktx:$nav_version\"}​1. 프래그먼트를 보여줄 NavHost 지정하기지금부터 설명드리는 예시는 액티비티에 여러 프래그먼트를 띄우는 방식입니다. 따라서 저는 액티비티 레이아웃 XML에 FragmentContainer를 만들어서 이 친구를 NavHost 로 지정하겠습니다. android:name  을 호스트 프래그먼트로 지정해 주고 app:navGraph 는 뒤에 그래프를 만들면 그때 추가해 주세요.&lt;androidx.fragment.app.FragmentContainerView    android:id=\"@+id/fcv_main\"    android:name=\"androidx.navigation.fragment.NavHostFragment\"    android:layout_width=\"0dp\"    android:layout_height=\"0dp\"    app:defaultNavHost=\"true\"    app:layout_constraintBottom_toTopOf=\"@id/bnv_main\"    app:layout_constraintEnd_toEndOf=\"parent\"    app:layout_constraintStart_toStartOf=\"parent\"    app:layout_constraintTop_toTopOf=\"parent\"    app:navGraph=\"@navigation/nav_main\" /&gt;​2. Navigation Graph 정의안드로이드 res 폴더 내에 New 를 통해  Android Resource Directory 를 누르시면 navigation 디렉토리를 따로 만들 수 있습니다. 생성하고 그 안에 리소스 파일을 새로 생성해 주세요. 생성했다면 밑의 예시처럼 필요한 액티비티나 프래그먼트를 불러서 마우스로 연결해 주세요.​3. navController를 통해 화면 전환 요청 코드 작성하기그래프를 다 만들었다면 Split을 통해서 XML 코드도 확인해 보세요. 그러면 &lt;fragment&gt;  태그로 감싸진 코드가 굉장히 많아진 것을 볼 수 있습니다. 그중에서 하나만 보겠습니다. 해당 프래그먼트는 연결 지점이 한 곳입니다. 이는 &lt;action&gt;에 정의되어 있습니다. 만약에 연결한 프래그먼트가 세 곳이면 &lt;action&gt; 은 세 개가 됩니다.    &lt;fragment        android:id=\"@+id/nav_my_page\"        android:name=\"com.example.travelfeeldog.presentation.mypage.MyPageFragment\"        android:label=\"fragment_my_page\"        tools:layout=\"@layout/fragment_my_page\" &gt;        &lt;action            android:id=\"@+id/action_nav_my_page_to_myReviewFragment\"            app:destination=\"@id/myReviewFragment\"            app:enterAnim=\"@anim/nav_default_enter_anim\"            app:exitAnim=\"@anim/nav_default_exit_anim\"            app:popEnterAnim=\"@anim/nav_default_pop_enter_anim\"            app:popExitAnim=\"@anim/nav_default_pop_exit_anim\" /&gt;    &lt;/fragment&gt;연결한 프래그먼트로 이동을 위해서 액션 아이디인 android:id 를 통해서 요청하면 됩니다.binding.clReviewArea.setOnClickListener{    findNavController().navigate(R.id.action_nav_my_page_to_myReviewFragment)}​BottomNavigationView 연동내비게이션은 바텀 내비게이션 뷰와 연결이 가능합니다. 방법은 다음과 같습니다.1. 필요한 메뉴 구성res  에서 menu  디렉토리(없으면 생성)에 바텀 내비게이션 전용 메뉴 XML 을 생성합니다. 생성했으면 해당 파일에 필요한 메뉴를 정의합니다. 저는 홈, 검색, 마이 페이지가 필요하므로 세 개를 만들었습니다.&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;    &lt;item android:id=\"@+id/nav_home\"        android:title=\"@string/navigation_home\"        android:icon=\"@drawable/ic_home\"/&gt;    &lt;item android:id=\"@+id/nav_search\"        android:title=\"@string/navigation_search\"        android:icon=\"@drawable/ic_search\"/&gt;    &lt;item android:id=\"@+id/nav_my_page\"        android:title=\"@string/navigation_my_page\"        android:icon=\"@drawable/ic_my_page\"/&gt;&lt;/menu&gt;  메뉴 아이템 태그의 아이디, 네비게이션 그래프에 정의한 프래그먼트 태그의 아이디는 동일해야 한다.​2. BottomNavigationView 생성액티비티 레이아웃 XML에 바텀 내비게이션 뷰를 생성합니다. 생성했으면 속성으로 app:menu 를 추가하여 만든 메뉴 파일을 연결합니다.&lt;com.google.android.material.bottomnavigation.BottomNavigationView    android:id=\"@+id/bnv_main\"    android:layout_width=\"0dp\"    android:layout_height=\"wrap_content\"    android:background=\"@color/white\"    android:paddingTop=\"6dp\"    app:itemIconTint=\"@color/selector_bottom_nav_color\"    app:itemRippleColor=\"@null\"    app:itemTextAppearanceActive=\"@style/Widget.BottomNavigationView.Active\"    app:itemTextAppearanceInactive=\"@style/Widget.BottomNavigationView.InActive\"    app:itemTextColor=\"@color/selector_bottom_nav_color\"    app:labelVisibilityMode=\"labeled\"    app:layout_constraintBottom_toBottomOf=\"parent\"    app:layout_constraintEnd_toEndOf=\"parent\"    app:layout_constraintStart_toStartOf=\"parent\"    app:layout_constraintTop_toBottomOf=\"@id/fcv_main\"    app:menu=\"@menu/menu_bottom\" /&gt;​3. BottomNavigationView 호스트에 NavController 연결마무리로 바텀 내비게이션 뷰를 가지고 있는 액티비티에 컨트롤러를 연결해야 합니다. 해당 코드는 호스트가 되는 액티비티에서 일부를 가져왔습니다.override fun onCreate(savedInstanceState: Bundle?) {    super.onCreate(savedInstanceState)    setContentView(binding.root)    binding.bnvMain.setupWithNavController(findNavController())}private fun findNavController(): NavController {    val navHostFragment =        supportFragmentManager.findFragmentById(R.id.fcv_main) as NavHostFragment    return navHostFragment.navController}​마무리안 중요한 라이브러리는 없지만 내비게이션 라이브러리는그중에서도 유용하고 정말 중요한 것 같습니다. 제가 첫 안드로이드 프로젝트를 했을 때 내비게이션의 존재를 모르고 수작업으로 전환 코드를 작성해서 엄청 고생했던 기억이 있습니다. 처음 시작하는 분들은 저처럼 삽질하지 말고 내비게이션으로 편한 프로젝트 되시길 바랍니다 :)참조Android 공식 문서 - NavigationAndroid 공식 문서 - Navigation 시작하기"
  },
  
  {
    "title": "Android의 UI, 뷰(View) 그리고 레이아웃(ViewGroup)",
    "url": "/posts/Android-UI/",
    "categories": "Android, 기본",
    "tags": "Android, UI, 레이아웃, 뷰",
    "date": "2023-04-06 12:00:00 +0900",
    





    
    "snippet": "모바일 UI는 어떻게 구성되어 있는가?예시로 우리가 스마트폰을 이용해서 배달의민족 앱을 이용할 때를 생각해 봅시다. 해당 앱에 접속을 해보면 여러 카테고리 버튼이 있고 밑으로 스크롤을 하면 여러 음식점들의 간략한 정보가 리스트 형식, 혹은 카드 형태로 제공됩니다.특정 음식점을 클릭하면 해당 음식점에 대한 상세 페이지로 이동하게 되고 여기서는 가게에 대...",
    "content": "모바일 UI는 어떻게 구성되어 있는가?예시로 우리가 스마트폰을 이용해서 배달의민족 앱을 이용할 때를 생각해 봅시다. 해당 앱에 접속을 해보면 여러 카테고리 버튼이 있고 밑으로 스크롤을 하면 여러 음식점들의 간략한 정보가 리스트 형식, 혹은 카드 형태로 제공됩니다.특정 음식점을 클릭하면 해당 음식점에 대한 상세 페이지로 이동하게 되고 여기서는 가게에 대한 텍스트 정보, 음식 사진에 대한 이미지 정보, 메뉴들을 선택할 수 있는 체크박스, 해당 가게 정보를 저장할 수 있는 찜 버튼과 같은 다양한 상호작용 요소들을 볼 수 있습니다.  이렇듯 모바일 UI는 하나의 화면 안에 사용자와 상호작용이 가능한 다양한 요소들이 존재합니다.​Android는 UI를 어떻게 제작하는가?그렇다면 Android는 이러한 모바일 UI를 어떤 방식으로 구현할까요? 가장 먼저 사용자에게 앱과 상호작용할 수 있는 화면으로 안내하는 것이 우선입니다.상호작용을 위한 화면안드로이드는 사용자가 앱과 상호작용할 수 있도록 진입점을 제공하는데 이것이 Activity 입니다. 액티비티는 안드로이드 앱을 구성하는 4대 구성 요소 중에 하나이며 사용자에게 UI를 제공하여 상호작용을 하기 위한 진입점입니다. 안드로이드 앱 내에 여러 화면을 구성할 수 있는 것도 액티비티가 있기 때문입니다.화면 내에 존재하는 여러 상호작용 요소들사용자가 Activity 에 도달했다면 이제는 그곳에 배치된 여러 요소들을 통해서 본격적으로 상호작용을 할 수 있게 됩니다. 이 요소들은 뷰(View) 와 뷰그룹(ViewGroup) 이라는 것들의 계층 구조로 이루어져 있습니다. 배달의민족을 통해 음식점 상세 페이지에 갔을 때 볼 수 있는 텍스트, 이미지, 체크박스, 이미지 버튼 등의 요소들을 뷰(View) 라고 하고 이런 여러 뷰들을 담는 컨테이너를 뷰그룹(ViewGroup) 이라고 합니다.​뷰(View)안드로이드는 사용자와 상호작용할 수 있는 요소 제작과 배치를 위해서 View 객체를 제공합니다. 뷰는 사용자 인터페이스의 기본적인 구성 요소이며 그리기 및 이벤트 처리를 담당합니다. 뷰를 다른 말로 위젯이라고도 합니다.뷰 객체는 여러 속성과 메서드를 가지고 있습니다. 대표적으로  draw() 라는 메서드가 있는데 이를 통해서 화면에 뷰를 그릴 수 있습니다. 이벤트 처리 같은 경우에는 대표적인 예시로 클릭에 대한 이벤트가 있는데 사용자가 뷰를 클릭하면 이를 감지하여 어떤 동작을 처리할 수 있게 지원합니다.여러 뷰들은 View 객체로부터 파생된 것(View Hierarchy)뷰 객체가 가지고 있는 속성과 메서드의 상속을 통해서 특정 기능을 가진 뷰로 확장시키는 방식으로 다양한 뷰들을 만들 수 있는데 안드로이드에서 기본적으로 제공하는 뷰들이 이에 해당됩니다. 따라서  많이 사용되는  TextView, Button, ImageView 등의 뷰들은 전부 View 객체에서 파생된 뷰입니다.기본 제공되는 뷰들을 사용해서 UI 구성을 진행하고 만약에 기본적으로 제공되는 뷰의 기능이 부족하다면 직접 뷰 객체를 커스텀 해서 만들어야 합니다. 이를 커스텀 뷰라고 하는데 이 부분은 나중에 따로 포스팅해보겠습니다.뷰의 상속 관계(View Hierarchy)​​뷰그룹(ViewGroup)ViewGroup 은 상속 관계도에서 확인할 수 있듯이  View 를 상속받은 객체입니다. 뷰그룹은 다른 말로  레이아웃이라고 하는데 여러 View 들을 담을 수 있고 이런 여러 뷰들의 배치를 도와줍니다. 뷰그룹은 여러 뷰도 담을 수 있지만 다른 뷰그룹도 담을 수 있습니다. 그래서 중첩으로 레이아웃을 만들어 좀 더 복잡한 배치를 할 수 있습니다. 레이아웃의 종류는 크게 6개로 볼 수 있습니다.LinearLayout  뷰를 일렬로 배치하는 레이아웃      배치 방식을 위한 orientation 속성을 제공                  orientation = vertical : 세로로 배치                            orientation = horizontal : 가로로 배치                    ​RelativeLayout  뷰의 상대적인 위치에 따라 배치하는 레이아웃      상대적인 위치 설정을 위한 속성들을 제공 RelativeLayout.LayoutParams        속성 몇 가지 예시          layout_alignParentTop      layout_centerVertical      layout_below      layout_toRightOf            배치 예시      ​FrameLayout  뷰를 중첩해서 배치하는 레이아웃      visibility  속성을 이용해서 상황에 따라 특정 뷰만 보이게 하고 나머지 뷰는 보이지 않게 설정        배치 예시      ​TableLayout  행과 열을 통해 표 형태로 뷰를 배치하는 레이아웃      TableRow  를 이용해 한 행을 생성하고 이 안에 여러 뷰들을 만들어서 열을 채우는 방식으로 배치        TableRow 내에는 View 혹은 ViewGroup  를 넣을 수 있음        배치 예시      ​GridLayout  격자 배치 레이아웃      TableLayout 와 마찬가지로 행과 열을 이용해 배치, 하지만 그리드레이아웃이 더 유연한 배치가 가능        행과 열에 대한 속성을 제공해서 유연한 배치 가능        배치 예시      ​ContraintLayout  제약 조건을 통한 배치 레이아웃      부모 레이아웃을 기반으로 배치하는 것이 아닌 동일한 뷰를 기반으로 유연한 배치가 가능        뷰와 뷰그룹의 계층 구조로 이루어진 Android의 UI 에서 제약레이아웃을 통해 플랫한 계층 구조 설계가 가능        사용 가능한 제약 조건들          Relative positioning      Margins      Centering positioning      Circular positioning      Visibility behavior      Dimension constraints      Chains      Virtual Helpers objects      Optimizer            배치 예시      ​Android의 UI는 뷰와 뷰그룹의 계층 구조지금까지의 이야기를 종합해 보면 사용자와 상호작용을 위한 기본적인 구성 요소인 뷰들을 레이아웃에 담아서 배치하는 식으로 UI를 제작합니다. UI가 단순하다면 단순히 하나의 레이아웃 안에 여러 뷰들을 넣어서 배치할 것이고 UI가 좀 더 복잡하다면 트리 구조처럼 레이아웃 안에 레이아웃을 더 만들어 배치할 것입니다.따라서 안드로이드의 UI는 뷰와 뷰그룹의 계층 구조로 이루어져 있습니다. 레이아웃 XML 파일을 들여다보면 루트에 레이아웃이 있고 그 안에 뷰나 레이아웃을 만드는 식의 계층 구조 형태로 제작하게 돼있습니다.​계층 구조 레이아웃의 최적화트리 구조를 생각해보자.트리 구조의 깊이가 증가할수록 어떤 단점이 발생할까요? 노드 탐색이 느려질 수 있다는 단점이 생깁니다. 만약에 찾고 싶은 노드가 가장 밑단에 위치해 있다면 트리의 깊이가 깊을수록 탐색 시간도 늘어나게 됩니다.트리를 이용한  Union-Find도 탐색 시간 최적화를 위해서 모든 자식 노드의 부모 노드를 루트 노드로 설정해서 깊이를 최소로 줄이는 방법을 사용합니다.Android UI 계층 구초는 가능한 한 얕게 유지해야 한다.뷰와 뷰그룹의 계층 구조의 안드로이드 UI도 가능하면 깊이를 얕게 유지해야 합니다. 중첩 레이아웃이 레이아웃 계층 구조의 깊이를 증가시키는 원인이므로 되도록이면 중첩 레이아웃을 사용하지 않고 배치하는 노력을 하는 것이 좋습니다. 얕게 유지하면 유지할수록 레이아웃이 더 빠르게 화면에 그려지게 됩니다.  가로로 넓은 뷰 계층 구조가 세로로 깊은 뷰 계층 구조보다 낫습니다.ConstraintLayout을 주로 사용하는 이유ConstraintLayout 은 이것만으로 다른 대부분의 레이아웃들의 배치 특성을 구현할 수 있고 뷰에 대한 포지셔닝이 굉장히 유연해서 가로로 넓은 뷰 계층 구조를 만들 수 있습니다. 그래서 저는 제약레이아웃을 주로 사용하고 있습니다.​마무리결국에는 여러 뷰와 뷰그룹을 통해서 UI를 구상하고 완성된 레이아웃 XML 파일은 Activity 에 연결되어 사용자에게 제공됩니다. 그래서 액티비티에서 뷰를 참조하여 특정한 UI 처리를 할 수 있습니다. 요즘에는 XML 방식이 아닌 최신 UI 제작 도구인 Jetpack compose를 도입하려는 움직임이 많습니다. 저도 나중에 기회가 되면 꼭 배워보려고 합니다.마지막으로 혹시나 틀린 부분이 있다면 댓글로 남겨주세요. 바로 수정하도록 하겠습니다. 긴 글 읽어주셔서 감사하고 이 글을 읽는 여러분 모두 좋은 하루 보내시길 바랍니다!​참조안드로이드 공식문서 - 레이아웃안드로이드 공식문서 - 성능 및 뷰 계층 구조찰스의 안드로이드"
  },
  
  {
    "title": "Union-Find 유니온 파인드",
    "url": "/posts/Uinon-Find/",
    "categories": "CS, 알고리즘",
    "tags": "알고리즘, 자료구조, 유니온 파인드",
    "date": "2023-02-21 12:00:00 +0900",
    





    
    "snippet": "서로소 집합(disjoint-set)을 관리하는 자료 구조다양한 원소들이 서로소 집합을 이루는 경우가 있습니다. 필요에 따라서 이 집합들을 이용하여 서로 합치거나 특정 원소를 통해 특정 집합을 탐색할 수도 있습니다. 유니온 파인드(union-find)는 그래프 알고리즘으로 서로소 집합을 관리하며 서로 다른 두 노드가 동일한 집합에 있는지 판별합니다.유...",
    "content": "서로소 집합(disjoint-set)을 관리하는 자료 구조다양한 원소들이 서로소 집합을 이루는 경우가 있습니다. 필요에 따라서 이 집합들을 이용하여 서로 합치거나 특정 원소를 통해 특정 집합을 탐색할 수도 있습니다. 유니온 파인드(union-find)는 그래프 알고리즘으로 서로소 집합을 관리하며 서로 다른 두 노드가 동일한 집합에 있는지 판별합니다.유니온 파인드는 서로 다른 두 노드가 같은 집합에 있는지 판별하기 위해서 각 집합의 대표 원소를 참고합니다. 여기서 대표 원소라 함은 연결 리스트에서는 헤드가 되며 트리에서는 루트 노드가 해당됩니다. 두 노드가 속한 집합의 대표 원소를 찾아서 대표 원소가 서로 동일하면 같은 집합에 있는 걸로 판단하게 됩니다. 이러한 판단 과정에서 여러 집합들이 합쳐지거나(Union) 특정 원소가 속한 대표 원소를 찾기 위해 집합 탐색(Find) 을 진행하기도 합니다. 그래서 유니온 파인드에서는 다음과 같은 연산들이 존재합니다.​연산의 종류            연산      특징                  MakeSet      특정 한 원소만 존재하는 집합을 만든다.              Union      두 개의 집합을 하나의 집합으로 합친다.              Find      특정 원소가 속한 집합의 대표 원소를 반환한다.      ​구현과 관리를 위해 사용되는 방법유니온 파인드를 관리하는 방식은 두 가지가 있습니다. 첫 번째는 연결 리스트를 통한 관리고 두 번째는 트리 구조를 이용한 관리입니다. 각 방식들이 유니온 파인드의 연산을 어떻게 처리하는지 알아보도록 합시다.연결 리스트            연산      방법                  MakeSet      원소 하나만 가지고 노드를 생성한다. 헤드가 해당 집합의 대표 원소다.              Union      한 집합의 헤드 부분이 다른 집합의 꼬리(Tail) 부분을 가리키는 방식으로 연결한다.              Find      지목한 원소의 집합에 존재하는 헤드 원소를 찾아 반환한다.      ​트리 구조            연산      방법                  MakeSet      원소 하나만 가지고 노드를 생성한다. 루트 노드가 해당 집합의 대표 원소다.              Union      한 집합의 루트 노드를 다른 집합의 자식 노드로 연결한다.              Find      특정 원소가 속한 집합의 루트 노드를 찾아 반환한다.      ​연결 리스트를 통한 관리MakeSet​Union​Find​트리 구조를 이용한 관리MakeSet​Union​​​Find​코드로 구현연결 리스트와 트리 구조를 코드로 구현해 보겠습니다. 연결 리스트와 트리 구조의 노드는 구조체나 클래스 등을 통해서 만들 수 있지만 배열로도 구현이 가능합니다.배열의 인덱스가 각 원소의 번호이며 인덱스에 해당하는 값은 해당 인덱스(원소 번호) 가 가리키고 있는 노드의 원소 번호입니다. 따라서 집합 내에서 대표 원소는 최상위에 위치하므로 가리킬 대상이 없고 자기 자신을 가리키게 됩니다. 여기서는 배열의 이름을 parent 라고 하겠습니다. ( 예시로 원소는 8개, 1번 ~ 8번까지 있다고 가정하겠습니다. )MakeSetvoid MakeSet(int X) {  parent[x] = x;}            index      1      2      3      4      5      6      7      8                  parent      1      2      3      4      5      6      7      8      ​Unionvoid Union(int x, int y) {    x = Find(parent[x]);    y = Find(parent[y]);    parent[x] = y;}ex) Union(1, 2)            index      1      2      3      4      5      6      7      8                  parent      2      2      3      4      5      6      7      8      ex) Union(2, 3)            index      1      2      3      4      5      6      7      8                  parent      2      3      3      4      5      6      7      8      ​Findint Find(int x) {    if(parent[x] == x) return x;    return Find(parent[x]);}  재귀 방식을 통해서 루트 노드 혹은 헤드 노드까지 이동해서 해당 원소를 반환합니다.​문제점과 해결 방안 : 연결 리스트 방식지금까지 설명드린 방법은 가장 간단한 방법입니다.  여기서 문제점이 존재합니다. 바로 Find 연산입니다.  연결 리스트와 트리 구조 둘 다 깊이가 커지면 대표 원소를 찾는 시간이 그만큼 오래 걸리게 됩니다. 원소가 n개라면 최악의 경우에는 Find연산이 O(n) 이 됩니다. 연산 시간을 단축시키기 위해서는 어떻게 해야 할까요?각 노드에 헤드를 가리키는 포인터를 추가시킨다.이전에 설명드린 것처럼 연결 리스트는 꼬리(Tail) 부분에서 헤드를 찾게 되면 해당 집합의 모든 원소들을 거치게 됩니다. 운 좋게 원소 2를 지목하면 한 번 이동하고 바로 헤드를 찾게 되지만 그림처럼 꼬리 부분의 원소를 지목하게 될 경우에는 전체를 거쳐서 탐색 시간이 오래 걸리게 됩니다.​그래서 나온 해결책이  모든 노드에 헤드를 가리키는 포인터를 추가하는 것입니다. 그렇게 되면 어느 원소를 지목해도 상수 시간에 바로 헤드에 위치한 원소를 알 수 있습니다.​\t​  하지만 만약 Union을 진행하면 합쳐지는 집합의 모든 원소들이 가리키는 헤드 업데이트가 필요하다.​​​​\t​문제점과 해결 방안 : 트리 구조 방식유니온 바이 랭크(Union by rank)두 집합을 Union 할 때 트리의 깊이가 작은 집합을 트리의 깊이가 큰 집합의 루트 노드에 붙이는 방식입니다. 이러한 방식으로 유니온을 하면 두 트리의 깊이가 동일한 경우에만 깊이가 증가하게 됩니다. 따라서 깊이가 증가하는 것을 최대한 방지해서 Find 연산 시간을 단축시킵니다.​​  만약 유니온 바이 랭크를 적용하지 않는다면 유니온 했을 때 깊이가 증가할 수 있습니다.​​유니온 바이 랭크 구현 function MakeSet(x)     x.parent := x     x.rank   := 0 function Union(x, y)     xRoot := Find(x)     yRoot := Find(y)     // if x and y are already in the same set (i.e., have the same root or representative)     if xRoot == yRoot         return     // x and y are not in same set, so we merge them     if xRoot.rank &lt; yRoot.rank         xRoot.parent := yRoot     else if xRoot.rank &gt; yRoot.rank         yRoot.parent := xRoot     else         yRoot.parent := xRoot         xRoot.rank := xRoot.rank + 1  해당 코드는 wekipedia 서로소 집합 자료 구조에서 참조했음을 알려드립니다.  wekipedia 서로소 집합 자료 구조​경로 압축(path compression)Find(x) 연산은 원소 x 가 속한 집합의 대표 원소를 찾아줍니다. 가장 간단한 방법은 대표 원소를 찾아 반환하고 끝내는 방식이지만 경로 압축에서는 대표 원소를 반환하기 전에 x 를 루트 노드(대표 원소)에 연결하고 대표 원소를 반환합니다. 이렇게 하면 모든 원소들이 대표 원소를 의미하는 루트 노드를 가리키게 됩니다. 이런 방식으로 모든 원소들을 루트 노드(대표 원소)로 연결시키면 연산 시간을 단축시킬 수 있습니다.​​경로 압축 구현 function Find(x)     if x.parent != x        x.parent := Find(x.parent)     return x.parent  해당 코드는 wekipedia 서로소 집합 자료 구조에서 참조했음을 알려드립니다.  wekipedia 서로소 집합 자료 구조​참조wekipedia 서로소 집합 자료 구조신찬수 교수님 : 자료구조 - union-find 자료구조 1/2"
  },
  
  {
    "title": "Android 액티비티 생명주기",
    "url": "/posts/android-lifecycle/",
    "categories": "Android, 기본",
    "tags": "Android, 모바일, 안드로이드, 생명주기, 개발",
    "date": "2023-02-14 00:00:00 +0900",
    





    
    "snippet": "생명주기가 무엇인가?1. 소프트웨어 개발 계획의 시작부터 끝까지 따라야 할 단계와 그것에 따른 계획의 형태 변화.2. 소프트웨어가 만들어져서 폐기될 때까지의 기간.    사용자의 요구에 대한 분석 및 설계, 그리고 프로그램 작성을 거쳐 운용되는 일련의 과정을 포함한다.네이버 국어사전에서 말하는 생명 주기는 다음과 같습니다. 즉, 액티비티가 만들어지고 ...",
    "content": "생명주기가 무엇인가?1. 소프트웨어 개발 계획의 시작부터 끝까지 따라야 할 단계와 그것에 따른 계획의 형태 변화.2. 소프트웨어가 만들어져서 폐기될 때까지의 기간.    사용자의 요구에 대한 분석 및 설계, 그리고 프로그램 작성을 거쳐 운용되는 일련의 과정을 포함한다.네이버 국어사전에서 말하는 생명 주기는 다음과 같습니다. 즉, 액티비티가 만들어지고 없어질 때까지의 과정을 말합니다. 어떤 생명이 탄생해서 죽을 때까지의 과정이 존재하듯  안드로이드의 액티비티도 생성되어 소멸하기까지의 과정을 가지고 있습니다.​생명주기는 왜 있는가?그렇다면 이쯤에서 드는 생각이 있을 겁니다. 그러면 생명주기는 왜 있는 것인가? 이 질문에 대한 해답은 모바일 사용 환경을 생각해 보면 됩니다. 다음과 같은 경우를 생각해 봅시다.  사용자가 앱을 사용하는 도중에 전화가 왔을 때  사용자가 앱에서 나갔다가 돌아왔을 때 이전의 데이터들이 저장되지 않는 문제  세로 모드로 사용하다가 가로로 돌려서 가로 모드로 전환  앱을 사용하는 도중에 홈 화면으로 이동 후, 다른 앱을 실행시킬 때네 가지 경우를 보면 모바일 사용자 환경에서는 많은 상태 변화가 발생한다는 것을 알 수 있습니다. 아마 사용자 입장에서는 위의 상황들이 발생해도 아무런 오류가 없이 매끄럽게 앱이 작동되길 바랄 겁니다.앱이 아무런 오류 없이 매끄럽게 동작하려면 어떻게 해야 할까요? 바로 다양한 상태 변화가 발생했을 때 상태에 따라 알맞은 작업을 하고 적절한 전환을 처리해야 할 것입니다. 그래서 현재 앱이 어떤 상태에 있는지를 계속 파악하는 것이 중요하고 이를 파악하기 위해서 생명주기가 있는 것입니다.​Android의 생명주기생명주기의 시작은 탄생이고 끝은 죽음입니다. 그리고 그 사이에는 다양한 상태들이 존재합니다. 탄생 후에 본격적으로 활동을 위한 준비단계가 있을 것이며 많은 활동 끝에 죽음을 준비하기 위한 단계도 있을 것입니다.안드로이드에서 정의한 액티비티의 생명주기 단계들은 시작과 실행 사이에  onCreate(),  onStart(),  onResume()  순서로 있고 실행과 종료 사이에  onPause(), onStop(), onDestroy() 순으로 여러 상태들이 존재합니다. 따라서 사용자가 앱을 이용하면 그 과정에서 여러 가지의 상태 변화가 발생하는데 이는 생명주기에 따라 적절히 처리됩니다.​생명주기 처리를 위한 콜백 메서드상황에 따라 적절한 처리를 해주려면 생명주기 내에서 해당 상황에 맞는 특정 상태를 알 수 있어야 합니다. 어떤 상태인지를 알아야 그에 맞는 처리를 해줄 수 있으니까요. 안드로이드는 이를 위해 생명주기 내의 다양한 단계들을 콜백 형태로 제공합니다.액티비티 클래스는 onCreate(),  onStart(), onResume() , onPause(), onStop(),onDestroy() 함수들을 상속받습니다. 상속을 받고 이 함수들을 필요에 따라 재정의 하여 특정 상황의 발생으로 인해서 호출이 됐을 때 재정의 한 내용을 토대로 처리를 하게 됩니다. 예를 들어서 가로 모드로 전환을 했을 때는 화면의 구성이 바뀌므로 수명주기의 상태는 onCreate() 에 해당이 되어 시스템에서 onCreate() 콜백을 호출합니다.  이렇게 각 콜백은 상태 변화에 적합한 특정 작업을 실행할 수 있도록 하고 적시에 알맞은 작업과 적절한 전환을 통해 앱이 더욱 안정적으로 기능할 수 있도록 해줍니다.​콜백 메서드 소개지금까지 생명주기가 왜 존재하고 어떻게 처리하는지 알아봤습니다. 콜백 호출을 통해서 상태 변화에 대응한다는 것을 알았으므로 이제는 각 콜백 메서드의 역할과 특징에 대해 알아보겠습니다.onCreate()시스템이 액티비티를 생성할 때 실행되고 필수적으로 구현해야 하는 콜백 메서드입니다. onCreate() 메서드에서는 액티비티의 전체 수명 주기 동안 한 번만 발생해야 하는 기본 애플리케이션 시작 로직을 실행합니다. 예를 들어 데이터 바인딩, ViewModel 연결, 클래스 인스턴스화 등을 onCreate() 에서 처리한다고 보면 되겠습니다. 대표적으로 레이아웃 XML을 액티비티로 불러올 때 setContentView() 함수를 onCreate() 에서 호출합니다.onCreate() 메서드는 savedInstanceState 를 매개변수로 받는데 이는 Bundle 객체입니다. savedInstanceState 는 액티비티의 이전 상태 정보들을 가지고 있습니다. 액티비티가 어떤 이유로 화면을 재구성하게 된다면 기존에 존재하던 값들이 초기화되는 것을 방지할 필요가 있을 수도 있습니다. 그래서 따로 저장을 해두면 나중에 액티비티가 다시 생성될 때 savedInstanceState 를 이용하여 저장했던 값들을 불러올 수 있습니다.마지막으로 onCreate() 가 호출이 완료되면 시스템은 거기서 멈추지 않고 뒤이어 onStart() 와  onResume() 콜백 메서드를 호출합니다.override fun onCreate(savedInstanceState: Bundle?) {    super.onCreate(savedInstanceState)    binding = ActivityMainBinding.inflate(layoutInflater)    val view = binding.root    setContentView(view)}​onStart()액티비티가 사용자에게 표시되고 앱은 액티비티를 포그라운드에 보내서 상호작용을 준비합니다. 액티비티는 사용자에게 표시되지만 아직은 상호작용을 할 수 없는 단계입니다. 상호작용 준비를 위해서 이 단계에서 UI를 관리하는 코드를 초기화합니다.onStart() 는 매우 빠르게 완료되고 onCreate() 때와 마찬가지로 시스템은 여기서 머무르지 않고  onResume()  콜백 메서드를 호출하게 됩니다.​onResume()액티비티가 포그라운드에 표시되고 사용자와 상호작용을 시작합니다. 중간에 전화가 와서 포커스가 전화 알람으로 이동하거나 다른 액티비티로 화면 전환을 하여 포커스가 이동한 액티비티로 전환되거나 기기 화면이 꺼져서 포커스를 잃는 등의 현재 액티비티에 대한 포커스 소실이 발생하면 앱은  onResume() 에서 벗어나고 그렇지 않다면 onResume()  상태에서 머물게 됩니다.만약 현재 상태에서 방해 이벤트가 발생한다면 액티비티는 일시 중지 상태를 의미하는 onPause() 콜백 메서드를 호출해서 상태 변화를 합니다. 일시 중지 상태에서 다시 액티비티로 돌아온다면 시스템은 다시  onResume() 를 호출합니다.​onPause()사용자가 액티비티를 떠날 때 첫 번째로 호출되는 콜백 메서드입니다.  액티비티가 포그라운드에서 벗어나는 경우 일시중지 상태로 전환됩니다. 이 일시 중지는 onPasue() 를 의미합니다. onPause() 가 호출되는 경우는 onResume() 에서 설명한 예시들에 해당됩니다.액티비티가 포그라운드에 있지 않다면 일시 중지 상태가 되어 원래 사용됐던 기능들을 실행할 필요가 없어지게 됩니다. 그래서 이때는 필요에 따라 onPause() 메서드를 이용하여 시스템 리소스, GPS, 배터리 수명에 영향을 미칠 수 있는 리소스들을 해제할 수도 있습니다.하지만 주의할 점이 있습니다.  onPause() 는 잠깐동안 실행되므로 시간이 길어질 수 있는 애플리케이션 또는 사용자 데이터 저장, 네트워크 호출, 데이터베이스 트랜잭션 등의 작업은 onPause() 가 끝난 후에도 완료가 안될 수도 있습니다. 그래서 공식 문서에서는 이러한 작업들은 onPause() 에서 하지 말고 onStop() 상태일 때 처리하라고 추천합니다.액티비티가 다시 포그라운드에 복귀하면 시스템은 다시 onResume() 을 호출하게 됩니다. 일시 중지 상태에서 재개 상태로 돌아오면 그 과정에서 시스템은 액티비티의 인스턴스를 메모리에 보관했다가 onResume() 을 호출할 때 메모리에 머물고 있던 인스턴스를 호출합니다.​onStop()액티비티가 사용자에게 더 이상 표시되지 않으면 onStop() 을 호출합니다. 기존 액티비티에서 다른 액티비티로 완전히 전환되거나 액티비티의 실행이 완료되어 종료되는 시점에 해당 콜백을 호출합니다. 예를 들어서 앱 사용 중에 홈 화면으로 이동하면 액티비티가 포그라운드에서 벗어나 화면에서 사라지므로  onPause() 가 실행된 후에 onStop() 이 호출됩니다.onStop() 에서도 onPause() 와 마찬가지로 앱이 사용자에게 보이지 않는 동안 앱에서 필요하지 않은 리소스를 해제하거나 조정할 수 있습니다. onPause() 에서는 비교적 가벼운 작업을 처리했다면 여기서는 CPU를 비교적 많이 소모하는 종료 작업 실행을 추천합니다. 데이터베이스에 정보를 저장하는 작업 같은 것을 현재 상태일 때 처리할 수도 있습니다.또한 액티비티가 중단 상태에서 재개 상태로 바뀔 때 onPause() 와 마찬가지로 액티비티 객체가 메모리에 머물다가 다시 시작되면 액티비티 객체 정보가 호출됩니다.onStop() 상태에서는 두 가지 경우가 발생할 수 있습니다. 첫 번째는 액티비티를 다시 재개하는 것이고 두 번째는 액티비티를 종료하는 것입니다. 첫 번째 경우는 onRestart() 가 호출되어 다시 재개하는 과정을 거치고 두 번째는 onDestroy() 가 호출됩니다.​onDestroy()액티비티가 소멸되기 전에 호출되는데 해당 콜백이 호출되는 경우는 다음과 같습니다.  사용자가 액티비티를 완전히 닫거나 finish()  를 호출하여 액티비티가 종료되는 경우  기기 회전이나 멀티 윈도우 모드로 인해서 일시적으로 액티비티를 소멸시키는 경우onDestroy() 는 액티비티가 종료된다면 수명 주기에서 마지막으로 수신하는 콜백 메서드가 됩니다. 따라서 이전에 미처 해제하지 못했던 모든 리소스들을 여기서 처리하고 끝내야 합니다.​여러 상황에서 생명주기지금까지 생명주기의 각 콜백들의 역할과 특징들을 알아봤습니다. 이제는 직접 여러 상황들을 구현하여 생명주기가 어떻게 되는지 알아보겠습니다. 실습에 사용되는 액티비티는 총 두 개, 메인 액티비티와 서브 액티비티가 되겠습니다.앱 실행을 하면 시작 액티비티는 메인 액티비티가 되고 메인에는 서브 액티비티로 전환할 수 있는 버튼이 하나 있습니다. 서브 액티비티에는 메인 액티비티로 전환할 수 있는 버튼 하나와 숫자를 카운트할 수 있는 카운트 버튼이 존재합니다. 각 액티비티의 코드는 다음과 같습니다.MainActivity 코드class MainActivity : AppCompatActivity() {    private lateinit var binding: ActivityMainBinding    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        Log.d(\"MainActivity\", \"onCreate\")        binding = ActivityMainBinding.inflate(layoutInflater)        val view = binding.root        setContentView(view)        binding.btnMoveAnotherActivity.setOnClickListener {            startActivity(Intent(this, SubActivity::class.java))            finish()        }    }    override fun onStart() {        super.onStart()        Log.d(\"MainActivity\", \"onStart\")    }    override fun onResume() {        super.onResume()        Log.d(\"MainActivity\", \"onResume\")    }    override fun onPause() {        super.onPause()        Log.d(\"MainActivity\", \"onPause\")    }    override fun onStop() {        super.onStop()        Log.d(\"MainActivity\", \"onStop\")    }    override fun onDestroy() {        super.onDestroy()        Log.d(\"MainActivity\", \"onDestroy\")    }    override fun onRestart() {        super.onRestart()        Log.d(\"MainActivity\", \"onRestart\")    }}​SubActivity 코드class SubActivity : AppCompatActivity() {private lateinit var binding: ActivitySubBindingprivate var counter: Int = 0    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        Log.d(\"SubActivity\", \"onCreate\")        binding = ActivitySubBinding.inflate(layoutInflater)        val view = binding.root        setContentView(view)        binding.tvCounter.text = counter.toString()        binding.btnMoveMainActivity.setOnClickListener {            startActivity(Intent(this, MainActivity::class.java))            finish()        }        binding.btnAddCount.setOnClickListener {            counter += 1            binding.tvCounter.text = counter.toString()            Log.d(\"Counter 증가 요청\", \"${binding.tvCounter.text}\")        }    }    override fun onStart() {        super.onStart()        Log.d(\"SubActivity\", \"onStart\")    }    override fun onResume() {        super.onResume()        Log.d(\"SubActivity\", \"onResume\")    }    override fun onPause() {        super.onPause()        Log.d(\"SubActivity\", \"onPause\")    }    override fun onStop() {        super.onStop()        Log.d(\"SubActivity\", \"onStop\")    }    override fun onDestroy() {        super.onDestroy()        Log.d(\"SubActivity\", \"onDestroy\")    }    override fun onRestart() {        super.onRestart()        Log.d(\"SubActivity\", \"onRestart\")    }}​앱 실행홈 화면에서 앱을 실행합니다.초기 액티비티를 생성하므로 onCreate() 부터 호출이 됩니다.MainActivity onCreateMainActivity onStartMainActivity onResume​액티비티 전환메인 액티비티에서 서브 액티비티로 전환합니다.메인 액티비티의 소멸까지 기다렸다가 서브 액티비티가 생성되는 것이 아닙니다. 메인 액티비티를 일시 중지 시켜놓고 서브 액티비티를 onResume() 까지 진행시킨 다음, 그 뒤에 메인 액티비티를 종료시키는 겁니다. 액티비티의 전환은 이렇게 처리됩니다.  MainActivity의 onPause() 메서드가 실행된다.  SubActivity의 onCreate(), onStart(), onResume() 메서드가 순차적으로 실행된다.  MainActivity는 finish()  호출로 onDestroy() 까지 호출되어 소멸된다.MainActivity onPauseSubActivity onCreateSubActivity onStartSubActivity onResumeMainActivity onStopMainActivity onDestroy​세로 모드에서 가로 모드로 전환메인 액티비티에서 가로 모드로 전환했습니다.위의 콜백 메서드 설명 부분에서도 언급했지만 화면 구성이 변경될 경우(가로 모드로 전환) 시스템은 액티비티를 소멸시키고 다시 생성하여 가로 모드에 대한 구성을 진행합니다.MainActivity onPauseMainActivity onStopMainActivity onDestroyMainActivity onCreateMainActivity onStartMainActivity onResume​가로 모드로 전환될 때 데이터 상태서브 액티비티에서 카운터를 증가시킨 후 가로 모드로 전환했을 때 과연 카운터 데이터는 유지될까요? 유지되지 않습니다. 가로 모드로 전환하면 액티비티가 소멸되고 다시 생성되기 때문에 데이터도 초기화가 됩니다.​홈 화면으로 이동메인 액티비티에서 홈 화면으로 이동을 해봤습니다.액티비티 화면이 포그라운드에서 벗어나 사용자 시야에서 완전히 사라지므로 onStop() 까지 진행됐습니다.MainActivity onPauseMainActivity onStop​홈 화면에서 앱으로 다시 이동이제 다시 홈 화면에서 메인 액티비티로 돌아갑니다.중단 상태에서 액티비티가 재개하므로 onRestart() 를 시작으로 onResume() 까지 호출됩니다.MainActivity onRestartMainActivity onStartMainActivity onResume​앱 종료앱을 완전히 종료시킵니다.앱이 종료됨에 따라서 액티비티도 소멸하므로 onDestroy() 까지 호출되고 액티비티는 소멸합니다.MainActivity onPauseMainActivity onStopMainActivity onDestroy​마치면서…지금까지 생명주기의 뜻부터 예시까지 알아봤습니다. 이 글은 안드로이드 공식 문서를 참고하여 작성했으며 제 나름대로 해석을 하면서 작성한 거라 잘못된 부분이 있을 수도 있습니다. 혹시라도 잘못된 부분이 있어서 알려주신다면 바로 수정하겠습니다. 긴 글 읽어주셔서 감사합니다!​참조Android 공식 문서제이슨의 개발이야기Dev.Cho - Dev World"
  },
  
  {
    "title": "Chirpy 테마를 이용한 Github 블로그 만들기",
    "url": "/posts/Make-Github-blog/",
    "categories": "블로그, Github 블로그 만들기",
    "tags": "Github 블로그",
    "date": "2023-01-14 00:00:00 +0900",
    





    
    "snippet": "시작하기에 앞서 참고해주세요!jekyll의 Chirpy 테마를 기준으로 진행합니다. 현재 이 블로그의 테마가 Chirpy 테마이며 이 블로그의 테마 디자인이 마음에 들어서 해당 테마가 적용된 깃허브 블로그를 만들고 싶다면 이 글을 참고하시면 좋을 것 같습니다.저는 Chirpy 테마를 적용하기 위해서 해당 테마에 대한 여러 블로그 글과 제작자의 가이드를...",
    "content": "시작하기에 앞서 참고해주세요!jekyll의 Chirpy 테마를 기준으로 진행합니다. 현재 이 블로그의 테마가 Chirpy 테마이며 이 블로그의 테마 디자인이 마음에 들어서 해당 테마가 적용된 깃허브 블로그를 만들고 싶다면 이 글을 참고하시면 좋을 것 같습니다.저는 Chirpy 테마를 적용하기 위해서 해당 테마에 대한 여러 블로그 글과 제작자의 가이드를 참고해서 하라는 대로 따라 했는데 중간 과정들의 결과가 블로그의 글과 달라서 당황했던 기억이 있습니다. 아무래도 제작자분이 해당 테마의 적용 방식에 대한 업데이트를 여러 번 진행해서 적용 방법이 이전과 약간 달라진 것 같습니다.그래서 앞으로 Chirpy 테마를 적용하려는 분들에게 적용 방법과  제가 겪었던 문제점들을 공유하고자 합니다. 아마 이 글을 쓰는 와중에도 제가 적용한 방식이 최신이 아닌 이전 방식이 될 수도 있습니다. 이 점을 참고하고 읽어주시면 감사하겠습니다.​사전 준비다음 세 가지를 준비해 주세요. 테마 적용 과정과 에러 해결에 중점을 두기 때문에 다음 세 가지에 대한 자세한 설명은 생략하겠습니다.  구글에 자세하게 정리된 글이 많으므로 검색해서 참고하시길 바랍니다.      Git, Github        Ruby 를 설치해 주세요. 제가 사용하고 있는 루비 버전은 3.1.3p  입니다. 설치가 완료되면 다음 명령과 같이 루비 버전이 출력되는지 확인해 주세요.  Ruby -vruby 3.1.3p185 (2022-11-24 revision 1a6b16756e) [x86_64-darwin22]  jekyll을 설치해 주세요.gem install jekyll bundler​Github에서 저장소 생성하기모든 준비가 끝났다면 블로그 운영에 필요한 파일들을 저장할 저장소부터 생성합니다. 다음과 같이 본인의 깃허브 네임과 그 뒤에  github.io 을 붙여서 저장소 이름을 만들어주세요. 공개 범위는 public으로 설정합니다.저는 이미 블로그를 위한 저장소가 존재하므로 다음과 같이 이미 해당 이름의 저장소가 존재한다고 메시지가 나옵니다.​테마 파일들 가져오기포크 방식과 압축파일을 다운로드하는 방법이 있는데 저는 두 번째 방법인 압축파일 다운로드 방식을 기준으로 설명하겠습니다.두 가지 방법  테마 저장소 를  fork 해서 fork한 저장소 이름을 {본인의 깃허브 네임}.github.io로 변경해서 사용          포크 한 저장소를 git clone을 통해서 연결한다.        테마 저장소 Download zip을 통해서 가져오기          저장소를 직접 만들고 git clone으로 연결한 후에 다운로드한 폴더를 저장소와 연결된 로컬 폴더에 넣는다.      ​zip 다운로드​테마 파일 초기화현재 다운로드한 테마 파일들은 완전히 초기의 상태가 아니라 제작자에 의해서 계속해서 업데이트가 된 상태입니다. 따라서 본인만의 블로그를 세팅하려면 초기 상태로 만들어줘야 합니다. 초기화 코드는 다음과 같습니다. 해당 코드는 제작자의 시작 가이드에서 가져왔습니다.bash tools/init​그런데 문제가….테마 파일을 다운로드하면 그중에 tools  라는 이름의 폴더가 있는데 그 안에 init 이 존재합니다. 이 init 을 이용해서 초기화를 진행시키는 것입니다. 그런데 저는 아무리 시도해 봐도 tools 디렉터리가 인식이 안되는 건지 초기화가 안됐습니다. 폴더가 존재하는데 디렉터리가 없다고 계속 오류가 발생해서 결국 터미널을 통한 초기화를 할 수 없었습니다. 혹시라도 이유를 아시는 분은 알려주시면 감사하겠습니다…  bash 사용이 제한이 되거나 저처럼 초기화가 안되는 경우에는 직접 테마 폴더를 건드려서 초기화를 하면 됩니다.​직접 초기화?직접 초기화는 다운로드한 테마 폴더 내의 파일 혹은 폴더들을 수정하거나 삭제하는 방식입니다. 다른 블로그들의 글에서 삭제하라는 파일 혹은 폴더가 현재 다운로드한 폴더 내에 없을 수 있습니다. 아마 이 부분도 제작자가 업데이트하면서 일부는 없앤 것 같습니다. 그래서 있는 것들만 수정하거나 삭제하시면 됩니다.  테마 폴더 내 숨겨진 파일들도 수정 및 삭제하므로 초기화 전에 숨김 파일 표시를 해주세요.​수정 및 삭제 목록  .github 폴더 내에 workflows 폴더를 제외하고 모두 삭제  github/workflows 내에 commitlint.yml 과 page-deploy.yml.hook 제외하고 모두 삭제  page-deploy.yml.hook 파일의 .hook 부분을 없애서 page-deploy.yml 로 수정      _config.yml 에서 url: '' 부분에 본인의 깃허브 블로그 주소 넣기    .github/workflows/page-deploy.yml 에서 루비 버전을 로컬 버전이랑 맞춰주세요. jobs:  내의  build: 부분을 찾아보면 밑의 코드처럼 루비 설정에 관한 부분을 찾을 수 있습니다. 제가 사용하는 루비 버전은 3.1.3 이므로 ruby-version: \"\"  에 3.1.3  를 적었습니다.jobs:  build:      - name: Setup Ruby        uses: ruby/setup-ruby@v1        with:          ruby-version: \"3.1.3\" # reads from a '.ruby-version' or '.tools-version' file if 'ruby-version' is omitted          bundler-cache: true  .github/workflows/page-deploy.yml 에서 설정된 브랜치를 확인해 주세요. 2번 라인에 밑의 코드를 확인할 수 있습니다. 연결된 저장소에 저 둘 중에 해당되는 브랜치가 있으면 됩니다. 제 저장소는 main 브랜치를 사용했습니다.on:  push:    branches:      - main      - master    paths-ignore:      - .gitignore      - README.md      - LICENSE  page-deploy.yml 에 등록된 브랜치와 루비 정보를 토대로 build가 진행됩니다.​깃허브 저장소에 PUSH그 전에 로컬 주소로 테스트 해보기bundle exec jekyll serveServer address: http://127.0.0.1:4000/깃허브에 올리기 전에 위의 첫 번째 명령을 실행했다면 두 번째의 로컬 주소를 얻을 수 있습니다.  해당 주소로 이동해서 블로그 상태를 체크해 보세요. 아마 _posts 폴더에 있던 가이드 파일들을 그대로 뒀다면 블로그 글 목록에 가이드 글들이 나타날 것이고, 전부 삭제를 했다면 블로그 글이 하나도 없는 깨끗한 상태일 것입니다.저는 나중에 글 쓰면서 가이드를 참고하기 위해서 완전히 삭제하지 않고 따로 바탕화면에 옮겼습니다. 가이드 글은 제작자의 데모 사이트에도 있으니 그냥 삭제하셔도 됩니다.​Github Actions이제 커밋을 하고 푸시를 하면 저장소 상단 탭에 있는 Actions 에서 블로그 빌드가 진행됩니다. 빌드는 완료되는 데 약간 시간이 걸립니다. 빌드가 정상적으로 끝났다면 이제 본인의 깃허브 블로그 주소에 접속해 보세요. 테마가 적용된 모습을 볼 수 있습니다.하지만 저는 여기서 오류가 발생했었는데 루비와 관련된 에러였습니다. .github/workflows/page-deploy.yml 에서 분명 루비 버전도  3.1.3 으로 맞췄는데 이런 오류가 뜨니 당황스러웠습니다.Error: The process '/opt/hostedtoolcache/Ruby/3.1.3/x64/bin/bundle' failed with exit code 16해당 문제에 대해서 구글링을 한 결과,  스택 오버플로우의 도움을 받아서 다음 코드를 통해 해결할 수 있었습니다. 저와 같은 오류가 발생했다면 해당 글을 참고해 보시면 좋을 것 같습니다.bundle lock --add-platform x86_64-linux​해치웠나?해당 오류는 다행히 해결이 돼서 정상적으로 빌드가 됐습니다. 이제 블로그를 작성할 모든 준비가 됐습니다. 이제 _posts 내에 마크다운 파일을 만들어서 글을 적고 깃허브에 올리는 과정을 반복하여 블로그 글을 채워나가면 됩니다.​참조테마 적용 과정      제작자의 데모 사이트    하얀눈길님 블로그  Jaewoo님 블로그  Ju-ing님 블로그오류 참고  hashnsalt님 블로그"
  }
  
]

