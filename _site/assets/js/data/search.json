[
  
  {
    "title": "Goodbye, 2023! Welcome, 2024! - [2023년 회고]",
    "url": "/posts/Review2023/",
    "categories": "블로그, 회고록",
    "tags": "2023년 회고록, 개발자, 개발 회고",
    "date": "2024-01-24 12:00:00 +0900",
    





    
    "snippet": "2024년을 맞이하며눈 깜짝할 사이에 2023년이 끝났다. 2023년은 여러 이벤트가 겹치면서 다양한 경험을 할 수 있었다. 사용하는 기술 스택에 대한 이해가 이전보다 나아졌고 무엇보다도 확실한 협업 경험을 통해 협업 능력이 높아진 부분에 대해서 상당히 만족하는 한 해였던 것 같다.이런 소중한 경험들을 머릿속에 두었다간 금방 잊힐 게 눈에 보여서 블로...",
    "content": "2024년을 맞이하며눈 깜짝할 사이에 2023년이 끝났다. 2023년은 여러 이벤트가 겹치면서 다양한 경험을 할 수 있었다. 사용하는 기술 스택에 대한 이해가 이전보다 나아졌고 무엇보다도 확실한 협업 경험을 통해 협업 능력이 높아진 부분에 대해서 상당히 만족하는 한 해였던 것 같다.이런 소중한 경험들을 머릿속에 두었다간 금방 잊힐 게 눈에 보여서 블로그 글로 23년의 경험들을 정리하고자 한다. 그리고 이왕 회고 글 작성을 시작한 김에 2023년을 시작으로 계속해서 1년 단위 회고를 작성하고자 한다. 해마다 계속해서 쌓이는 회고들을 보면서 내 성장 과정을 확인한다면 뭐라도 느끼는 게 있지 않을까 싶어서다.이 글이 나중에 뭐 어떤 식으로든 도움이 되길 바라며 이야기를 시작하겠다.​첫 번째 이야기 - 팀 리더로서 첫 프로젝트첫 프로젝트 리더2023년 3월부터 6월까지는 대학교에 다닌 시기다. 4학년 1학기였고 졸업 필수조건인 캡스톤 강의를 수강해야 했다. 캡스톤은 학교에 협력하는 여러 기업에서 필요로 하는 기능이나 서비스를 강의를 수강하는 학생들이 팀을 이루어 개발하는 졸업 프로젝트다. 그래서 캡스톤을 수강한 학생이라면 최소한 한 번의 프로젝트 경험을 얻게 된다.나는 대학교 개강 전에 미리 연락을 돌려 캡스톤 팀원을 모으고자 했는데 당시에 활동하고 있던 개발 커뮤니티에서 합을 맞춰본 지인을 섭외하는 데 성공했다. 그리고 나머지 두 자리는 내가 섭외했던 지인이 두 명을 데리고 왔다. 팀원은 총 4명이고 나는 모바일 개발, 한 명은 웹 개발, 나머지 두 명은 서버 개발을 맡았다.팀 구성이 끝나고 여러 기업이 요구하는 과제를 둘러봤는데 우리 팀 구성에 맞는 프로젝트가 딱 한 개 있었다. 반려동물 케어 서비스를 요구하는 프로젝트였다. 모바일, 웹, 서버 개발이 모두 가능했기에 주저 없이 해당 프로젝트를 선택했다.팀도 구성했고 프로젝트 선택도 끝났으니 마지막으로 팀장을 뽑는 시간을 가졌다. 팀원 모집할 때 내가 섭외했던 지인을 포함해서 나머지 팀원들에게 혹시 팀장을 맡을 의향이 있는지 물어봤는데 원하지 않는 눈치였다. 그래서 마침 팀장으로서의 포지션도 경험하고 싶었던 내가맡기로 했다.기획모든 준비가 끝났고 본격적으로 기획 회의에 들어갔다. 기획부터 쉽지 않았다. 시중에 서비스하는 반려동물 케어 관련 서비스들을 확인했는데 웬만한 것들은 다 있어서 어떻게 차별성을 만들지 아주 많은 고민을 했다. 그래서 2~3번의 기획 회의를 진행했고 결론은 다음과 같다.반려인과 동반으로 여행하는 반려동물의 안전을 위해서 반려동물에 맞춘 여행지 정보 제공 및 리뷰 제공 서비스를 하기로 했다. AI 기술을 이용한 서비스 개발은 팀 구성을 봤을 때 불가능하고 짧은 시간 내에 프로젝트를 마무리해야 해서 충분히 시도해볼만한 주제를 탐색했다. 이를 고려하여 위와 같은 주제를 선택했고 유사 서비스를 벤치마킹하여 좀 더 세밀하게 정보를 제공한다는 목표로 기획을 마무리했다.UI 디자인두 번째 난관에 봉착했다. 어려웠던 기획을 끝내고 모바일 UI/UX 디자인을 시작했는데 이 부분도 굉장히 어려웠다. 시각적인 요소들을 다루는 걸 좋아해서 평소에 UI/UX 디자이너 영상을 챙겨보는 편인데 막상 영상에서 배웠던 걸 적용하려 하니까 쉽지 않았다.그래서 강의 영상과 구글링해서 배우는 것 이외에도 야놀자, 여기어때, 토스 앱의 UI/UX를 참고했다. 카테고리 배치와 리스트와 배치 등을 참고하여 내 나름대로 디자인을 해봤다.잘 만들어진 디자인 시스템을 이용해서 제작하는 게 좋을 것 같다고 판단하여 Material Design을 사용하기로 결정했다. 구글 디자인 시스템인 Material Design에서 제공하는 UI 컴포넌트에 최대한 맞춰서 설계하고자 했고 가능한 단순하게 구성하려고 노력을 많이 했다. 근데 막상 다 만들고 보니까 단순한데 복잡(?)한 느낌이 좀 들었다.프로그래밍모바일 UI/UX 디자인을 마치고 본격적으로 개발을 진행했다. 이때는 서버 담당 인원들과 회의를 진행하면서 API 설계 방식에 대한 회의를 최대한 많이 진행해서 API를 연결하는 데 지장이 가지 않도록 했다. 그리고 서버 담당 인원들의 진행속도에 맞춰서 개발을 진행했다.Android 설계 방식에 관해 얘기를 해보자면 22년 여름으로 거슬러 올라간다.  당시 여름에 처음 나갔던 해커톤에서 팀원이 설정한 프로젝트 구조를 통해 아키텍처 컴포넌트를 처음으로 경험해봤다. 당시에 ViewModel , LiveData , Coroutine 등을 몰라서 코딩하는 시간보다 해당 개념들을 이해하는 데 시간을 많이 소비했다.또한 프로젝트를 Ui , Data 층으로 분류해서 관리하는 법도 처음 경험했다. 이전까지는 액티비티나 프래그먼트에 모든 코드를 때려박았으니  View 와 ViewModel 이 무엇인지, Data 층에서 Repository , DataSource 가 무엇인지 몰랐다. 이것도 최대한 이해하려고 발버둥을 쳐봤는데 결국 한 10%만 조금 이해하고 팀원이 먼저 작성한 코드를 보면서 그대로 따라 하는 식으로 어떻게든 코딩을 했다. 결국, 미완성으로 제출하고 마무리했다.​​  새로운 목표 - 해커톤 대회에서 사용했던 설계 방식을 스스로 1부터 100까지 해보자해커톤 대회를 마치고 대회에서 처음 써봤던 개념들을 차근차근 학습하면서 각 개념의 역할을 이해하고자 했고 이때 새로운 목표를 세웠다. 해당 목표를 완수하기 위해서 마침 혼자서 앱 개발을 진행해야 했던 캡스톤 프로젝트로 도전했다.결과는 성공적이었다. 해커톤 때는 팀원이 작성한 예시코드를 단순히 따라서 만드는 식으로 진행했기 때문에 코딩해도 내가 사용하는 라이브러리나 구조에 대한 이해가 전혀 안 됐다. 하지만 캡스톤 프로젝트에서는 내가 직접 프로젝트를 생성하고 세팅부터 마무리까지 하니까 이전에는 보이지 않던 이유들이 보이기 시작했던 것 같다.덕분에 DI Retrofit ViewModel LiveData  등등.. 이런 여러 라이브러리의 역할을 이해할 수 있었다. 물론 해당 라이브러리들을 완벽하게 이해한 것은 절대 아니다. 역할과 다른 라이브러리와 연결되는 흐름 정도만 조금 이해했다고 할 수 있는 정도가 되겠다.퀄리티를 높이기 위한 생성형 AI 적용캡스톤 프로젝트의 가장 중요한 부분이고 가장 잘한 선택이었다고 말할 수 있다. 기존에 기획했던 목표치 개발을 무사히 완료하고 오류를 검토하는 단계로 넘어갔는데 한 가지 고민이 생겼다. “여기서 좀 더 보완하거나 강화할만한 요소가 있을까?”그런데 서버 담당이었던 팀원이 챗 GPT API 얘기를 꺼냈다. 나는 그걸 듣고 AI 챗봇 기능을 생각했고 바로 해당 인원과 얘기를 해서 GPT API 적용이 가능한 조건의 상황인지 파악했다. 이게 적용하기만 하면 여행지 정보를 찾는 과정 자체가 굉장히 단순해져서 AI API 연결이 가능하다면 하면 무조건 추가하고 싶은 마음이 컸다.그래서 로직 흐름 작성 및 간단한 테스트를 진행해본 결과, 충분히 적용 가능하다는 결론이 나왔다. 나는 바로 AI 챗봇 느낌으로 구현하는 계획을 진행했다. 적용 방법은 다음과 같다.0. 서버에서 관리하는 장소 데이터들을 GPT에 제공하여 학습시키기.1. 사용자가 질문을 입력하면 해당 질문에 대한 문자열을 서버로 전송해서 서버에서 GPT API를 호출한다. 2. 해당 호출의 결과는 서버로 다시 전송될 것이고 서버는 이 결과를 클라이언트에 최종 전달한다. 3. 클라이언트(Android)는 서버로부터 받은 결과물을 화면에 출력한다.​​UI는 흔히 볼 수 있는 챗봇 UI 느낌으로 제작했다. 사용자가 질문을 입력하면 답변을 띄우기 전까지 프로그래스 바를 이용해서 사용자 요청이 정상적으로 처리되고 있음을 나타냈다. 프로그래스 바에 사용된 이미지 파일은 로티(Lottie)에서 가져왔다.리사이클러 뷰를 기반으로 아이템을 동적 추가하는 방식으로 설계를 했다. 그래서 사용자가 처음에 챗봇 페이지에 들어가면 빈 공간이 나오고 질문에 대한 답변이 추가되면 위에서 아래로 쌓인다. 질문이 많아지면 스크롤을 해서 볼 수 있도록 스크롤 뷰도 추가했다.사진에 나오는 강릉 경포해변, 라마다 호텔앤스위트, 서울남대문은 실제로 해당 앱에서 제공하는 여러 장소 중 하나다. 이런 식으로 사용자가 여러 과정 필요없이 챗봇을 이용해서 바로 요약된 답변을 받아 볼 수 있다.결과결과는 최고학점인 A+ 을 받았다. 다 팀원들이 모두 열심히 참여해준 덕이다 :)기업 멘토님의 평가여태 맡았던 팀 중에서 가장 잘한 팀이라는 칭찬을 받았다. 뭔가 기획한 서비스가 대단한 것도 아니고 유사 서비스를 이길 수 있는 강력한 무기가 있는 것도 아니어서 이 정도 칭찬을 들을 정돈가 싶었다. 그래도 기획한 부분을 깔끔하게 완료했고 오히려 기존 기획에서 AI챗봇을 추가한 부분에 대해서 좋게 봐주신 것 같다.교수님들 평가기획 관련해서 여러 질문을 해주셨다. 엄청나게 깊은 질문은 아니고 그냥 이 서비스를 기획한 이유라던가 다른 서비스와의 차이점 같은 간단한 질문이었다.개발 관련 질문도 나왔는데 AI에 관한 내용이었다. 챗봇 기능을 위해 사용한 챗 GPT의 버전이 무엇이며 해당 기술의 정보 신뢰성에 대한 질문을 받았다. 교수님들이 봤을 때는 GPT API가 항상 우리가 원하는 답을 주는 것도 아니고 거짓된 정보도 제공할 수 있기 때문에 이에 대해서 기술적인 해결시도가 있었는지를 알고 싶어서 물어보신 것 같다.우리 팀도 이 부분을 몰랐던 것은 아니다. 이를 어느 정도 해결하기 위해서는 1차로 좀 더 비싸고 성능 좋은 GPT API를 사용해야 한다. 그리고 2차는 우리가 기술적으로 설계를 탄탄하게 해서 사용자에게 신뢰성 있는 정보를 제공하는 것이다. 하지만 우리에겐 돈도 많이 없었고 챗봇 기능을 거의 캡스톤 막바지에 추가했기 때문에 기능을 리뷰할 시간도 많이 없었다. 그래서 교수님들의 질문에 대해선 이 부분을 솔직하게 말씀드렸다.프로젝트를 마무리하며 좋았던 점우선 팀장으로서 팀원들을 이끌고 프로젝트를 하는 경험은 처음이었는데 팀원으로서 프로젝트에 참여했을 때와는 다르게 신경써야 하는 범위가 매우 컸다. 팀장이라 직접 노션에 협업 페이지를 만들고 회의, 팀원 케어, 보고서 작성, 일정 조율을 주도적으로 했는데 협업 능력치가 이전보다 성장한 것 같아서 이 부분에 대해선 굉장히 만족한다.그리고 서비스 기획부터 완성 발표까지 처음과 끝을 다 경험해서 나중에 기획자와 디자이너의 협업 기회가 생기면 잘할 수 있겠다는 자신감이 생겼다. 기획과 디자인의 고충을 이번 프로젝트로 뼈저리게 느꼈다…마지막으로 팀 분위기가 처음부터 끝까지 열정적이어서 매우 좋았다. 같이 으쌰으쌰하는 분위기라 나도 열심히 참여했고 다른 팀원들도 열심히 참여했다. 팀장으로서 팀 분위기를 좋게 하려고 연예인 매니저 빙의해서 케어를 했는데 팀원들이 잘 받아주고 잘 참여해줘서 너무나도 고마웠다.프로젝트를 마무리하며 아쉬웠던 점챗봇 AI 기능을 개선할 시간이 부족했던 게 너무 아쉬웠다. 프로젝트 막바지에 챗봇 기능을 추가해서 뭔가 개선할 수 있는 시간이 좀 부족했던 것 같다. AI 기술을 처음 다뤄서 굉장히 재밌게 개발했는데 나중에 AI 기술을 다뤄볼 기회가 또 생기면 그때는 제대로 만들어보고 싶다.또 다른 아쉬운 점은 기업이랑 협력해서 과제를 수행하는 방식인데 우리 팀은 기업으로부터 도움을 받은 게 별로 없었다는 것이다. 초반 기획에는 화상회의를 통해서 기획에 대한 여러 피드백을 받을 수 있어서 좋았다. 하지만 멘토로 참여했던 기업 대표이사님이 기획자 위치라 기획이 완료된 이후의 과정에서는 우리끼리 모든 걸 정하고 진행할 수밖에 없었다.UI/UX, 기술적인 설계에 대한 도움이 가장 필요했는데 해당 피드백은 어려울 것 같다는 답변을 받아서 우리가 직접 검토하면서 진행을 했다. 만드는 건 문제가 되지 않았지만, 문제점 없이 만들었는지에 대한 점검은 우리 수준에서 어려웠던 것 같다.​두 번째 이야기 - GDSC, 2년의 마침표21년에 합격해서 시작했던 구글 학생 개발자 클럽인 GDSC  활동을 드디어 23년 6월 중순에 마무리했다. 약 2년의 기간동안 다양한 활동들을 했었는데 나에게 정말 좋은 추억으로 남았다. 이 활동을 통해서 개발자라는 목표를 더욱 돈독히 다지게 됐으니 말이다.시작은 군대에서 우연히 보게 된 영상으로부터나는 원래 군대를 가기 전까지는 개발자가 되는 것을 원하지 않았다. 과는 컴퓨터공학부였지만 단순히 고등학교 성적에 맞춰서 선택해서 들어온 학과고 이 때문에 목표의식이 없는채로 1학년을 마무리했다. 그리고는 그 상태 그대로 입대를 했다. 훈련소에서 새벽 불침번을 하면서 혼자 미래에 대한 생각을 해봤는데 뭔가 스스로에게 변화가 필요하다는 것을 느꼈다.그래서 훈련소를 수료하고 자대에 가자마자 평생 해보지도 않았던 헬스를 시작했다. 제대로 해보고 싶어서 유튜브로 운동 영상을 찾아봤고 벌크업을 위해서 식사량을 엄청 늘렸다. 그 결과, 말랐던 몸이 건강한 근육질로 바뀌었고 특급전사까지 달성하는 쾌거를 이루었다. 아마 이때를 기점으로 새로운 것에 도전하고 성취하고자 하는 가치관이 만들어진 것 같다.이때 이후로 군대에서 할 수 있는 여러 큰 도전을 해본 것 같다. 평생 남들 밑에서 조용히 지내던 내가 팀의 리더인 분대장을 자원해서 팀을 이끄는 일도 하고 공도 제대로 차본 적 없는 내가 족구에 도전해서 대대 족구 대회를 우승하는 경험도 했다. 내가 뭔가를 시작하면 끝을 봐야 하는 성격이라 덕분에 결과가 모두 좋게 나온 것 같다.손을 대는 것마다 성과가 엄청나니까 진로에 대한 자신감도 생기게 되었다. 그래서 이왕 컴퓨터공학부로 입학했으니 전공을 살리기로 마음을 먹고 유튜브에 개발자 관련 영상을 찾아보기 시작했다.그렇게 영상을 보던 중에 눈에 띄는 제목의 한 영상을 발견했다. Interactive Developer 라는 멋있는 네임이 달린 채널이었다. 디자이너와 개발자를 동시에 수행하는 구글 직원이었는데 궁금해서 그 사람이 올린 본인 포트폴리오 영상을 봤다. 미적인 영감을 프로그래밍으로 구현하는 모습을 보고 감탄을 했다. 코딩의 대단함을 이때 많이 느꼈던 것 같다.  출처 - jongmin kim blog그리고 군대에 있던 20년도에 ‘하트시그널3’이라는 프로그램이 유행했다. 딱히 개인시간에 할 게 없어서 한 번 봤는데 남자 출연자 중에서 금융 관련 스타트업에서 일하는(현재 퇴사) 개발자가 있었다. 개발자로서 어떤 사람인지 호기심에 유튜브 검색을 해봤는데 엄청난 인물이었다. 실력은 당연하고 직업 가치관이 굉장히 멋있었다. 이런 멋있는 가치관과 직업에 대한 애정에 반해서 개발자라는 직업에 좀 더 흥미를 붙이게 된 것 같다.  출처 - 아무튼 출근  출처 - eo 천인우​이를 통해 전역 후에 개발 역량을 높이기 위한 방법을 생각해봤다. 혼자서 개발 공부를 하는 것보다는 동아리나 학회에 들어가서 잘하고 열심히 하는 사람들 밑에서 공부하는 게 성장하는 데 유리할 것 같다는 생각을 했다. 그래서 대학생 커뮤니티인 에브리타임에서 동아리나 학회 모집 공고를 챙겨보기 시작했고 거기서 GDSC 모집글을 발견했다. 커리큘럼도 괜찮았고 구글 후원의 행사도 다양해서 여기 아니면 안된다는 마인드로 지원을 넣었고 운좋게 합격해서 활동을 시작하게 되었다.21-22 개발 새내기의 도전GDSC에 합격한 후, 다양한 사람들과 다양한 활동들을 경험했다. 들어가자마자 안드로이드 개발 공부를 팀 스터디 형식으로 진행했다. 팀 스터디 자체를 처음 해보고 안드로이드 개발도 처음 해보는 거여서 같이 하는 사람들한테 민폐 안끼치려고 정말 열심히 했다.안드로이드에 어느정도 익숙해졌을 때 구글에서 전세계 대학생들을 상대로 여는 솔루션 챌린지 대회에 참가했다. 이 대회가 내 첫 프로젝트였다. 이때 세 명이서 한팀을 이루고 채식주의자를 위한 레시피 정보 제공 어플리케이션을 개발했다. 프로젝트가 처음이었던 나는 깃허브 사용도 어색해서 이것저것 팀장한테 물어보면서 겨우겨우 내 코드를 메인 브랜치에  merge 했던 기억이 난다.그리고 안드로이드 스튜디오로 뷰를 제작할 때 코드타이핑을 하지 않고 레이아웃 툴을 이용해서 뷰를 마우스로 배치하는 짓을 저질렀다. 또한 이것도 모자라.. 액티비티에 네트워킹, 데이터, 뷰와 관련된 모든 코드를 때려박는 짓을 저질렀다. 덕분에 내가 작성한 액티비티 코드는 담당자인 내가 봐도 파악을 못하는 경지에 도달했다.유지보수는 1도 안되고 어딘가 오류가 발생하면 액티비티 전역이 빨간불 걸리고… 확장하려니 기존코드를 또 수정해야 하고… 정말 답도 없었다. 심사하려고 이 코드를 봤던 구글 개발자분들에게 죄송할 따름이다. 그래도 이런 경험을 통해 소프트웨어 아키텍처가 필요한 이유를 알게 되었다.완전 초보인 상태로 프로젝트를 끝낸 이후에는 다양한 사람들과 스터디도 하고 해커톤도 나가고 MT도 갔다. 프로젝트 이외에도 다양한 활동을 한 덕분에 소통, 협업, 개발 능력치를 올릴 수 있었다. 여기서 인연이 되어 지금도 연락하고 지내는 사람들도 꽤 있다. 그만큼 멤버들도 활동 내용도 너무 만족스러운 활동이었다.22 - 23 새로운 도전멤버로서 약 1년의 활동을 끝내고 혼자 머릿속으로 회고를 진행해봤다. 개발과 협업을 모두 경험해봤는데 뭔가 개발보다는 협업이 더 어려운 것 같다는 생각을 했다. 그래서 협업 능력을 키우기 위한 고민을 하고 있었는데 때마침 GDSC에서 멤버로 같이 활동을 한 친구가 다음 기수 리드로 활동을 하게 돼서 코어 멤버를 뽑아야 하는데 해볼 생각 있냐고 제안이 왔다.코어 멤버로 활동하게 되면 멤버로 활동할 때와 다르게 조직 운영 및 기획과 소통을 할 일이 많기 때문에 내가 원하는 부분을 얻을 수 있을 것 같아 면접을 보고 코어 멤버로 2회차 활동을 시작했다. 코어 멤버로서 리드와 회의를 진행하면서 여러 중요한 것들을 결정하고 진행했다. 이 과정에서 회의를 정말 많이 한 것 같다.가장 기억에 남는 활동은 대회를 기획하고 운영하는 일이었다."
  },
  
  {
    "title": "(프로그래머스 | Kotlin) - 무인도 여행",
    "url": "/posts/KotlinAlgorithm13/",
    "categories": "CS, 알고리즘 문제",
    "tags": "Kotlin, Algorithm, 알고리즘, 프로그래머스",
    "date": "2023-12-07 12:00:00 +0900",
    





    
    "snippet": "해결 방법그래프 탐색을 이용해서 X 가 아닌 영역들을 찾아서 합산한다. BFS 혹은 DFS 를 사용하면 되는데 나는 DFS 를 사용해서 풀었다. maps 의 모든 원소를 반복문으로 돌면서 X 가 아니면서 방문하지 않은 곳을 시작점으로 두고 DFS 를 돌린다.그리고 DFS 를 돌면서 방문한 점들은 모두 방문 처리(true)를 한다. 전형적인 DFS BF...",
    "content": "해결 방법그래프 탐색을 이용해서 X 가 아닌 영역들을 찾아서 합산한다. BFS 혹은 DFS 를 사용하면 되는데 나는 DFS 를 사용해서 풀었다. maps 의 모든 원소를 반복문으로 돌면서 X 가 아니면서 방문하지 않은 곳을 시작점으로 두고 DFS 를 돌린다.그리고 DFS 를 돌면서 방문한 점들은 모두 방문 처리(true)를 한다. 전형적인 DFS BFS 문제라서 그래프 탐색 알고리즘만 작성할 수 있으면 어렵지 않게 풀 수 있는 문제다.​전체 코드class Solution {    fun solution(maps: Array&lt;String&gt;): IntArray {        val answer = ArrayList&lt;Int&gt;()        val isVisited = Array(100) { BooleanArray(100) }        for(i in 0..maps.lastIndex) {            for(j in 0..maps[0].lastIndex) {                if(maps[i][j] != 'X' &amp;&amp; !isVisited[i][j]) {                    isVisited[i][j] = true                    answer.add(rec(Point(i, j, maps[i][j] - '0'), maps, isVisited))                }            }        }        return if(answer.isEmpty()) intArrayOf(-1) else answer.sorted().toIntArray()    }    private fun rec(        s: Point,        maps: Array&lt;String&gt;,        isVisited: Array&lt;BooleanArray&gt;    ): Int {        var answer = s.days        val dirX = listOf(0, 1, 0, -1)        val dirY = listOf(1, 0, -1, 0)        for(i in 0..3) {            val nxtX = s.x + dirX[i]            val nxtY = s.y + dirY[i]            if(nxtX in maps.indices &amp;&amp; nxtY in maps[0].indices &amp;&amp; maps[nxtX][nxtY] != 'X' &amp;&amp; !isVisited[nxtX][nxtY]) {                isVisited[nxtX][nxtY] = true                answer += rec(Point(nxtX, nxtY, maps[nxtX][nxtY] - '0'), maps, isVisited)            }        }        return answer    }    data class Point(        val x: Int,        val y: Int,        val days: Int    )}"
  },
  
  {
    "title": "(프로그래머스 | Kotlin) - 메뉴 리뉴얼",
    "url": "/posts/KotlinAlgorithm12/",
    "categories": "CS, 알고리즘 문제",
    "tags": "Kotlin, Algorithm, 알고리즘, 프로그래머스, 카카오 코딩테스트",
    "date": "2023-12-05 12:00:00 +0900",
    





    
    "snippet": "해결 방법가장 간단한 해결 방법은 orders 의 모든 원소들을 course 내의 희망 개수에 맞춰 단품메뉴 조합을 만드는 것이다. 예를 들어서 1번 예시를 보면 orders 의 첫 번째 원소는 ABCFG, course 의 첫 번째 원소는 2 다.이를 토대로 ABCFG 에서 두 개로 구성된 조합을 모두 꺼내서 map 에 카운트를 증가시킨다. 마찬가지로...",
    "content": "해결 방법가장 간단한 해결 방법은 orders 의 모든 원소들을 course 내의 희망 개수에 맞춰 단품메뉴 조합을 만드는 것이다. 예를 들어서 1번 예시를 보면 orders 의 첫 번째 원소는 ABCFG, course 의 첫 번째 원소는 2 다.이를 토대로 ABCFG 에서 두 개로 구성된 조합을 모두 꺼내서 map 에 카운트를 증가시킨다. 마찬가지로 orders 의 나머지 원소들도 두 개로 구성된 조합을 모두 만들어서 map 에 카운트를 증가시킨다. 이렇게 해서 course 에서 2 에 대한 작업이 끝나면 나머지 3 4 도 동일하게 처리한다.이제 map 에는 course 에서 희망한 단품메뉴 조합 수를 토대로 제작한 조합들이 key 값으로, 해당 조합이 등장한 횟수를 카운트한 값이 value 로 존재한다. 2 개로 구성된 조합도 많을테고, 3 개, 4 개의 조합 수도 많을 것이다.이제 그중에서 등장 횟수가 가장 많은 조합만 꺼내면 된다.  2 개 조합에서 가장 많은 등장을 한 조합은 AC , 3 개 조합에서 가장 많은 등장을 한 조합은 CDE , 4 개 조합은 최대 등장 횟수가 동일한 ACDE BCFG .​정렬된 결과값이 필요하기 때문에 orders 의 모든 원소들을 정렬result 도 정렬되어야 하고, result 내 원소들도 정렬되어야 한다. 따라서 시작할 때 orders 의 모든 원소들을 정렬시키는 것이 좋다. 그래야 부분 조합을 구할 때도 정렬된 조합으로 만들어져서 정렬과 관련된 작업을 하지 않아도 된다.orders.map { it.toSortedSet().joinToString(\"\") }.forEach { order -&gt;    course.forEach { menuCnt -&gt;        rec(0, menuCnt, order)    }}여기서 배열이나 조합과 같은 컬렉션의 원소들을 모두 합친 형태의 문자열로 만들고 싶으면 jotinToString 을 사용하자. 해당 메서드를 사용하면 컬렉션의 각 원소들을 더하기 연산으로 붙이는 작업을 할 필요가 없다.​course 별 등장 빈도가 가장 높은 조합을 꺼내서 result 에 추가  원하는 조합 수에 해당되는 key 값들만 필터링  그중에서 최대 등장값 구하기 (없으면 쓰레기값 넣기)  주문 횟수가 최소 2개 이상이면서 최대 등장값인 조합 필터링course.forEach { menuCnt -&gt;    val filtered = m.filter { it.key.length == menuCnt }    val max = filtered.maxByOrNull { it.value }?.value ?: Int.MAX_VALUE    answer.addAll(filtered.filter { it.value &gt; 1 &amp;&amp; it.value == max }.keys)}​부분 조합을 구하기 위해 재귀 함수 이용백트래킹을 응용해서 원하는 개수의 부분 조합을 구한다. 조합이 완성될 때마다 map 에 해당 조합을 새로 등록하거나 카운트를 증가시킨다.private fun rec(    start: Int,    targetLength: Int,    order: String,    tmp: MutableList&lt;Char&gt; = mutableListOf(),) {    if(tmp.size == targetLength) {        with(tmp.joinToString(\"\")) {            if(!m.containsKey(this)) { m[this] = 0 }            m[this] = m[this]!! + 1        }        return    }    for(i in start..order.lastIndex) {        tmp.add(order[i])        rec(i+1, targetLength, order, tmp)        tmp.removeLast()    }}​전체 코드class Solution {    private val m = mutableMapOf&lt;String, Int&gt;()    fun solution(orders: Array&lt;String&gt;, course: IntArray): Array&lt;String&gt; {        val answer = ArrayList&lt;String&gt;()        orders.map { it.toSortedSet().joinToString(\"\") }.forEach { order -&gt;            course.forEach { menuCnt -&gt;                rec(0, menuCnt, order)            }        }        course.forEach { menuCnt -&gt;            val filtered = m.filter { it.key.length == menuCnt }            val max = filtered.maxByOrNull { it.value }?.value ?: Int.MAX_VALUE            answer.addAll(filtered.filter { it.value &gt; 1 &amp;&amp; it.value == max }.keys)        }        return answer.sorted().toTypedArray()    }    private fun rec(        start: Int,        targetLength: Int,        order: String,        tmp: MutableList&lt;Char&gt; = mutableListOf(),    ) {        if(tmp.size == targetLength) {            with(tmp.joinToString(\"\")) {                if(!m.containsKey(this)) { m[this] = 0 }                m[this] = m[this]!! + 1            }            return        }        for(i in start..order.lastIndex) {            tmp.add(order[i])            rec(i+1, targetLength, order, tmp)            tmp.removeLast()        }    }}"
  },
  
  {
    "title": "(프로그래머스 | Kotlin) - 2차원 동전 뒤집기",
    "url": "/posts/KotlinAlgorithm11/",
    "categories": "CS, 알고리즘 문제",
    "tags": "Kotlin, Algorithm, 알고리즘, 프로그래머스",
    "date": "2023-11-23 12:00:00 +0900",
    





    
    "snippet": "해결 방법이 문제는 특정 행, 혹은 열을 뒤집어서 원하는 형태를 만드는 게 핵심이다. 어떤 행, 혹은 열을 뒤집는 순서가 중요한 것이 아니다. 어떤 행, 혹은 열의 상태를 어떻게 할 것인지(뒤집거나 그대로 두거나)가 중요하다.  M X N  형태에서 특정 열과 행의 상태를 결정하는 방식으로 로직을 짜면 된다.​뒷면, 앞면의 상태값을 비트로 표현해보자문...",
    "content": "해결 방법이 문제는 특정 행, 혹은 열을 뒤집어서 원하는 형태를 만드는 게 핵심이다. 어떤 행, 혹은 열을 뒤집는 순서가 중요한 것이 아니다. 어떤 행, 혹은 열의 상태를 어떻게 할 것인지(뒤집거나 그대로 두거나)가 중요하다.  M X N  형태에서 특정 열과 행의 상태를 결정하는 방식으로 로직을 짜면 된다.​뒷면, 앞면의 상태값을 비트로 표현해보자문제 마지막에 보면 0 은 동전의 앞면, 1 은 동전의 뒷면을 의미한다. 그렇다면  0 1 을 비트 연산으로 처리해보자. 예를 들어서 2 X 2 형태라고 가정해보자. 행과 열은 각각 2개고 다음과 같이 표현할 수 있다.두 개면 모두 앞면인 경우와 모두 뒷면 경우, 한쪽은 앞면 한쪽은 뒷면인 경우가 존재한다. 이를 비트 형식으로 표현하면 다음과 같이 표현할 수 있다.  예를 들어서 행에서 00 은 첫 번째 행, 두 번째 행 모두 앞면인 상태를 의미한다.행 -&gt;00 01 10 11 열 -&gt; 00 01 10 11​시프트 연산을 응용하여 모든 경우의 수(완전 탐색)를 꺼내 처리해보자비트 00 은 십진수로  0 을 의미한다. 비트 01 은 1 이다. 비트 10 은 2 이다. 비트 11 은 3 이다. 즉, 0 부터 3 까지 반복문을 통해서 나올 수 있는 동전판의 모든 경우를 꺼내서 타겟과 일치하는지 검사할 수 있다.for(i in 0 until (1 shl 2))// 1 shl 2 =&gt; 2^2를 의미한다.여기서 행과 열의 비트를 합쳐서 하나의 반복문으로 처리한다. 이렇게 하면 2X2 형태에서 나올 수 있는 경우의 수를 하나의 비트식으로 표현할 수 있다.예를 들어서 2X2 형태에서 모든 행은 뒷면이고 모든 열은 앞면인 경우라면 1100, 반대로 모든 행은 앞면이고 모든 열이 뒷면이라면 0011 이다. 맨 앞의 두 개가 열의 상태값이고 뒤의 두 개가 행의 상태값이다.이렇게 0000 부터 1111 까지 모든 조합을 꺼내서 원본과 비교하여 뒤집거나 그대로 두는 코드를 작성하면 된다.for( i in 0 until (1 shl col+row))// col =&gt; 행의 크기// row =&gt; 열의 크기// 2X2형태라면 (1 shl 4) =&gt; 2^4가 된다.// 0000 ~ 1111 까지 루프​비트 연산을 이용하여 처리하자for( i in 0 until (1 shl col+row))// 2X2크기라고 가정해당 반복문을 동작시키면 0000 부터 1111 까지 나오는데 현재 1010 차례라고 가정해보자. 그리고 원본이 1100 라고 하자. 앞의 두 개는 열의 상태값을 의미하고 뒤의 두 개는 행의 상태값을 의미한다.행부터 살펴보면 2^1 부분의 값이 다르다. 반면에  2^0 부분은 서로 0 이기 때문에 뒤집을 필요가 없다. 따라서 값이 다른  2^1 부분은 뒤집어야 함을 의미하므로 이 부분은 뒤집어주면 된다.첫 번째 행의 인덱스는 0, 두 번째 행의 인덱스는 1 이다. 첫 번째 행의 상태값을 의미하는 비트 위치는 2^0 , 두 번째 행은 2^1 이다. 따라서 두 번째 행을 뒤집으면 된다. 이 개념을 코드로 옮기면 다음과 같다.  XOR 비트 연산을 사용하면 뒤집는 동작을 쉽게 처리할 수 있다.​행을 처리하는 코드for(c in 0 until col) {    if(b and (1 shl c) != 0) {        flipCounter++        tmp[c] = tmp[c].map { it xor 1 }.toIntArray()    }}열을 처리하는 코드for(r in 0 until row) {    if(b and (1 shl r + col) != 0) {        flipCounter++        for(i in 0..tmp.lastIndex) { tmp[i][r] = tmp[i][r] xor 1 }    }}  열의 경우에는 2^2 부터 검사를 해야 하기 때문에 (1 shl r+col) 로 AND 처리를 해줘야 한다.​마지막은 target 과 비교하여 동일한지 검사한다.if(tmp.contentDeepEquals(target)) { answer = min(answer, flipCounter) }​전체 코드import kotlin.math.*class Solution {    fun solution(beginning: Array&lt;IntArray&gt;, target: Array&lt;IntArray&gt;): Int {        val col = beginning.size        val row = beginning[0].size        var answer = Int.MAX_VALUE        for(b in 0 until (1 shl col+row)) {            val tmp = Array(col) { i -&gt; IntArray(row) { j -&gt; beginning[i][j] } }            var flipCounter = 0            for(c in 0 until col) {                if(b and (1 shl c) != 0) {                    flipCounter++                    tmp[c] = tmp[c].map { it xor 1 }.toIntArray()                }            }            for(r in 0 until row) {                if(b and (1 shl r + col) != 0) {                    flipCounter++                    for(i in 0..tmp.lastIndex) { tmp[i][r] = tmp[i][r] xor 1 }                }            }            if(tmp.contentDeepEquals(target)) { answer = min(answer, flipCounter) }        }        return if(answer == Int.MAX_VALUE) -1 else answer    }    }"
  },
  
  {
    "title": "(프로그래머스 | C++) - 방금그곡",
    "url": "/posts/KotlinAlgorithm10/",
    "categories": "CS, 알고리즘 문제",
    "tags": "Kotlin, Algorithm, 알고리즘, 프로그래머스, 카카오 코딩테스트",
    "date": "2023-11-23 12:00:00 +0900",
    





    
    "snippet": "해결 방법문제에서 주어진 조건을 가지고 시킨 것만 잘 수행하면 된다. musicinfos 에서는 \"12:00,12:14,HELLO,CDEFGAB\" 형식의 문자열을 원소로 가지고 있다. 이 문자열을 잘 분해해서 처리해야 하는데 순서는 다음과 같다.      문자열을 , 기준으로 split 한 배열을 생성한다.  [\"12:00\", \"12:14\", \"HEL...",
    "content": "해결 방법문제에서 주어진 조건을 가지고 시킨 것만 잘 수행하면 된다. musicinfos 에서는 \"12:00,12:14,HELLO,CDEFGAB\" 형식의 문자열을 원소로 가지고 있다. 이 문자열을 잘 분해해서 처리해야 하는데 순서는 다음과 같다.      문자열을 , 기준으로 split 한 배열을 생성한다.  [\"12:00\", \"12:14\", \"HELLO\", \"CDEFGAB\"]    vector&lt;string&gt; split(string str, char splitChar) {    vector&lt;string&gt; result;    istringstream iss(str);    string buffer;    while(getline(iss, buffer, splitChar)) {        result.push_back(buffer);    }    return result;}   for(string info: musicinfos) {    vector&lt;string&gt; infoList = split(info, ',');}            # 이 붙은 음을 하나로 합치기 위해서 알파벳 소문자로 변환해준다. 예를 들어서 C# 이 있다면 c 이렇게 하나의 문자로 바꿔준다. 이렇게 해야 ABC 를 찾아야 하는데 ABC# 에서 C# 을 C 로 착각해서 ABC 가 있는 것으로 인식하는 변수를 방지할 수 있다.    string convertSharpToLowercase(string str) {    int i = 0;    while(i &lt; str.length()) {        if(str[i] == '#') {            char lowercase = tolower(str[i-1]);            str.replace(i-1, 2, string(1, lowercase));            continue;        }        i++;    }    return str;}            실행시간을 정수형으로 구한다.  12:00, 12:14 의 수행시간은 총 14분이다.    int getPlaytimeWithString(string start, string end) {    int startForMinute = stoi(start.substr(0,2)) * 60 + stoi(start.substr(3));    int endForMinute = stoi(end.substr(0,2)) * 60 + stoi(end.substr(3));    return endForMinute - startForMinute;}            실행시간 크기만큼 악보를 재구성한다. 예를 들어서  CDEFGAB 이게 기본 악보인데 1분당 1개의 음을 구성하므로 14분으로 재구성하면 CDEFGABCDEFGAB 이다.    string getMelodyDuringPlaytime(string melodyOrigin, int playtime) {    string melodyDuringPlaytime = \"\";    if(melodyOrigin.length() &lt;= playtime) {        melodyDuringPlaytime = melodyOrigin;        for(int i = 0; i &lt; playtime - melodyOrigin.length(); i++) {            melodyDuringPlaytime += melodyOrigin[i%melodyOrigin.length()];        }    }    else {        for(int i = 0; i &lt; playtime; i++) {            melodyDuringPlaytime += melodyOrigin[i];        }    }    return melodyDuringPlaytime;}            재구성한 악보에서 m 에 해당되는 구간이 있는지 찾는다. 이런 방식으로 musicinfos 의 모든 음악들을 비교하면 된다.    bool isValid(string userMelody, string playtimeMelody) {    return playtimeMelody.find(userMelody) != string::npos;}      전체 코드#include &lt;string&gt;#include &lt;vector&gt;#include &lt;sstream&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;string&gt; split(string str, char splitChar) {    vector&lt;string&gt; result;    istringstream iss(str);    string buffer;    while(getline(iss, buffer, splitChar)) {        result.push_back(buffer);    }    return result;}int getPlaytimeWithString(string start, string end) {    int startForMinute = stoi(start.substr(0,2)) * 60 + stoi(start.substr(3));    int endForMinute = stoi(end.substr(0,2)) * 60 + stoi(end.substr(3));    return endForMinute - startForMinute;}string convertSharpToLowercase(string str) {    int i = 0;    while(i &lt; str.length()) {        if(str[i] == '#') {            char lowercase = tolower(str[i-1]);            str.replace(i-1, 2, string(1, lowercase));            continue;        }        i++;    }    return str;}string getMelodyDuringPlaytime(string melodyOrigin, int playtime) {    string melodyDuringPlaytime = \"\";    if(melodyOrigin.length() &lt;= playtime) {        melodyDuringPlaytime = melodyOrigin;        for(int i = 0; i &lt; playtime - melodyOrigin.length(); i++) {            melodyDuringPlaytime += melodyOrigin[i%melodyOrigin.length()];        }    }    else {        for(int i = 0; i &lt; playtime; i++) {            melodyDuringPlaytime += melodyOrigin[i];        }    }    return melodyDuringPlaytime;}bool isValid(string userMelody, string playtimeMelody) {    return playtimeMelody.find(userMelody) != string::npos;}string solution(string m, vector&lt;string&gt; musicinfos) {    string targetTitle = \"(None)\";    int targetPlaytime = -1;    for(string info: musicinfos) {        vector&lt;string&gt; infoList = split(info, ',');        int playtime = getPlaytimeWithString(infoList[0], infoList[1]);        if(playtime &lt;= targetPlaytime) continue;        string melodyOrigin = convertSharpToLowercase(infoList[3]);        string melodyDuringPlaytime = getMelodyDuringPlaytime(melodyOrigin, playtime);        if(isValid(convertSharpToLowercase(m), melodyDuringPlaytime)) {            targetPlaytime = playtime;            targetTitle = infoList[2];        }    }    return targetTitle;}"
  },
  
  {
    "title": "(프로그래머스 | Kotlin) - 전력망을 둘로 나누기",
    "url": "/posts/KotlinAlgorithm9/",
    "categories": "CS, 알고리즘 문제",
    "tags": "Kotlin, Algorithm, 알고리즘, 프로그래머스",
    "date": "2023-11-21 12:00:00 +0900",
    





    
    "snippet": "해결 방법특정 전선이 끊어지면 하나의 트리는 두 개의 그룹으로 나뉘게 된다. 따라서 두 개의 그룹 각각, DFS 혹은 BFS 를 이용해서 그룹 내 노드의 개수를 카운트한다. 나는 BFS 를 이용해서 노드의 개수를 구했다.그리고 탐색 시작점은 제거한 전선과 연결된 노드로 지정했다. 첫 번째 입출력 예제 그림에서 4 와  7 이 연결된 전선을 끊은 경우를...",
    "content": "해결 방법특정 전선이 끊어지면 하나의 트리는 두 개의 그룹으로 나뉘게 된다. 따라서 두 개의 그룹 각각, DFS 혹은 BFS 를 이용해서 그룹 내 노드의 개수를 카운트한다. 나는 BFS 를 이용해서 노드의 개수를 구했다.그리고 탐색 시작점은 제거한 전선과 연결된 노드로 지정했다. 첫 번째 입출력 예제 그림에서 4 와  7 이 연결된 전선을 끊은 경우를 보여주는데 이때 생긴 두 개의 그룹에서 탐색 시작점은 4,  7 이 된다. 4 에서 탐색을 시작하면 6개, 7 에서 탐색을 시작하면 3개가 카운드된다.따라서 모든 전선에 대해서 위 방법을 적용시켜 비교해야 한다. 예제에서 전선 정보가 담긴 wires 을 줬기 때문에 이 배열의 각 원소(전선)에 대해서 트리를 두 개로 나누고 각 트리마다 송전탑 개수를 BFS 로 구한다.​전체 코드import kotlin.math.*class Solution {    private val node = Array(101) { arrayListOf&lt;Int&gt;() }    fun solution(n: Int, wires: Array&lt;IntArray&gt;): Int {        var answer = Int.MAX_VALUE        val isChecked = Array(101) { Array(101) { false } }        wires.forEach {            node[it[0]].add(it[1])            node[it[1]].add(it[0])        }        for(a in 1..n) {            node[a].forEach { b -&gt;                if(!isChecked[a][b] &amp;&amp; !isChecked[b][a]) {                    answer = min(answer, abs(bfs(a, Pair(a, b)) - bfs(b, Pair(a, b))))                    isChecked[a][b] = true                    isChecked[b][a] = true                }            }        }        return answer    }    private fun bfs(s: Int, blockSet: Pair&lt;Int, Int&gt;): Int {        var towerCounter = 0        val isVisited = Array(101) { false }        val q = ArrayDeque&lt;Int&gt;()        q.add(s)        isVisited[s] = true        while(!q.isEmpty()) {            val cur = q.first()            q.removeFirst()            towerCounter++            node[cur].forEach { n -&gt;                if(!isVisited[n] &amp;&amp; blockSet != Pair(cur, n) &amp;&amp; blockSet != Pair(n, cur) ) {                    isVisited[n] = true                    q.add(n)                }            }        }        return towerCounter    }    }"
  },
  
  {
    "title": "(프로그래머스 | Kotlin) - 호텔 대실",
    "url": "/posts/KotlinAlgorithm8/",
    "categories": "CS, 알고리즘 문제",
    "tags": "Kotlin, Algorithm, 알고리즘, 프로그래머스",
    "date": "2023-11-21 12:00:00 +0900",
    





    
    "snippet": "해결 방법이 문제의 핵심은 그리디 알고리즘을 이용하는 것이다. 우선 문제에서 예약 시작 시간과 종료 시간이 여러 개 담긴 배열을 줬으므로 해당 예약 시작 시간을 기준으로 배열을 정렬시킨다. 그리고 정렬된 배열을 가지고 반복문을 돌려서 현재 원소의 예약 시작 시간보다 10분 더 적은 종료 시간이 있는 방 번호를 찾는다.예를 들어서 현재 예약이 잡힌 방의...",
    "content": "해결 방법이 문제의 핵심은 그리디 알고리즘을 이용하는 것이다. 우선 문제에서 예약 시작 시간과 종료 시간이 여러 개 담긴 배열을 줬으므로 해당 예약 시작 시간을 기준으로 배열을 정렬시킨다. 그리고 정렬된 배열을 가지고 반복문을 돌려서 현재 원소의 예약 시작 시간보다 10분 더 적은 종료 시간이 있는 방 번호를 찾는다.예를 들어서 현재 예약이 잡힌 방의 갯수를 n 개라고 가정하자. 그럼 방의 번호는 현재 1 번부터 n 번까지 존재한다. 정렬된 배열의 반복문을 돌렸을 때 가장 좋은 예약 방법은 기존에 존재하는 방에 예약을 거는 것이다. 그렇게 하기 위해선 현존하는 방들 중에서 마지막으로 예약된 시간대의 종료 시간이 현재 원소의 시작 시간보다 10분 더 적어야 한다.그래서 모든 방을 탐색해서 예약이 가능한 방을 찾으면 해당 방의 예약 현황을 업데이트(마지막 예약의 종료 시간)한다. 업데이트가 완료되면 다음 원소로 넘어가서 이전과 똑같은 작업을 한다.만약 예약 가능한 방이 존재하지 않는다면 현존하는 방으로는 예약을 할 수 없다는 뜻이므로 이때는 방을 새로 생성한다. 현존하는 방의 갯수가 n 개라면 이때 방을 새로 생성해서 n + 1 개가 된다.​설명왜 종료 시간이 아닌 시작 시간을 기준으로 배열을 정렬시켜야 하는가?종료 시간을 기준으로 정렬을 했다 가정해보자. 다음 예시는 임의로 만들어본 예시다. 해당 그림은 예약 종료 시간을 기준으로 위에서 아래로 오름차순 정렬을 한 상태를 나타낸다.여기서 설명했던 해결 방법대로 예약 시간들을 배치하면 다음과 같다. 해당 결과로 방이 세 개 생성된다. 뭔가 이상하지 않은가? 뭔가 듬성듬성 배치되어 방이 세 개나 사용됐다.12:14 ~ 12:34 시간대를 첫 번째 방이 아닌 두 번째 방에 배치하고 11:20 ~ 14:20 시간대를 첫 번째 방에 배치하면 방을 세 개로 사용하지 않고 두 개만 가지고 모든 예약 처리를 할 수 있다. 이런 반례가 있어서 종료 시간을 기준으로 정렬하는 것은 옳지 않다.​전체 코드class Solution {    fun solution(bookTime: Array&lt;Array&lt;String&gt;&gt;): Int {        val bookTimeMinute = bookTime            .map { arrayOf(it[0].toMinute(), it[1].toMinute()) }            .sortedBy { it[0] }        val availableTime = ArrayList&lt;Int&gt;()        for(t in bookTimeMinute) {            var renewedRoom: Int? = null            for((roomNumber, lastTime) in availableTime.withIndex()) {                if(lastTime &lt;= t[0]) {                    availableTime[roomNumber] = t[1]+10                    renewedRoom = roomNumber                    break                }            }            renewedRoom ?: availableTime.add(t[1]+10)        }        return availableTime.size    }    private fun String.toMinute(): Int {        val sum: Int        this            .split(':')            .map { it.toInt() }            .let { sum = it[0] * 60 + it[1] }        return sum    }}"
  },
  
  {
    "title": "(프로그래머스 | Kotlin) - 매칭 점수",
    "url": "/posts/KotlinAlgorithm7/",
    "categories": "CS, 알고리즘 문제",
    "tags": "Kotlin, Algorithm, 알고리즘, 프로그래머스",
    "date": "2023-11-19 21:00:00 +0900",
    





    
    "snippet": "해결 방법정말 보자마자 머리가 지끈거리는 문제였다. 카카오 코테 문제를 풀어보면서 문자열 처리 로직을 많이 작성했었는데 설마 html 형식을 통째로 주는 건 상상도 못했다. 필요한 건 크게 url, 키워드, 외부 링크, 이렇게 세 가지다.여기서 문제는 해당 세 가지를 구하기 위해서 정규식을 사용해야 하는데 나는 정규식을 사용할 때 항상 검색해서 복붙한...",
    "content": "해결 방법정말 보자마자 머리가 지끈거리는 문제였다. 카카오 코테 문제를 풀어보면서 문자열 처리 로직을 많이 작성했었는데 설마 html 형식을 통째로 주는 건 상상도 못했다. 필요한 건 크게 url, 키워드, 외부 링크, 이렇게 세 가지다.여기서 문제는 해당 세 가지를 구하기 위해서 정규식을 사용해야 하는데 나는 정규식을 사용할 때 항상 검색해서 복붙한 게 전부여서 식을 어떻게 작성해야 하는지 몰랐다. 그래서 검색을 해서 몇몇 정규식을 참고했다.1. 현재 페이지의 URL\"(&lt;meta property=\\\"og:url\\\" content=\\\"(\\\\S*)//(\\\\S*)\\\"/&gt;)\"페이지의 url 을 구할 때 중요한 점은 문제에서 준 양식과 정확히 일치해야 한다는 것이다. 보니까 url 부분을 포함해서 조금이라도 양식에 벗어나는 예제가 있는 것 같다.2. html 페이지 내 키워드 수\"[^a-zA-Z]\"키워드 갯수는 알파벳이 아닌 문자로 둘러싸인 키워드를 찾으면 되므로 알파벳이 아닌 문자를 기준으로 split 해서 키워드 갯수를 구하는 방식으로 구현했다.3. 외부링크 갯수\"&lt;a href=\\\"https://(.+?)\\\"&gt;\"현재 페이지의 url 구하는 것처럼 외부 링크 태그 양식을 정확히 지켜야 한다. 외부링크는 여러 개 존재할 수 있기 때문에 하나만 find 하면 안되고 findAll 해야 한다.​전체 코드위의 세 가지를 구현하기 위해 필요한 정규식만 만들줄 알면 나머지는 구현하는 데 크게 어렵지 않다.class Solution {    fun solution(word: String, pages: Array&lt;String&gt;): Int {        var answer = 0        var maxScore = -1.0        val pageInfo = ArrayList&lt;WebInfo&gt;()        val pageIndex = mutableMapOf&lt;String, Int&gt;()        pages.forEach { html -&gt;            getSelfUrl(html)?.let { selfUrl -&gt;                val keyword = getKeywordCount(html.lowercase(), word.lowercase())                val extLink = getLinkCount(html)                pageIndex[selfUrl] = pageInfo.size                pageInfo.add(WebInfo(selfUrl, keyword, extLink, mutableSetOf(), pageInfo.size))            }        }        pageInfo.forEach { webInfo -&gt;            webInfo.extLink.forEach { extLink -&gt;                if(pageIndex.containsKey(extLink)) {                    pageInfo[pageIndex[extLink]!!].linker.add(webInfo.url)                }            }        }        pageInfo.forEachIndexed { i, webInfo -&gt;            var webScore = webInfo.basic.toDouble()            webInfo.linker.forEach { linker -&gt;                webScore += pageInfo[pageIndex[linker]!!].getSingleLinkScore()            }            if(maxScore &lt; webScore) {                maxScore = webScore                answer = i            }        }        return answer    }    private fun getSelfUrl(html: String): String? {        var urlTag: String? = null        Regex(\"(&lt;meta property=\\\"og:url\\\" content=\\\"(\\\\S*)//(\\\\S*)\\\"/&gt;)\")            .find(html)            ?.value            ?.let {                urlTag = it.split(\" \")[2].split(\"\\\"\")[1]            }        return urlTag    }    private fun getKeywordCount(html: String, keyword: String): Int {        return html            .split(Regex(\"[^a-zA-Z]\"))            .filter { it == keyword }            .size    }    private fun getLinkCount(html: String): MutableSet&lt;String&gt; {        val linker = mutableSetOf&lt;String&gt;()        Regex(\"&lt;a href=\\\"https://(.+?)\\\"&gt;\")            .findAll(html)            .forEach { linkTag -&gt;                linker.add(linkTag.value.split(\" \")[1].split(\"\\\"\")[1])            }        return linker    }    data class WebInfo(        val url: String,        val basic: Int,        val extLink: MutableSet&lt;String&gt;,        val linker: MutableSet&lt;String&gt;,        val index: Int    ) {        fun getSingleLinkScore(): Double {            return if (extLink.size == 0) 0.0 else basic.toDouble() / extLink.size        }    }}​참조외부링크 정규식 참고키워드 갯수와 페이지 URL 정규식 참고"
  },
  
  {
    "title": "(프로그래머스 | Kotlin) - 수식 최대화",
    "url": "/posts/KotlinAlgorithm6/",
    "categories": "CS, 알고리즘 문제",
    "tags": "Kotlin, Algorithm, 알고리즘, 프로그래머스",
    "date": "2023-11-15 12:00:00 +0900",
    





    
    "snippet": "해결 방법뭔가 풀이 방법이 다양할 것 같은 문제인데 나는 재귀를 이용해서 해결했다. 연산 기호가 최대 세 개인데 연산 우선순위를 리스트로 표현했다. 예를 들어서 표현식에서 사용된 연산 기호가 * - , 2개라면 만들 수 있는 우선순위 조합은 2개, [[*, -], [-, *]]  이렇게 리스트로 표현이 가능하다. 인덱스가 클수록 연산 우선순위가 높다는...",
    "content": "해결 방법뭔가 풀이 방법이 다양할 것 같은 문제인데 나는 재귀를 이용해서 해결했다. 연산 기호가 최대 세 개인데 연산 우선순위를 리스트로 표현했다. 예를 들어서 표현식에서 사용된 연산 기호가 * - , 2개라면 만들 수 있는 우선순위 조합은 2개, [[*, -], [-, *]]  이렇게 리스트로 표현이 가능하다. 인덱스가 클수록 연산 우선순위가 높다는 뜻이다.이런 식으로 만들 수 있는 연산 우선순위를 모두 만들고 모든 경우에 대해 식을 계산하고 결과값을 비교해서 가장 큰 값을 리턴하면 문제 해결이 가능하다. 그런데 문제는 식을 계산하는 방법이다. 여기서 풀이 방법이 다양하게 갈릴 것 같은데 내가 푼 방법은 다음과 같다.​1. 나올 수 있는 연산 우선순위 조합 모두 구하기\"100-200*300-500+20\" 예제를 예시로 생각해보자. 사용된 연산자는 * - + 총 세 개, 나올 수 있는 연산 우선순위 조합은 총 여섯 개다. 우선 이 여섯 개를 구하는 알고리즘을 짜야 한다. 이는 순열 알고리즘을 이용해서 구하면 된다.제네릭 함수, 리스트 확장함수, 연산자 함수를 응용한 깔끔한 순열 알고리즘이다. 자세한 원리는 링크를 통해서 확인하면 된다. 개인적으로 가장 깔끔한 순열 알고리즘인 것 같다.private fun &lt;T&gt; permutation(sub: List&lt;T&gt;, fin: List&lt;T&gt; = listOf()): List&lt;List&lt;T&gt;&gt; {    return if(sub.isEmpty()) listOf(fin)    else sub.flatMap { permutation(sub - it, fin + it) }}permutation(listOf('*', '-', '+'))// [*, +, -]// [*, -, +]// [+, *, -]// [+, -, *]// [-, *, +]// [-, +, *]​2. 재귀를 이용한 식 계산permutation(existingOperator.toList()).forEach {    answer = max(answer, abs(rec(expression, it.toList())))}rec : 식을 계산한 결과값을 반환하는 재귀 함수이고 계산할 식이 담긴 문자열과 연산 우선순위 정보를 인자로 넘긴다. 그리고 계산 결과의 절대값으로 비교를 해야 하므로 abs 로 감싸준다. 이렇게 메인 함수에서 틀을 잡는다.다음은 rec 함수 구현 부분이다. permutation 결과값의 첫 번째 값이 [*, +, -] 이므로  rec 함수로 넘기는 인자는 \"100-200*300-500+20\" , [*, +, -] 다. 연산자 우선순위 리스트의 인덱스가 높을수록 연산 우선순위가 높다고 설정했기 때문에 - -&gt; + -&gt; *  순서로 계산을 처리한다.해당 순서로 계산을 처리하기 위해선 연산 우선순위가 낮은순으로 연산자를 기준으로 split 을 하고, split 의 결과값으로 만들어진 리스트 내의 모든 식의 결과값들을 현재 기준이 되는 연산자로 계산을 해주면 된다. 글만 봐서는 바로 이해가 되지 않으니 예시를 살펴보자.​1. 연산 우선순위가 가장 낮은 연산자는 * 이므로 이 연산자를 기준으로 split 을 한다\"100-200*300-500+20\" -&gt; [\"100-200\", \"300-500+20\"]식이 두 개로 분리가 됐다. \"100-200\" 을 A 라 하고 \"300-500+20\" 을 B 라고 한다면 A * B 가 rec 함수의 반환값이 된다. 따라서 A B 를 먼저 계산을 해야 한다. 여기서 rec 함수를 이용해서 A B 의 결과값을 받아오면 된다. 그리고 *  연산자를 기준으로 분리된 식들이기 때문에 이제 처리해야 할 연산자는 + -  둘뿐이다.​2. split 으로 분리된 식들의 결과값을 rec 재귀호출로 구한다.따라서 A = rec(\"100-200\", [\"+\", \"-\"])  , B = rec(\"300-500+20\", [\"+\", \"-\"]) 이 된다. 이제 재귀호출로  A B 를 구하는 rec 함수를 살펴보자.  * 연산자를 기준으로 처리했을 때와 마찬가지로 이번에는 + 연산자를 기준으로 split 한다.A -&gt; \"100-200\" -&gt; [\"100-200\"]B -&gt; \"300-500+20\" -&gt; [\"300-500\", \"20\"]이제 - 연산자에 해당되는 식만 남았다. 이것들도 rec 함수를 재귀호출하여 계산 결과를 구한다. 각각 rec(\"100-200\", [\"-\"]) rec(\"300-500\", [\"-\"]) rec(\"20\", [\"-\"]) 를 C D E 라고 하면 A = C , B = D + E 가 된다. 그리고 마지막에는 A * B 가 최종 반환된다.​정리  연산 우선순위대로 식을 계산하기 위해서는 연산 우선순위가 가장 낮은 연산자부터 해당 연산자를 기준으로 식을 split 한다. split 을 하면 분리된 식들로 구성된 리스트가 반환된다.  분리된 식들의 계산 결과를 rec 함수를 재귀호출하여 구한다.  분리된 식들의 계산 결과들을 현재 split  기준이 되는 연산자로 계산하여 반환한다.  결국 가장 낮은 연산 우선순위의 연산자부터 가장 큰 우선순위의 연산자 순서로 split 및 재귀호출을 하게 되면 결국 재귀호출의 특성 때문에 계산 순서가 연산 우선순위가 가장 높은 연산자에서 가장 낮은 연산자 순으로 처리가 된다.​rec 함수 코드private fun rec(expression: String, splitOperators: List&lt;Char&gt;): Long {    var sum: Long    getNextSplitOperatorIndex(expression, splitOperators)?.let { i -&gt;        val splitOperator = splitOperators[i]        val splitExpression = expression.split(splitOperator)        sum = rec(splitExpression.first(), splitOperators.subList(i + 1, splitOperators.size))        splitExpression.subList(1, splitExpression.size).forEach {            sum = splitOperator calculate Pair(sum, rec(it, splitOperators.subList(i + 1, splitOperators.size)))        }        return sum    }    return expression.toLong()}private fun getNextSplitOperatorIndex(expression: String, splitOperators: List&lt;Char&gt;): Int? {    var i = 0    while(i &lt; splitOperators.size &amp;&amp; !expression.contains(splitOperators[i])) { i++ }    return if (i == splitOperators.size) null else i}​연산 우선순위를 고려한 rec 함수 처리 과정​전체 코드fun solution(expression: String): Long {    var answer: Long = 0    val existingOperator = mutableSetOf&lt;Char&gt;()    listOf('*', '+', '-').forEach {        if (expression.contains(it)) { existingOperator.add(it) }    }    permutation(existingOperator.toList()).forEach {        answer = max(answer, abs(rec(expression, it.toList())))    }    return answer}private fun rec(expression: String, splitOperators: List&lt;Char&gt;): Long {    var sum: Long    getNextSplitOperatorIndex(expression, splitOperators)?.let { i -&gt;        val splitOperator = splitOperators[i]        val splitExpression = expression.split(splitOperator)        sum = rec(splitExpression.first(), splitOperators.subList(i + 1, splitOperators.size))        splitExpression.subList(1, splitExpression.size).forEach {            sum = splitOperator calculate Pair(sum, rec(it, splitOperators.subList(i + 1, splitOperators.size)))        }        return sum    }    return expression.toLong()}private fun getNextSplitOperatorIndex(expression: String, splitOperators: List&lt;Char&gt;): Int? {    var i = 0    while(i &lt; splitOperators.size &amp;&amp; !expression.contains(splitOperators[i])) { i++ }    return if (i == splitOperators.size) null else i}private fun &lt;T&gt; permutation(sub: List&lt;T&gt;, fin: List&lt;T&gt; = listOf()): List&lt;List&lt;T&gt;&gt; {    return if(sub.isEmpty()) listOf(fin)    else sub.flatMap { permutation(sub - it, fin + it) }}private infix fun Char.calculate(pair: Pair&lt;Long, Long&gt;): Long {    return when (this) {        '*' -&gt; pair.first * pair.second        '+' -&gt; pair.first + pair.second        '-' -&gt; pair.first - pair.second        else -&gt; throw IllegalArgumentException()    }}"
  },
  
  {
    "title": "Kotlin Generic (1) 제네릭 클래스와 함수, 그리고 변성",
    "url": "/posts/Kotlin-Generic/",
    "categories": "CS, 프로그래밍 언어",
    "tags": "Kotlin, Java, Generic, 제네릭",
    "date": "2023-11-09 12:00:00 +0900",
    





    
    "snippet": "Kotlin도 Java의 제네릭 기능을 제공한다.  “Classes in Kotlin can have type parameters, just like in Java:” - Kotlin 공식 문서코틀린의 클래스는 자바와 마찬가지로 타입 파라미터를 가질 수 있습니다. 제네릭을 사용함으로써 컴파일 타임에 타입 안전성을 관리할 수 있고 여러 타입에 대응하여 ...",
    "content": "Kotlin도 Java의 제네릭 기능을 제공한다.  “Classes in Kotlin can have type parameters, just like in Java:” - Kotlin 공식 문서코틀린의 클래스는 자바와 마찬가지로 타입 파라미터를 가질 수 있습니다. 제네릭을 사용함으로써 컴파일 타임에 타입 안전성을 관리할 수 있고 여러 타입에 대응하여 코드를 재사용하는 이점을 얻을 수 있습니다.코틀린 역시  &lt;&gt; 기호를 이용한 제네릭 기능을 제공합니다. 다음 Box 클래스는 제네릭을 사용하여 만들어졌기 때문에  Int , String, Float 등의 다양한 타입을 가질 수 있습니다.class Box&lt;T&gt;(t: T) {    var value = t}val boxInt: Box&lt;Int&gt; = Box&lt;Int&gt;(1)val boxString: Box&lt;String&gt; = Box&lt;String&gt;(\"empty\")val boxFloat: Box&lt;Float&gt; = Box&lt;Float&gt;(2.0F)위의 예시를 통해서 제네릭(Generic)은 단순히 하나의 타입으로 고정하는 것이 아닌 다양한 타입을 수용할 수 있는 하나의 일반화(Generalization)된 타입 파라미터라고 할 수 있습니다.위의 예제에서는 타입 파라미터 정의를 T 로 했는데 이는 제네릭을 사용할 때 무조건 T 를 사용해야 한다는 뜻이 아닙니다. 제네릭에서 사용되는 기호는 정해진 것이 아닌 사용자가 직접 정의합니다. 그래서 상황에 따라 네이밍을 하면 됩니다.            유형      의미                  &lt;T&gt;      Type              &lt;E&gt;      Element              &lt;K&gt;      Key              &lt;V&gt;      Value              &lt;N&gt;      Number      ​타입 안전성제네릭을 사용하지 않은 클래스의 경우는?Animal 추상 클래스가 있고, 해당 추상 클래스의 구현체인 Tiger,  Lion 이렇게 두 개의 클래스가 존재하는 상황이라고 가정하겠습니다. 동물의 정보와 관련된 클래스를 정의했으므로 이제 동물들을 관리하는 동물원, Zoo 클래스를 정의합니다.abstract class Animalabstract class Mammalia: Animal()class Tiger: Mammalia()class Lion: Mammalia()class Zoo {    private val animals = mutableListOf&lt;Animal&gt;()    fun getLast(): Animal {        return animals.last()    }    fun getFirst(): Animal {        return animals.first()    }    fun add(animal: Animal) {        animals.add(animal)    }}메인 함수에서 호랑이를 동물원에 추가하고 다시 꺼내오는 작업을 했을 때 Tiger로 받으려면 다운캐스팅이기 때문에 변환 타입을 명시해야 합니다.val zoo = Zoo()zoo.add(Tiger())val tiger: Tiger = zoo.getLast() as Tiger그런데 동물 리스트에서 데이터를 꺼내올 때 해당 데이터가 무조건 Tiger 라는 보장이 없습니다. 데이터를 삽입할 때 Tiger 가 아닌 Lion 을 넣을수도 있기 때문입니다. 그래서 as? 를 이용하거나 엘비스 연산자 ?: 를 이용해서 예외에 대응하는 방법이 있습니다만…​제네릭 클래스로 수정하자제네릭을 이용한다면 타입 미스매치 발생을 방지하고 코드 가독성도 좋게 만들 수 있습니다. 동물들을 관리하는 Zoo 클래스에 타입 파라미터 T 를 정의하여 수정하면 클래스 생성부터  Tiger 타입 지정이 가능합니다.이렇게 제네릭 클래스로 만들면 컴파일 타임에 타입 오류를 찾아낼 수 있고 Tiger 를 관리하는 동물원 Zoo 로 관리가 가능합니다. 그래서 as 를 사용해서 캐스팅할 타입을 명시하지 않아도 깔끔하고 안전하게 데이터를 가져올 수 있습니다.class Zoo&lt;T&gt; {    private val animals = mutableListOf&lt;T&gt;()    fun getLast(): T {        return animals.last()    }    fun getFirst(): T {        return animals.first()    }    fun add(animal: T) {        animals.add(animal)    }}val zoo = Zoo&lt;Tiger&gt;()zoo.add(Tiger())val tiger: Tiger = zoo.getLast()​변성변성(Variance)변성(Variance)은 제네릭 클래스끼리의 상속 관계를 나타내는 개념입니다. 변성은 크게 공변, 반공변, 무공변 이렇게 세 가지로 나눌 수 있는데 해당 세 가지의 정의는 다음과 같습니다.            유형      의미                  공변(Covariance)      Tiger 가 Mammalia 의 서브타입이라면 Zoo&lt;Tiger&gt; 는 Zoo&lt;Mammalia&gt; 의 서브타입이다.              반공변(Contravariance)      Tiger 가 Mammalia 의 서브타입이라면 Zoo&lt;Mammalia&gt; 는 Zoo&lt;Tiger&gt; 의 서브타입이다.              무공변(Invariance)      공변도 아니고 반공변도 아닌 상태      ​제네릭 클래스는 기본적으로 무공변동물원 예시 코드를 조금 수정하겠습니다. 다음과 같이 Tiger Lion 의 상위타입인 Mammalia 를 타입 파라미터로 가지는 제네릭 클래스를 생성해서 거기에 Tiger Lion 클래스를 add 해보겠습니다.val zooWithMammalia = Zoo&lt;Mammalia&gt;()zooWithMammalia.add(Tiger())zooWithMammalia.add(Lion())Mammalia 를 타입 파라미터로 가지는 Zoo&lt;Mammalia 의 add 메서드는 파라미터가 animal: Mammalia 로 설정이 되고 여기에 인자로 Tiger , Lion 이 온다면 서로 상속 관계이기 때문에 컴파일 및 실행에 문제가 없습니다.fun add(animal: T) { // animal: Mammalia    animals.add(animal)}이렇게 단일 동물을 다른 동물원에 추가하는 데 문제가 발생하지 않지만 동물원 자체를 다른 동물원에 합치는 경우는 어떨까요? 다음과 같이 동물원 자체를 합치는 메서드를 추가로 작성해보겠습니다.fun mergeOtherZoo(zoo: Zoo&lt;T&gt;) {    this.animals.addAll(zoo.animals)}그리고 Zoo&lt;Mammalia&gt; 에 Zoo&lt;Tiger&gt; 를 병합시켜보겠습니다. 결과는 단일 동물을 추가할 때와 달리 타입 미스매치가 발생합니다.val zooWithTigers = Zoo&lt;Tiger&gt;()val zooWithMammalia = Zoo&lt;Mammalia&gt;()zooWithTigers.add(Tiger())zooWithMammalia.mergeOtherZoo(zooWithTigers) // Type mismatch 발생분명 Zoo&lt;Mammalia&gt; 에 Tiger() 를 추가하는 것은 문제가 없었는데 Zoo&lt;Tiger&gt; 를 추가하는 것에는 문제가 발생합니다. 이는 제네릭 클래스는 기본적으로 무공변 상태이기 때문에 아무런 관계가 없는  Zoo&lt;Mammalia&gt; 와 Zoo&lt;Tiger&gt; 는 병합 시도시 오류가 발생할 수밖에 없는 겁니다.​공변으로 전환이를 해결하기 위해서는 무공변인 상태를 공변으로 전환해야 합니다. 전환하는 방법은 간단합니다. 병합하는 메서드의 타입 파라미터 왼쪽에 out 이라는 키워드를 추가하면 됩니다. 이 결과로 본인의 하위타입을 수용할 수 있고 타입 미스매치 오류가 사라지면서 정상 실행이 됩니다.fun mergeOtherZoo(zoo: Zoo&lt;out T&gt;) {    this.animals.addAll(zoo.animals)}​공변으로 전환시 주의할 점무공변 상태에서 공변으로 전환을 하면 제네릭 클래스 간 상속 관계가 생겨서 인자로 넘길 수 있게 되지만 주의할 점이 있습니다. 만약에 mergeOtherZoo 메서드 내부 코드가 반대로 인자로 받은 동물원에 기존 동물원을 합치는 경우면 어떻게 될까요?타입 미스매치가 발생하게 됩니다. out 을 사용한 시점에서 인자로 받는 zoo 는 자신을 인자로 필요로 한 클래스의 서브 타입일 수 있기 때문에 하위타입에 상위타입의 데이터를 넣는 동작은 타입 안전성을 해칠 수 있습니다.fun mergeOtherZoo(zoo: Zoo&lt;out T&gt;) {    zoo.animals.addAll(this.animals)\t\t}  out 키워드를 이용해서 공변 상태로 전환할 때는 파라미터인  zoo  가 본인의 데이터를 넘겨주는 쪽으로 동작을 처리하면 됩니다.​반공변으로 전환out 을 이용해서 공변 상태로 만들었을 때는 zoo 가 this 의 하위 타입이 되는 것이 가능하므로 zoo 에 this 데이터를 가져가는 동작은 타입 안전성을 해칠 수 있습니다. 이러한 동작을 처리하려면 공변이 아닌 반공변으로 설정하는 것이 좋습니다.반공변은 말 그대로 공변의 반대입니다. 여기서는 서브타입이었던 클래스가 반대로 상위타입이 됩니다. 그래서 공변이었을 때 불가능했던 파라미터 zoo 에 this 의 데이터를 가져가는 동작이 반공변에선 가능합니다.fun mergeOtherZoo(zoo: Zoo&lt;in T&gt;) {    zoo.animals.addAll(this.animals)}  in 키워드를 이용해서 반공변 상태로 전환할 때는 파라미터인 zoo 가 this 의 데이터를 소비하는 쪽으로 동작을 처리하면 됩니다.​변성 선언 위치변성 선언은 파라미터에서 설정하는 것 이외에도 클래스 전체를 설정하는 것도 가능합니다. 만약에 클래스 전체를 공변하게 만들고 싶거나 반공변하게 만들고 싶다면 다음과 같이 클래스 헤더에 설정하면 됩니다. 이렇게 하면 예시로 사용했던 mergeOtherZoo 메서드 파라미터로 Zoo 클래스를 받을 필요가 없어집니다.class Zoo&lt;out T&gt; {}class Zoo&lt;in T&gt; {}// 클래스 자체를 공변 설정하지 않았을 때fun mergeOtherZoo(zoo: Zoo&lt;T&gt;) {    this.animals.addAll(zoo.animals)}// 파라미터로 클래스가 아닌 리스트로 수정fun mergeOtherZoo(zoo: List&lt;T&gt;) {    this.animals.addAll(zoo)}공변 설정만약 클래스를 out (공변) 설정했다면 다음 두 메서드에서 오류가 발생합니다.fun add(animal: T) {    animals.add(animal)}fun mergeOtherZoo(zoo: List&lt;T&gt;) {    this.animals.addAll(zoo)}// Type parameter T is declared as 'out' but occurs in 'in' position in type T다음과 같이 메서드 파라미터에 공변을 설정했을 때를 보면 zoo 가 데이터를 넘겨주는 역할을 해야 한다고 언급했습니다. 그래서 클래스 자체를 공변으로 설정했다면 내부 메서드도 전부 데이터를 넘기는(getter) 동작으로 설정해야 합니다. 그래서 getLast() getFirst() 는 별다른 오류가 없는 겁니다.fun mergeOtherZoo(zoo: Zoo&lt;out T&gt;) {    zoo.animals.addAll(this.animals)\t\t}반공변 설정이번엔 클래스를 in (반공변) 설정했다면 다음 두 메서드에서 오류가 발생합니다.fun getLast(): T {    return animals.last()}fun getFirst(): T {    return animals.first()}// Type parameter T is declared as 'in' but occurs in 'out' position in type T이번엔 공변으로 설정했을 때와 달리 getter 역할을 수행하는 메서드에서 오류가 발생했습니다. 메서드 파라미터에 in 반공변을 설정했을 때를 보면 zoo 가 데이터를 넘기는 것이 아닌 오히려 데이터를 받는 입장인 것을 알 수 있습니다. 그래서 이때는 클래스 내 메서드는 데이터를 받는 쪽으로 처리하면 됩니다.fun mergeOtherZoo(zoo: Zoo&lt;in T&gt;) {    zoo.animals.addAll(this.animals)}​강제 변성위의 예시를 보면 알 수 있듯이, 제네릭은 타입 안전성을 굉장히 신경을 씁니다. 그래서 in 혹은 out 으로 했을 때 안전성을 해칠 수 있는 타입 파라미터를 오류 메세지를 보여주는 것으로 막습니다. 그런데 이를 무시하고 강제로 설정을 해야 하는 경우가 있을 수 있습니다.그래서 코틀린은 @UnsafeVariance 라는 어노테이션을 제공합니다. 타입 파라미터에 붙여서 사용하면 변성 설정으로 인해 발생할 수 있는 위험성을 감수하고 강제로 실행시킬 수 있습니다.만약에 클래스 자체를 out 으로 설정했다면 add mergeOtherZoo 메서드의 타입 파라미터에서 오류가 발생합니다. 이때 이 어노테이션을 사용하면 강제로 실행할 수 있습니다. 물론 런타임에 발생된 오류에 대한 처리는 어노테이션을 설정한 개발자의 몫입니다.fun add(animal: @UnsafeVariance T) {    animals.add(animal)}fun mergeOtherZoo(zoo: List&lt;@UnsafeVariance T&gt;) {    this.animals.addAll(zoo)}​범위 지정타입으로 받을 수 있는 범위 제한지금까지 동물원을 예시로 설명을 드렸습니다. 그런데 다음과 같이 동물이랑 전혀 상관없는 Int 를 타입으로 넘겨도 객체 생성에 문제가 없습니다. 그래서 넘기는 타입 파라미터의 범위를 지정해줘야 합니다.&lt;T: Animal&gt; 이런 식으로 범위를 지정하면 됩니다. 설정하면 Animal  범위 내의 타입들만 넘길 수 있습니다.fun main() {    val zooWithNotAnimal = Zoo&lt;Int&gt;() // 오류 없음}class Zoo&lt;T&gt; {}fun main() {    val zooWithNotAnimal = Zoo&lt;Int&gt;() // Type argument is not within its bounds.}class Zoo&lt;T: Animal&gt; {}​제네릭 클래스뿐만 아니라 제네릭 함수도 있다.예시로 사용한 동물원은 제네릭 클래스입니다. 제네릭 클래스는 클래스 이름 오른쪽에 타입을 지정합니다. 반면에 클래스가 아닌 함수를 제네릭으로 정의할 때는 fun 키워드와 함수 이름 사이에 타입 파라미터를 넣어줘야 합니다.fun List&lt;T&gt;.isNone(): Boolean {    return this.isEmpty()}// 틀린 코드: Unresolved reference: Tfun &lt;T&gt; List&lt;T&gt;.isNone(): Boolean {    return this.isEmpty()}// 맞는 코드: fun 키워드 다음에 타입 파라미터를 적어줘야 함제네릭 함수를 잘만 활용하면 유틸성 함수들을 마구 찍어낼 수 있습니다. 코틀린 자체에서 제공하는 여러 유용한 확장함수들도 제네릭 함수로 정의되어 제공됩니다. 대표적으로 Collection 과 관련된 파일을 보면 유용한 기능의 함수가 제네릭으로 정의되어 있는 것을 알 수 있습니다.​마무리지금까지 예시를 통해서 제네릭을 이용한 클래스와 함수가 어떻게 정의되고 어떤 특징을 가지고 있는지 설명을 해봤습니다. 단순히 하나의 클래스나 함수를 제네릭으로 정의함으로써 코드 재사용성을 높일 수 있고 변성을 통한 타입 안전성도 얻을 수 있다는 것을 알았습니다.설명을 위해 사용된 코드는 단순히 제네릭의 특징을 직관적으로 보여주기 위해서 굉장히 단순하고 허술하게 작성을 했으니 이 점 이해해주시면 감사하겠습니다. 혹시라도 틀린 내용이 있어서 알려주신다면 바로 수정하겠습니다. 감사합니다 :)혹시 괜찮은 코틀린 강의를 찾고 계시다면 하나 추천드리겠습니다. 개인적으로 굉장히 만족하면서 들었던 강의입니다.인프런 - 코틀린 고급편​참조Wikipedia 변성인프런 - 코틀린 고급편"
  },
  
  {
    "title": "Android BuildConfig 적용 안되는 현상",
    "url": "/posts/Android-BuildConfig/",
    "categories": "Android, 이슈",
    "tags": "Android, BuildConfig",
    "date": "2023-11-01 12:00:00 +0900",
    





    
    "snippet": "빌드를 다시 해봐도 BuildConfig 가 없음BuildConfig 는 보통 노출되면 안되는 값을 저장할 때 사용되곤 합니다. 그래서 프로젝트를 몇번 해봤다면 해당 기능을 사용해봤을 겁니다. 보통 서버 주소나 API 키와 같은 중요한 값들을 로컬 프로퍼티에 저장을 하고 재빌드를 해서 BuildConfig 를 참조하게 됩니다. 그런데 재빌드를 했음에도...",
    "content": "빌드를 다시 해봐도 BuildConfig 가 없음BuildConfig 는 보통 노출되면 안되는 값을 저장할 때 사용되곤 합니다. 그래서 프로젝트를 몇번 해봤다면 해당 기능을 사용해봤을 겁니다. 보통 서버 주소나 API 키와 같은 중요한 값들을 로컬 프로퍼티에 저장을 하고 재빌드를 해서 BuildConfig 를 참조하게 됩니다. 그런데 재빌드를 했음에도 불구하고 BuildConfig 가 참조되지 않는 경우가 있었을 겁니다.AGP 8.0 부터 BuildConfig 는 기본으로 적용되지 않음빌드 퍼포먼스 향상을 위해서 그래들 플러그인 8.0 버전부터는 BuildConfig 생성이 되지 않도록 변경됐습니다.Android 공식문서 내용 발췌  Starting with AGP 8.0, the default values for these flags have changed to improve build performance. To get help adjusting your code to support some of these changes, use the AGP Upgrade Assistant (Tools &gt; AGP Upgrade Assistant). The Upgrade Assistant guides you through updating your code to accommodate the new behavior or setting flags to preserve the previous behavior.            Flag      New default value      Previous default value      Notes                  android.defaults.buildfeatures.buildconfig      false      true      AGP 8.0 doesn’t generate BuildConfig by default. You need to specify this option using the DSL in the projects where you need it.      Medium : Android Developers 내용 발췌  If you call the BuildConfig class from your module code, you need to enable buildConfig in the android {} block in your module’s build.gradle.kts file. Otherwise, the BuildConfig file isn’t automatically generated anymore.​BuildConfig 사용을 명시해야 사용 가능따라서 그래들 플러그인 버전이 8.0 이상이라면 해당 기능을 사용하기 위해서 그래들 파일에 직접 명시를 해줘야 합니다. ViewBinding DataBinding 을 사용하기 위해서 그래들 파일에 명시해주는 거랑 똑같다고 보시면 됩니다.// Module build.gradle.ktsandroid {  buildFeatures {    buildConfig = true  }}​참조Android 공식문서Medium : Android Developers"
  },
  
  {
    "title": "Android 구글 로그인 구현하기",
    "url": "/posts/Android-Google-Login/",
    "categories": "Android, 라이브러리",
    "tags": "Android, 소셜 로그인, 구글, Google Login",
    "date": "2023-10-31 22:00:00 +0900",
    





    
    "snippet": "사전 준비안드로이드에서 구글 로그인을 구현하기 위해서는 준비해야 될 게 몇 가지가 있습니다. 구글 클라우드에 들어가서 OAuth 클라이언트 아이디를 만들고 그 과정에서 본인의 앱을 등록해야 합니다. 그러므로 구체적으로 무엇을 먼저 준비해야 하는지 알아보겠습니다.  파이어베이스에 앱을 등록해서 관리하는 것까지 할 예정이니 파이어베이스 과정이 필요없다면 ...",
    "content": "사전 준비안드로이드에서 구글 로그인을 구현하기 위해서는 준비해야 될 게 몇 가지가 있습니다. 구글 클라우드에 들어가서 OAuth 클라이언트 아이디를 만들고 그 과정에서 본인의 앱을 등록해야 합니다. 그러므로 구체적으로 무엇을 먼저 준비해야 하는지 알아보겠습니다.  파이어베이스에 앱을 등록해서 관리하는 것까지 할 예정이니 파이어베이스 과정이 필요없다면 해당 부분은 스킵하세요!​1. 구글 클라우드에서 클라이언트 아이디 생성      구글 클라우드에 들어가서 오른쪽 상단의 콘솔 을 클릭합니다.        API 및 서비스로 들어갑니다. (만약 프로젝트가 없다면 새 프로젝트부터 만들고 시작)        왼쪽에 메뉴가 다섯 가지가 존재하는데 거기서 사용자 인증 정보를 클릭합니다.        + 사용자 인증 정보 만들기 를 눌러서 OAuth 클라이언트 ID 를 클릭해서 아이디를 생성합니다. 여기서 애플리케이션 유형을 선택할 수 있는데 웹 애플리케이션, Android 이 두 개를 각각 만들어야 합니다.      ​2. SHA-1 값 찾기웹 애플리케이션 유형은 그냥 생성하면 되므로 Android 유형 만드는 방법을 중점으로 알아보겠습니다. 여기서는 중요한 게 패키지 이름과 SHA-1 인증서 디지털 지문 입니다. 패키지 이름은 본인 프로젝트의 패키지 이름을 그대로 적으면 됩니다.인증서 디지털 지문은 그래들 태스크를 이용해서 찾을 수 있습니다. 그래들 태스크는 다음과 같이 두 가지 방법으로 실행할 수 있습니다. 태스크를 실행시켰다면 gradle signingreport 를 입력해서 실행시키면 됩니다. 그러면 터미널 창에서 SHA1 을 확인할 수 있습니다.      안드로이드 스튜디오 오른쪽 메뉴를 클릭한 다음, 터미널 아이콘을 클릭해서 그래들 태스크를 실행합니다.    안드로이드 스튜디오 오른쪽 상단의 검색 아이콘을 눌러 Gradle Task 를 검색해서 그래들 태스크를 실행합니다.  \t​파이어베이스에 앱 등록하기파이어베이스에 가서 프로젝트를 새로 만드시고 프로젝트에 들어가서 앱 추가를 해주세요. 당연히 안드로이드로 해주시면 됩니다. 그러면 구글 클라이언트 아이디 생성할 때와 똑같이 패키지 이름과 SHA-1 값을 요구할 겁니다. 동일하게 작성하고 완료하면 됩니다. 다 만들면 google-services.json 파일을 다운받을 수 있을텐데 이거를 프로젝트 폴더 내 app 에 붙여넣기 해주세요.​의존성 추가그래들 앱 수준 -  Module:app 에서 추가해야 하는 의존성 및 플러그인입니다.plugins {    id(\"com.google.gms.google-services\") // &lt;- 추가}dependencies {    implementation(platform(\"com.google.firebase:firebase-bom:32.3.1\"))    implementation(\"com.google.firebase:firebase-auth-ktx\")    implementation(\"com.google.android.gms:play-services-auth:20.7.0\")}그래들 프로젝트 수준 - Project:{본인 프로젝트명} 에서 추가해야 하는 플러그인입니다.plugins {    id(\"com.google.gms.google-services\") version \"4.4.0\" apply false // &lt;- 추가}​구글 아이디 토큰 발급하기이제 코드를 작성할 단계입니다. 파이어베이스에 로그인 유저 관리를 하기 위해서는 먼저 구글 아이디 토큰이란 것을 받아와야 합니다. 아이디 토큰을 이용해서 파이어베이스에 연결하기 때문에 이 작업을 먼저 처리해야 합니다.      GoogleSignInOptions 을 생성합니다. 저는 아이디 토큰 요청, 이메일 요청만 추가했지만 다른 옵션이 더 필요하다면 추가하면 됩니다. 여기서 requestIdToken 에 넘기는 인자가 웹 클라이언트 유형으로 만들었던 클라이언트 아이디 값입니다.    private val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)    .requestIdToken(BuildConfig.GOOGLE_CLIENT_ID)    .requestEmail()    .build()            GoogleSignInClient 을 생성합니다.    val googleSignInClient = GoogleSignIn.getClient(this, gso)            사용자가 구글 로그인을 요청했을 때 결과를 처리하는 코드를 작성    val googleLogInRequest =    registerForActivityResult(ActivityResultContracts.StartActivityForResult()) {        if (it.resultCode == RESULT_OK) {            val task = GoogleSignIn.getSignedInAccountFromIntent(it.data)            try {                val account = task.getResult(ApiException::class.java)                account?.let { user -&gt;                    user.idToken?.let { idToken -&gt;                        Timber.d(\"Get Account idToken! : ${account.idToken}\")                    }                }            } catch (e: ApiException) {                Timber.d(e)            }        }    }            사용자가 구글 로그인 버튼을 클릭했을 때 이벤트를 처리하는 코드 작성    _binding.btnRequestGoogleLogin.setOnClickListener {    googleLogInRequest.launch(googleSignInClient.signInIntent)}      ​파이어베이스에 연결하기아이디 토큰을 받았다면 이제 해당 토큰을 가지고 파이어베이스에 연결을 해야 합니다. 그러기 위해서 먼저 파이어베이스 auth 를 생성합니다.class MainActivity : AppCompatActivity() {    private lateinit var auth: FirebaseAuth    override fun onCreate(savedInstanceState: Bundle?) {\t\t\t\t// ...        auth = Firebase.auth    }}그리고 아이디 토큰을 가지고 파이어베이스에 연결을 시도합니다.private fun handleGoogleIdToken(idToken: String) {    val firebaseCredential = GoogleAuthProvider.getCredential(idToken, null)    auth.signInWithCredential(firebaseCredential)        .addOnCompleteListener(this) {            if(it.isSuccessful) {                // 정상 완료            }        }}​정리지금까지 구글 로그인 연결을 위해 필요한 과정들을 알아봤습니다. 최종적으로 구한 아이디 토큰이나 파이어베이스 auth 가 가지고 있는 값들을 프로젝트에 연결된 서버에 전송하여 유저 등록을 하게 됩니다. 지금까지의 코드를 간단하게 정리한 예시를 끝으로 마치겠습니다. 감사합니다.class MainActivity : AppCompatActivity() {    private val viewModel: GoogleLoginViewModel by viewModel()    private lateinit var _binding: ActivityMainBinding    private lateinit var auth: FirebaseAuth    private val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)        .requestIdToken(BuildConfig.GOOGLE_CLIENT_ID)        .requestEmail()        .build()    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        _binding = DataBindingUtil.setContentView(this, R.layout.activity_main)        setContentView(_binding.root)        _binding.vm = viewModel        auth = Firebase.auth        val googleSignInClient = GoogleSignIn.getClient(this, gso)        val googleLogInRequest =            registerForActivityResult(ActivityResultContracts.StartActivityForResult()) {                if (it.resultCode == RESULT_OK) {                    val task = GoogleSignIn.getSignedInAccountFromIntent(it.data)                    try {                        val account = task.getResult(ApiException::class.java)                        account?.let { user -&gt;                            user.idToken?.let { idToken -&gt;                                Timber.d(\"Get Account idToken! : ${account.idToken}\")                                handleLoginResponse()                                viewModel.googleLoginByToken(idToken)                            }                        }                    } catch (e: ApiException) {                        Timber.d(e)                    }                }            }        _binding.btnRequestGoogleLogin.setOnClickListener {            googleLogInRequest.launch(googleSignInClient.signInIntent)        }        _binding.btnRequestGoogleSignOut.setOnClickListener {            googleSignInClient.signOut().addOnCompleteListener {                if(it.isComplete) {                    viewModel.googleSignOut()                    toast(\"Complete sign out!\")                }                else { toast(\"Failure sign out!\") }            }        }    }    private fun handleLoginResponse() {        viewModel.account.observe(this) { _binding.accountInfo = it }    }    private fun handleGoogleIdToken(idToken: String) {        val firebaseCredential = GoogleAuthProvider.getCredential(idToken, null)        auth.signInWithCredential(firebaseCredential)            .addOnCompleteListener(this) {                if(it.isSuccessful) {                    // 정상 완료                }            }    }}​참조Android용 로그인Android에서 Google로 인증"
  },
  
  {
    "title": "(프로그래머스 | Kotlin) - 카드 짝 맞추기",
    "url": "/posts/KotlinAlgorithm5/",
    "categories": "CS, 알고리즘 문제",
    "tags": "Kotlin, Algorithm, 알고리즘, 프로그래머스",
    "date": "2023-10-28 22:00:00 +0900",
    





    
    "snippet": "해결 방법이 문제의 핵심은 그냥 구현, 또 구현, 그리고 또 구현이다. 막 엄청 수준이 높은 알고리즘을 요구하는 것이 아닌 기본적인 알고리즘 여러 개를 가지고 복잡한 구현을 요구한다. 그래서 이 문제를 풀면서 굉장한 피로감을 느꼈다… 나같은 경우에는 백트래킹, 너비 우선 탐색, 그리디 이 세 가지를 중심으로 구현을 진행했다. 해당 알고리즘을 사용한 이...",
    "content": "해결 방법이 문제의 핵심은 그냥 구현, 또 구현, 그리고 또 구현이다. 막 엄청 수준이 높은 알고리즘을 요구하는 것이 아닌 기본적인 알고리즘 여러 개를 가지고 복잡한 구현을 요구한다. 그래서 이 문제를 풀면서 굉장한 피로감을 느꼈다… 나같은 경우에는 백트래킹, 너비 우선 탐색, 그리디 이 세 가지를 중심으로 구현을 진행했다. 해당 알고리즘을 사용한 이유는 다음과 같다.1. 최소 탐색을 위해서는 가능한 뒤집는 순서 조합을 모두 구해서 계산해야 한다.만약 보드판 위에 1 2 3 이렇게 세 종류의 카드가 존재한다면 가능한 뒤집는 순서의 갯수는 6가지다. 이 6가지 순서쌍에서 최소 탐색을 할 수 있는 순서쌍이 존재하기 때문에 모든 순서쌍을 계산해서 최소값을 찾는 방식으로 진행한다.  1 -&gt; 2 -&gt; 3  1 -&gt; 3 -&gt; 2  2 -&gt; 1 -&gt; 3  2 -&gt; 3 -&gt; 1  3 -&gt; 1 -&gt; 2  3 -&gt; 2 -&gt; 1  private fun setPermutation(p: ArrayList&lt;Int&gt;, isVisited: Array&lt;Boolean&gt;) {      if(p.size == image.size) {          permutation.add(p.toIntArray())          return      }      image.forEach { imageCode -&gt;          if(!isVisited[imageCode]) {              isVisited[imageCode] = true              p.add(imageCode)              setPermutation(p, isVisited)              p.removeLast()              isVisited[imageCode] = false          }      }  }2. 같은 종류의 카드가 2개씩 있는데 이 2개의 뒤집는 순서도 고려해야 한다.카드가 1 2 3 이렇게 있으면 한 개씩 세 장을 의미하는 게 아니라 실제로는 각 종류별로 2개씩 총 6장의 카드가 보드판에 존재한다. 따라서 각 종류별로 2장을 어떤 순서로 뒤집을 건지도 고려해야 한다. 이 부분은 예를 들어서 특정  n번 카드 두 장을 각각 a b 라고 가정하자. 그럼 a -&gt; b b -&gt; a 이렇게 두 가지 경우에서 더 작은 이동값을 가지는 경우를 택한다.  private fun getMinimumMove(cursor: Pair&lt;Int,Int&gt;, target: Int, board:  Array&lt;IntArray&gt;): Point {      val a = position[target][0]      val b =  position[target][1]      val moveFromAtoB = bfs(cursor, a, board) + bfs(a, b, board) + 2      val moveFromBtoA = bfs(cursor, b, board) + bfs(b, a, board) + 2      return when(min(moveFromAtoB, moveFromBtoA)) {          moveFromAtoB -&gt; Point(b.first, b.second, moveFromAtoB)          else -&gt; Point(a.first, a.second, moveFromBtoA)      }  }3. 보드판 위에서 특정 위치의 카드를 찾는 방법은 BFS를 이용한다.카드를 뒤집기 위해서는 현재 위치에 있는 커서가 카드가 있는 곳으로 최소의 움직임으로 이동해야 한다. 따라서 이를 위해 BFS를 이용하여 구현했다. 대충 함수 헤더가 어떤지 설명하자면 fun bfs(curr: Pair&lt;Int,Int&gt;, target: Pair&lt;Int,Int&gt;) 이런 느낌이다.private fun bfs(cursor: Pair&lt;Int,Int&gt;, target: Pair&lt;Int,Int&gt;, board:  Array&lt;IntArray&gt;): Int {    val q = ArrayDeque&lt;Point&gt;()    val col = listOf(0,1,0,-1)    val row = listOf(1,0,-1,0)    val isVisited = Array(4) { Array(4) {false} }    q.add(Point(cursor.first, cursor.second, 0))    isVisited[cursor.first][cursor.second] = true    while(!q.isEmpty()) {        val curr = q.first()        q.removeFirst()        if(curr.x == target.first &amp;&amp; curr.y == target.second) {            return curr.cnt        }        for(i in 0..3) {            val nextCol = curr.x+ col[i]            val nextRow = curr.y + row[i]            if(-1 &lt; nextCol &amp;&amp; nextCol &lt; 4 &amp;&amp; -1 &lt; nextRow &amp;&amp; nextRow &lt; 4 &amp;&amp; !isVisited[nextCol][nextRow]) {                q.add(Point(nextCol, nextRow, curr.cnt+1))                isVisited[nextCol][nextRow] = true            }        }        for(i in 0..3) {            var nextCol = curr.x            var nextRow = curr.y            while(true) {                nextCol += col[i]                nextRow += row[i]                if(3 &lt; nextCol || nextCol &lt; 0 || 3 &lt; nextRow || nextRow &lt; 0) {                    nextCol -= col[i]                    nextRow -= row[i]                    break                }                if(board[nextCol][nextRow] &gt; 0) { break }            }            if(isVisited[nextCol][nextRow]) { continue }            q.add(Point(nextCol, nextRow, curr.cnt+1))            isVisited[nextCol][nextRow] = true        }    }    return 0}설명순서 1.백트래킹을 이용해서 순열을 구한다. 중복 순열이 필요한 것은 아니므로 방문한 번호에 대해서는 재방문을 허용하지 않도록 isVisited 와 같은 논리형 변수를 만들어서 처리한다. 순열이 한쌍 완성될 때마다 만들어둔 permutation 배열에 저장한다.순서 2.n 번 카드 2장(a b )이 있고 a -&gt; b b -&gt; a  를 각각 구해야 한다. 이를 bfs 로 구하려면 a -&gt; b 를 현재 커서 -&gt; a  a -&gt; b 이렇게 나눠서 계산해야 하고 b -&gt; a 도 마찬가지다. 그리고 두 장의 카드에 도달했을 때 뒤집는 행동도 카운트해야 하니까 a 뒤집을 때 한 번, b 뒤집을 때 한 번 해서 총 2를 더하는 것도 잊지 말아야 한다. 이렇게 계산을 끝내고 값이 더 적은 결과값을 반환하면 된다.순서 3.보통 bfs 문제들은 동, 서, 남, 북 이렇게 네 방향으로 한 칸씩 움직이면서 목표 지점을 향한다. 그런데 이 문제는 컨트롤을 누른채로 움직이는 것도 있어서 이것도 추가로 고려를 해줘야 한다. 따라서 해당 부분에 대한 로직도 같이 작성한다.for(i in 0..3) {    var nextCol = curr.x    var nextRow = curr.y    while(true) {        nextCol += col[i]        nextRow += row[i]        if(3 &lt; nextCol || nextCol &lt; 0 || 3 &lt; nextRow || nextRow &lt; 0) {            nextCol -= col[i]            nextRow -= row[i]            break        }        if(board[nextCol][nextRow] &gt; 0) { break }    }    if(isVisited[nextCol][nextRow]) { continue }    q.add(Point(nextCol, nextRow, curr.cnt+1))    isVisited[nextCol][nextRow] = true}전체 코드class Solution {    private val position = Array(7) { arrayListOf&lt;Pair&lt;Int,Int&gt;&gt;() }    private val permutation = ArrayList&lt;IntArray&gt;()    private val image = arrayListOf&lt;Int&gt;()    fun solution(board: Array&lt;IntArray&gt;, r: Int, c: Int): Int {        board.forEachIndexed { i, l -&gt;            l.forEachIndexed { j, value -&gt;                if (value != 0 &amp;&amp; position[value].size == 0) { image.add(value) }                position[value].add(Pair(i, j))            }        }        var answer: Int = 4*4*2*image.size        setPermutation(arrayListOf(), Array(7){false})        permutation.forEach { l -&gt;            var cursor = Pair(r,c)            var sum = 0            val tmpBoard = Array(4) { IntArray(4) }            for(i in 0..3) { for(j in 0..3) { tmpBoard[i][j] = board[i][j] } }            l.forEachIndexed { i, imageCode -&gt;                val result =  getMinimumMove(cursor, l[i], tmpBoard)                sum += result.cnt                cursor = Pair(result.x, result.y)                tmpBoard[position[imageCode][0].first][position[imageCode][0].second] = 0                tmpBoard[position[imageCode][1].first][position[imageCode][1].second] = 0            }            answer = min(answer, sum)        }        return answer    }    private fun getMinimumMove(cursor: Pair&lt;Int,Int&gt;, target: Int, board:  Array&lt;IntArray&gt;): Point {        val a = position[target][0]        val b =  position[target][1]        val moveFromAtoB = bfs(cursor, a, board) + bfs(a, b, board) + 2        val moveFromBtoA = bfs(cursor, b, board) + bfs(b, a, board) + 2        return when(min(moveFromAtoB, moveFromBtoA)) {            moveFromAtoB -&gt; Point(b.first, b.second, moveFromAtoB)            else -&gt; Point(a.first, a.second, moveFromBtoA)        }    }    private fun bfs(cursor: Pair&lt;Int,Int&gt;, target: Pair&lt;Int,Int&gt;, board:  Array&lt;IntArray&gt;): Int {        val q = ArrayDeque&lt;Point&gt;()        val col = listOf(0,1,0,-1)        val row = listOf(1,0,-1,0)        val isVisited = Array(4) { Array(4) {false} }        q.add(Point(cursor.first, cursor.second, 0))        isVisited[cursor.first][cursor.second] = true        while(!q.isEmpty()) {            val curr = q.first()            q.removeFirst()            if(curr.x == target.first &amp;&amp; curr.y == target.second) {                return curr.cnt            }            for(i in 0..3) {                val nextCol = curr.x+ col[i]                val nextRow = curr.y + row[i]                if(-1 &lt; nextCol &amp;&amp; nextCol &lt; 4 &amp;&amp; -1 &lt; nextRow &amp;&amp; nextRow &lt; 4 &amp;&amp; !isVisited[nextCol][nextRow]) {                    q.add(Point(nextCol, nextRow, curr.cnt+1))                    isVisited[nextCol][nextRow] = true                }            }            for(i in 0..3) {                var nextCol = curr.x                var nextRow = curr.y                while(true) {                    nextCol += col[i]                    nextRow += row[i]                    if(3 &lt; nextCol || nextCol &lt; 0 || 3 &lt; nextRow || nextRow &lt; 0) {                        nextCol -= col[i]                        nextRow -= row[i]                        break                    }                    if(board[nextCol][nextRow] &gt; 0) { break }                }                if(isVisited[nextCol][nextRow]) { continue }                q.add(Point(nextCol, nextRow, curr.cnt+1))                isVisited[nextCol][nextRow] = true            }        }        return 0    }    private fun setPermutation(p: ArrayList&lt;Int&gt;, isVisited: Array&lt;Boolean&gt;) {        if(p.size == image.size) {            permutation.add(p.toIntArray())            return        }        image.forEach { imageCode -&gt;            if(!isVisited[imageCode]) {                isVisited[imageCode] = true                p.add(imageCode)                setPermutation(p, isVisited)                p.removeLast()                isVisited[imageCode] = false            }        }    }    data class Point(        val x: Int,        val y: Int,        val cnt: Int    )}"
  },
  
  {
    "title": "(프로그래머스 | C++) - 숫자 블록",
    "url": "/posts/KotlinAlgorithm4/",
    "categories": "CS, 알고리즘 문제",
    "tags": "Kotlin, Algorithm, 알고리즘, 프로그래머스",
    "date": "2023-10-16 20:00:00 +0900",
    





    
    "snippet": "해결 방법이 문제의 핵심은 가장 큰 약수를 구하는 데 있다.  문제에서 블록의 번호가 n 이고 해당 블록은 n*2 n*3 … 이렇게 설치를 한다. 이것은 곧 약수가 됨을 의미한다. 예를 들어서 구간 10 에 설치될 블록의 번호 무엇일까? 바로  5 다. 왜 이렇게 나오는 것일까? 구간이 가지고 있는 약수들 중에서 본인을 제외한 가장 큰 숫자가 설치될 ...",
    "content": "해결 방법이 문제의 핵심은 가장 큰 약수를 구하는 데 있다.  문제에서 블록의 번호가 n 이고 해당 블록은 n*2 n*3 … 이렇게 설치를 한다. 이것은 곧 약수가 됨을 의미한다. 예를 들어서 구간 10 에 설치될 블록의 번호 무엇일까? 바로  5 다. 왜 이렇게 나오는 것일까? 구간이 가지고 있는 약수들 중에서 본인을 제외한 가장 큰 숫자가 설치될 블록 번호이기 때문이다.10 의 약수는 1, 2, 5, 10 인데 약수 1 부터 살펴보면 1*10 = 10 인 것을 알 수 있고 n=1 로 표현이 가능하다. 그래서 처음에는 구간 10 에 1 블록이 설치된다.  그 다음 블록 번호는 2 다. 마찬가지로 2*5=10 인 것을 알 수 있고 n=2 로 표현이 가능하다. 따라서 이미 설치된 1 블록에 2 블록을 덮어씌운다. 그 다음 블록 번호 3 4 는 특정 숫자를 곱해서 10 을 만들 수 없으므로 패스한다. 이런 방식으로 진행을 하면 5 가 5*2=10 이므로 구간 10 에 마지막으로 설치되는 블록 번호는 5 임을 알 수 있다. 결국 구간이 가진 본인 제외, 가장 큰 약수가 해당 구간에 설치될 블록의 번호다.      특정 숫자에 대해서 가장 큰 약수를 반환하는 메서드를 정의한다.    int GetMostDivisor(int num) {    if(num == 1) return 0;    vector&lt;int&gt; divisor(1, 1);           for(int i=2; i&lt;=sqrt(num); i++) {        if(num%i == 0) {            if(num/i &lt;= MAX_BLOCK_NUM) return num/i;            divisor.push_back(i);        }       }    return divisor.back();}            begin ~ end 범위의 반복문을 통해 본인 제외 가장 큰 약수를 저장한다.    for(int i=begin; i&lt;end+1; i++) {    answer[i-begin] = GetMostDivisor(i);}      설명순서 1.가장 큰 약수를 구하려면 가장 작은 수부터 나눠서 확인하면 된다. 이때 문제 조건인 블록 최대값 10,000,000 이 넘어가지 않는다면 해당 결과값이 된다. 아니라면 따로 약수 후보들을 배열에 저장해놓고 반복문이 끝나면 해당 배열에서 최대값을 리턴하면 된다.순서 2.각 구간의 시작과 끝을 반복문으로 돌면서 answer 에 저장하면 간단하게 끝난다.전체 코드#include &lt;string&gt;#include &lt;vector&gt;#include &lt;math.h&gt;#include &lt;iostream&gt;using namespace std;const int MAX_BLOCK_NUM = 10000000;int GetMostDivisor(int num) {    if(num == 1) return 0;    vector&lt;int&gt; divisor(1, 1);        for(int i=2; i&lt;=sqrt(num); i++) {        if(num%i == 0) {            if(num/i &lt;= MAX_BLOCK_NUM) return num/i;            divisor.push_back(i);        }       }    return divisor.back();}vector&lt;int&gt; solution(long long begin, long long end) {    vector&lt;int&gt; answer(end-begin+1, 0);        for(int i=begin; i&lt;end+1; i++) {        answer[i-begin] = GetMostDivisor(i);    }    return answer;}"
  },
  
  {
    "title": "(프로그래머스 | Kotlin) - 이모티콘 할인행사",
    "url": "/posts/KotlinAlgorithm3/",
    "categories": "CS, 알고리즘 문제",
    "tags": "Kotlin, Algorithm, 알고리즘, 프로그래머스",
    "date": "2023-10-11 20:00:00 +0900",
    





    
    "snippet": "해결방법이 문제의 핵심은 emoticons 배열에 담겨 있는 이모티콘들의 할인율을 배정하는 것이다. 각 이모티콘은 각각 10, 20, 30, 40 퍼센트로 네 가지 할인율을 가질 수 있다. 따라서 각 이모티콘은 네 가지 중에서 하나의 할인율을 가진다. emoticons 의 최대 길이가 7 이므로 나올 수 있는 이모티콘들의 할인율의 경우의 수는 최대 4...",
    "content": "해결방법이 문제의 핵심은 emoticons 배열에 담겨 있는 이모티콘들의 할인율을 배정하는 것이다. 각 이모티콘은 각각 10, 20, 30, 40 퍼센트로 네 가지 할인율을 가질 수 있다. 따라서 각 이모티콘은 네 가지 중에서 하나의 할인율을 가진다. emoticons 의 최대 길이가 7 이므로 나올 수 있는 이모티콘들의 할인율의 경우의 수는 최대 4^7 개다.나올 수 있는 최대 경우의 수가 4의 7승이라면 모든 경우를 탐색해도 지장이 없는 크기다. 따라서 완전 탐색을 통해 문제에서 요구하는 최대 효율을 가진 경우의 수(최대 효율을 내는 할인율 조합)를 찾을 수 있다. 완전 탐색을 위해서 모든 경우의 수를 구해야 하므로 백트래킹을 이용하여 나올 수 있는 모든 할인율 조합을 배열에 저장한다.모든 할인율 조합을 구했다면 하나씩 꺼내서 users 를 통해 결과값을 도출해본다. 결과값은 문제 조건대로 이모티콘 구독자 수가 많은 게 우선이고 그 다음은 이모티콘 판매액이다. 따라서 현재 계산 시점에서 나온 결과값과 이전에 계산했던 결과값 중에서 최대 효율을 내는 값과 비교하여 둘 중에 더 좋은 효율을 가진 결과값으로 업데이트하는 방식으로 해결한다. 해결 순서는 다음과 같다.      주어진 이모티콘 배열의 사이즈에 맞는 구할 수 있는 모든 할인율 조합을 구한다.    max 는 주어진 이모티콘 배열의 사이즈를 의미한다.    private fun setRatePermutation(count: Int){    if(count == max){        ratePermutation.add(tempPermutation.copyOf().toIntArray())        return    }    for(i in rate.indices){        tempPermutation[count] = rate[i]        setRatePermutation(count + 1)    }}        main 함수에서 먼저 할인율 조합을 저장한다.    this.max = emoticons.sizesetRatePermutation(0)            할인율 조합을 반복문으로 돌려 각 할인율 조합에 대한 users 배열을 계산해서 result 를 갱신한다.    for(p in ratePermutation) {    var selling = 0    var subscriberCounter = 0    for(user in users) {        var boughtSum = 0        for((i,price) in emoticons.withIndex()) {            if(p[i] &gt;= user[0]) {                boughtSum += ((100-p[i])*0.01*price).toInt()            }        }        if(boughtSum &gt;= user[1]) { subscriberCounter++ }        else{ selling += boughtSum }    }    if(answer[0] &lt; subscriberCounter || (answer[0]==subscriberCounter) &amp;&amp; answer[1] &lt; selling) {        answer[0] = subscriberCounter        answer[1] = selling    }}      설명순서 1.백트래킹을 이용한다. 여기서 할인율은 각 이모티콘마다 서로 다른 값으로 배정돼야 하는 것이 아니므로 중복값을 허용하도록 설계해야 한다. 이모티콘이 4개 있으면 할인율이  10, 20, 30, 40 일수도 있고, 10, 10, 10, 10 일수도 있다. 이렇게 구한 경우의 수가 최대(emoticons 사이즈가 7일 때) 약 16000 ~ 17000개다. 굉장히 값이 작아서 충분히 완전 탐색할 수 있는 크기다.순서 2.users 배열에 대한 계산은 그냥 문제에서 하라는 것만 하면 문제없이 결과값을 구할 수 있다. 결과값이 나왔다면 현재 최대값(1. 최대한 많은 이모티콘 구독자 수 2. 높은 판매액)과 비교해서 최대값을 갱신하면 된다. 최대값을 새로 갱신해야 하는 경우는 다음과 같다.      결과값([이모티콘 구독자 수, 이모티콘 판매액])의 이모티콘 구독자 수가 현재 최대값의 이모티콘 구독자 수보다 많을 경우    이모티콘 구독자 수가 결과값과 현재 최대값이 서로 같은데 판매액의 결과값이 더 많은 경우  전체 코드class Solution {    private var max = 7    private val tempPermutation = Array(max) {0}    private val ratePermutation = ArrayList&lt;IntArray&gt;()    private val rate = listOf(10, 20, 30, 40)    fun solution(users: Array&lt;IntArray&gt;, emoticons: IntArray): IntArray {        val answer = Array(2) {0}        this.max = emoticons.size        setRatePermutation(0)        for(p in ratePermutation) {            var selling = 0            var subscriberCounter = 0            for(user in users) {                var boughtSum = 0                for((i,price) in emoticons.withIndex()) {                    if(p[i] &gt;= user[0]) {                        boughtSum += ((100-p[i])*0.01*price).toInt()                    }                }                if(boughtSum &gt;= user[1]) { subscriberCounter++ }                else{ selling += boughtSum }            }            if(answer[0] &lt; subscriberCounter || (answer[0]==subscriberCounter) &amp;&amp; answer[1] &lt; selling) {                answer[0] = subscriberCounter                answer[1] = selling            }        }        return answer.toIntArray()    }        private fun setRatePermutation(count: Int){        if(count == max){            ratePermutation.add(tempPermutation.copyOf().toIntArray())            return        }        for(i in rate.indices){            tempPermutation[count] = rate[i]            setRatePermutation(count + 1)        }    }}"
  },
  
  {
    "title": "(프로그래머스 | Kotlin) - 억억단을 외우자",
    "url": "/posts/KotlinAlgorithm2/",
    "categories": "CS, 알고리즘 문제",
    "tags": "Kotlin, Algorithm, 알고리즘, 프로그래머스",
    "date": "2023-10-10 16:00:00 +0900",
    





    
    "snippet": "해결 방법이 문제의 핵심은 약수의 개수를 구하는 데 있다.  특정 숫자의 약수 개수를 알아야 등장 빈도를 알 수 있기 때문이다. 예를 들어서 숫자 4 를 예시로 들어보겠다. 억억단 예시 사진을 보면 해당 숫자가 세 번 등장하는데 그 이유가 구구단, 1단부터 e 단까지를 행렬로 표현해서 1X4 4X1 2X2 이렇게 나오기 때문이다.그럼 여기서 대충 약수...",
    "content": "해결 방법이 문제의 핵심은 약수의 개수를 구하는 데 있다.  특정 숫자의 약수 개수를 알아야 등장 빈도를 알 수 있기 때문이다. 예를 들어서 숫자 4 를 예시로 들어보겠다. 억억단 예시 사진을 보면 해당 숫자가 세 번 등장하는데 그 이유가 구구단, 1단부터 e 단까지를 행렬로 표현해서 1X4 4X1 2X2 이렇게 나오기 때문이다.그럼 여기서 대충 약수와 관련이 있다는 것을 눈치챌 수 있다. 4 의 약수는 총 세 개, 1, 2, 4 이다. 가운데를 기준으로 특정 위치에 있는 숫자는 자신의 반대쪽에 있는 숫자와 곱을 하면 4 가 된다. 그래서 원래는 4 가 두 개가 나오는 것이 맞지만 억억단은 행과 열 둘 다 구구단이 존재하기 때문에 동일 숫자 곱(2X2)을 제외하고 각각 2배를 해줘야 한다. 따라서  1, 4 는 1X4 4X1 이렇게 두 가지가 된다.이런 특징을 이용해서 숫자  e 까지의 등장 빈도를 배열에 저장하고 이 배열을 이용해 result 를 구하면 되는데 문제는 등장 빈도를 구하는 속도가 빨라야 한다. 나같은 경우에는 처음에  제곱근을 이용한 약수 개수를 구하는 알고리즘을 이용해서 시도했었는데 시간 초과가 됐었다. 그래서 배수를 이용한 약수 개수 구하는 알고리즘으로 변경하여 제출했더니 통과가 됐다. 따라서 이 문제는 약수 개수를 구하는 알고리즘만 잘 짜면 그 뒤는 무난하게 풀 수 있다. 해결 순서는 다음과 같다.      e 까지 각 숫자의 등장 빈도를 배열에 저장한다.    for (i in 1..e) {    for (j in 1..e / i) {        counter[i*j]++    }}            starts 배열 내 원소들을 하나씩 방문하여 result 를 구한다.    getResult 는 i ~ j 사이에서 빈도가 가장 높은 수와 빈도 값을 배열에 담아 리턴하는 메서드이다.    private fun getResult(i: Int, j: Int, counter: Array&lt;Int&gt;): IntArray {    var maxCnt = 0    var numOfMaxCnt = 0    for(num in i .. j) {        if(counter[num] &gt; maxCnt) {            maxCnt = counter[num]            numOfMaxCnt = num        }    }    return intArrayOf(numOfMaxCnt, maxCnt)}        var prev = getResult(sortedStarts.last()[0], e, counter)answer[sortedStarts.last()[1]] = prev[0]   for(i in sortedStarts.lastIndex-1 downTo 0) {    val curr = getResult(sortedStarts[i][0], sortedStarts[i + 1][0], counter)    answer[sortedStarts[i][1]] = if (curr[1] &gt;= prev[1]) curr[0] else prev[0]       if(curr[1] &gt; prev[1]) {        answer[sortedStarts[i][1]] = curr[0]        prev = curr    }    else if(curr[1] == prev[1]) {        answer[sortedStarts[i][1]] = min(curr[0], prev[0])        prev = if(curr[0] &lt; prev[0]) curr else prev    }    else {        answer[sortedStarts[i][1]] = prev[0]    }}answer.toIntArray()        설명    순서 1.    이 부분은 위에서 설명했듯이 배수를 이용한 약수 개수 구하는 알고리즘을 사용해서 e 까지 빈도를 배열에 저장하면 된다.    순서 2.    이 부분은 풀이 방법이 사람마다 다를 수 있는데 나같은 경우에는 starts 를 정렬해놓고 내림차순으로 각 원소의 result 를 구하는 방법을 사용했다. 예를 들어서 문제 예시에서 준 starts 는 [1, 3, 7] 인데 이를 먼저 정렬한다. (근데 이미 정렬이 되어 있으므로 패스) 그리고  e 는 8 이다.    이제 starts 를 내림차순으로 반복문을 돌려서 7~8 -&gt; 3~8 -&gt; 1~8 이런 식으로 result 를 구한다. 그런데 7~8 을 먼저 계산을 하면 3~8 을 계산할 때 3~7 까지만 계산하면 된다. 7~8 부분은 이미 앞서 계산을 끝마쳤기 때문이다. 서로 두 결과값을 비교해서 빈도가 더 많은쪽을 설정해주면 된다. 만약 빈도가 서로 같다면 문제에서 내건 조건대로 숫자가 더 작은쪽을 설정해주면 된다. 이런 방식으로 계산을 하면은 마지막인 1~8 계산은 1~3 까지만 계산하고 앞서 계산한 3~8 값과 비교해서 값을 업데이트하면 된다.    전체 코드    import kotlin.math.*   class Solution {    fun solution(e: Int, starts: IntArray): IntArray {        val answer = Array(starts.size) {0}        val counter = Array(e+1) {0}        val sortedStarts = Array(starts.size) { Array(2) {0} }              for((i, num) in starts.withIndex()) {            sortedStarts[i][0] = num            sortedStarts[i][1] = i        }        sortedStarts.sortBy {it[0]}                   for (i in 1..e) {            for (j in 1..e / i) {                counter[i*j]++            }        }           return if(starts.size &lt; 2) {            intArrayOf(getResult(starts[0], e, counter)[0])        } else {            var prev = getResult(sortedStarts.last()[0], e, counter)            answer[sortedStarts.last()[1]] = prev[0]                           for(i in sortedStarts.lastIndex-1 downTo 0) {                val curr = getResult(sortedStarts[i][0], sortedStarts[i + 1][0], counter)                answer[sortedStarts[i][1]] = if (curr[1] &gt;= prev[1]) curr[0] else prev[0]                   if(curr[1] &gt; prev[1]) {                    answer[sortedStarts[i][1]] = curr[0]                    prev = curr                }                else if(curr[1] == prev[1]) {                    answer[sortedStarts[i][1]] = min(curr[0], prev[0])                    prev = if(curr[0] &lt; prev[0]) curr else prev                }                else {                    answer[sortedStarts[i][1]] = prev[0]                }            }            answer.toIntArray()        }       }       private fun getResult(i: Int, j: Int, counter: Array&lt;Int&gt;): IntArray {        var maxCnt = 0        var numOfMaxCnt = 0        for(num in i .. j) {            if(counter[num] &gt; maxCnt) {                maxCnt = counter[num]                numOfMaxCnt = num            }        }        return intArrayOf(numOfMaxCnt, maxCnt)    }}      "
  },
  
  {
    "title": "(프로그래머스 | Kotlin) - 요격 시스템",
    "url": "/posts/KotlinAlgorithm1/",
    "categories": "CS, 알고리즘 문제",
    "tags": "Kotlin, Algorithm, 알고리즘, 프로그래머스",
    "date": "2023-10-09 22:00:00 +0900",
    





    
    "snippet": "해결 방법문제를 해석하면 특정 구간이 여러 개 주어지고 그 구간들을 전부 관통할 수 있는 최소의 폭격 미사일 수를 구해야 한다. 문제에서 그리디 알고리즘 문제를 좀 풀어봤다면 예시로 던져준 사진을 보자마자 그리디 문제임을 알아챘을 것이다. 따라서 이 문제는 그리디 알고리즘을 이용해서 해결하면 된다. 해결 순서는 다음과 같다.      targets 내...",
    "content": "해결 방법문제를 해석하면 특정 구간이 여러 개 주어지고 그 구간들을 전부 관통할 수 있는 최소의 폭격 미사일 수를 구해야 한다. 문제에서 그리디 알고리즘 문제를 좀 풀어봤다면 예시로 던져준 사진을 보자마자 그리디 문제임을 알아챘을 것이다. 따라서 이 문제는 그리디 알고리즘을 이용해서 해결하면 된다. 해결 순서는 다음과 같다.      targets 내 특정 구간 i 에 대해서 targets[i][1] 을 기준으로 정렬한다.        첫 폭격 미사일 설치 위치를 targets[0][1] 로 설정한다.    var lastSpot = targets[0][1]            반복문을 통해 정렬된 targets 내의 모든 원소들을 차례로 돌면서 현재 원소의 시작 위치가 lastSpot 위치보다 같거나 크다면 해당 원소의 끝 위치가 다음 폭격 미사일의 설치 위치가 된다.    for(i in targets.indices) {    if(targets[i][0] &gt;= lastSpot) {        lastSpot = targets[i][1]        answer++    }}            3번 반복문 내의 조건문이 충족될 때마다 answer (설치해야 할 폭격 미사일 갯수) 를 증가시킨다.  설명순서 1.모든 원소는 시작과 끝 값을 가지고 있다. 여기서 끝 값을 기준으로 오름차순 정렬을 해주면 특정 원소 인덱스 i  다음부터 모든 원소들의 끝 값은 i 번째 원소의 끝 값보다 무조건 같거나 크다. 그래서 i+1 부터 끝 원소까지 차례로 탐색하면서 시작 위치 값이 i 위치의 끝 값보다 같거나 큰 원소가 나오면 해당 원소의 끝에 폭격 미사일을 설치하면 된다.순서 2.끝 좌표 기준으로 정렬된 상태라면 폭격 미사일을 특정 원소의 끝 좌표를 겨냥해서 설치하는 것이 최대한 많은 원소들을 관통할 확률을 높여준다. 문제 예시 사진처럼 직접 정렬된 형태로 그려놓고 시작 위치에 폭격 미사일을 설치하는 것과 끝 위치에 폭격 미사일 설치하는 것을 비교하면 무슨 말인지 이해할 수 있다.순서 3.문제 조건에서 조심해야 할 점은 시작, 혹은 끝 위치는 폭격이 불가능하다는 것이다. 그래서 특정 원소 i 의 끝 위치가 , i+1  의 시작 위치와 같다고 해도 i  끝 위치에 설치해서 하나로 두 개를 터트릴 수 없다는 뜻이다.그래서 2번에 설명한 끝 위치라는 것은 실제로 끝 값을 의미하는 것이 아닌 최대한 끝 값에 가까운 값으로 가정해서 코드를 작성한다. 배열은 끝 값이 저장되지만 머릿속으로는 끝 값에 가까운 값이라고 생각하면서 문제를 풀면 된다. 이런 이유로 반복문 내 조건문은 현재 원소의 시작 위치가 마지막으로 설치된 폭격 미사일 위치와 같아도 미사일을 새로 설치해야 한다.전체 코드class Solution {    fun solution(targets: Array&lt;IntArray&gt;): Int {        targets.sortBy {it[1]}        var answer= 1        var lastSpot = targets[0][1]        for(i in targets.indices) {            if(targets[i][0] &gt;= lastSpot) {                lastSpot = targets[i][1]                answer++            }        }        return answer    }}"
  },
  
  {
    "title": "Android Navigation에 대해서 알아보자",
    "url": "/posts/Android-Navigation/",
    "categories": "Android, 라이브러리",
    "tags": "Android, UI, 레이아웃, 네비게이션, JetPack",
    "date": "2023-05-05 00:00:00 +0900",
    





    
    "snippet": "Jetpack에서 제공하는 Navigation내비게이션(Navigation)은 안드로이드 Jetpack에서 제공하는 라이브러리 중 하나입니다. 내비게이션은 말 그대로 탐색을 지원하는 라이브러리며 기존의 방식보다 화면 전환을 쉽고 빠르고 유연하게 도와줍니다. 아마 안드로이드 앱 개발을 시작한 지 얼마 안 됐다면 꼭 알아야 하는 라이브러리 중 하나이지 않...",
    "content": "Jetpack에서 제공하는 Navigation내비게이션(Navigation)은 안드로이드 Jetpack에서 제공하는 라이브러리 중 하나입니다. 내비게이션은 말 그대로 탐색을 지원하는 라이브러리며 기존의 방식보다 화면 전환을 쉽고 빠르고 유연하게 도와줍니다. 아마 안드로이드 앱 개발을 시작한 지 얼마 안 됐다면 꼭 알아야 하는 라이브러리 중 하나이지 않을까 싶습니다. 그래서 이번 포스팅은 내비게이션 라이브러리가 무엇이고 왜 사용하며 어떻게 사용하는지 알아보겠습니다.​기존의 화면 전환 방식안드로이드에서 UI를 제공할 수 있는 창은 Activity 와 이에 종속되어서 부분 UI를 나타내는 Fragment 입니다. 그래서 안드로이드 앱 내에서 화면 전환이라 하면 보통 다음과 같이 세 가지가 있습니다.  Activity to Activity  Fragment to Fragment  Activity to Fragment액티비티와 액티비티 사이의 전환은 Intent 객체를 이용해서 구현합니다. 그리고 프래그먼트로의 이동은 fragmentManager 를 이용해서 beginTransaction 을 통해 구현하게 됩니다. 앱 프로젝트 규모가 작다면 상관없지만 규모가 큰 프로젝트라면 사용해야 될 화면도 많아질 것이고 복잡한 화면 전환 구성을 가지게 될 가능성이 높습니다.화면만 전환하면 끝일까요? 화면 전환에 데이터를 담아서 전송할 수도 있고 화면 전환 애니메이션도 적용할 수도 있습니다. 따라서 화면 전환은 많은 작업을 필요로 합니다.​그래서 하나로 합쳐드렸습니다~그래서 구글은 화면 전환에 필요한 라이브러리, 툴, 플러그인 등을 하나로 합쳐서 Navigation이라는 라이브러리를 만들었습니다. 기존에 인텐트 혹은 프래그먼트 매니저를 통한 화면 전환에서 내비게이션 XML 공간에서 쉽게 탐색구조를 구축하는 방식으로 전환된 것입니다.아래 사진과 같이 내비게이션 XML에서 기존에 가지고 있는 프래그먼트나 액티비티를 추가해서 원하는 탐색구조를 마우스로 연결해 주기만 하면 화살표가 생성되어 화면 전환 구조에 대한 직관적인 파악이 가능해집니다.​쉽고 깔끔한 프래그먼트로의 전환내비게이션 라이브러리를 사용했을 때 얻을 수 있는 장점은 프래그먼트 전환이 굉장히 쉬워집니다. 설명드린 대로 현재 생성한 프래그먼트들을 다 추가해서 연결하기만 하면 생성된 id 를 통해서 전환을 할 수 있는데 이 전환을 요청하는 코드도 굉장히 짧고 간단합니다.  그래서 이 라이브러리를 사용하면 프래그먼트를 실컷 생성해서 복잡한 탐색구조를 구축할 수 있습니다.​Single Activity이러한 장점 때문에 구글에서는 프래그먼트 전환 관리가 쉬운 네비게이션을 통해 단일 액티비티 구조를 권장합니다. 액티비티를 하나만 생성하고 나머지는 전부 프래그먼트로 채우라는 소리입니다. 단일 액티비티 구조를 주장하는 이유는 다음과 같습니다.  Activity 는 Fragment 에 비해 덩치가 큰 객체라 메모리, 속도 면에서 불리하다.  Fragment 는 Activity 에 비해 비교적 쉬운 데이터 공유, 유연한 UI 구축의 장점을 가지고 있다.​Navigation 대표 구성요소 세 가지Navigation Graph탐색구조를 구축할 수 있는 XML 리소스 파일입니다. 여기서 화면 전환, 애니메이션 등을 세팅할 수 있습니다.NavHost여러 프래그먼트를 담을 수 있는 하나의  컨테이너입니다. 이 컨테이너에서 여러 프래그먼트의 전환이 일어나게 됩니다.  탐색구조를 여러 개의 그룹으로 쪼개고 싶다면 NavHost 를 여러 개 만들어서 구축할 수도 있습니다.NavController각각의 NavHost 는 하나의  NavController 를 가지고 있습니다. 이 친구는 앱 내의 탐색을 관리하여 A에서 B로 전환해야 되는 상황이 발생하면 이를 인식하고 화면 전환을 수행합니다.findNavController().navigate(R.id.action)세 가지를 종합해보면?Navigation Graph를 통해서 탐색구조를 정의를 하여 전환이 필요할 때 NavController 에게 요청을 합니다. 그럼 컨트롤러는 이를 수행하고 NavHost 는 이를 인식하여 기존 프래그먼트에서 알맞은 프래그먼트로 교체하여 화면에 표시합니다.​Navigation 사용 방법0. Dependency 설정dependencies {  // 글 작성 기준으로 2.5.3 버전입니다.  def nav_version = \"2.5.3\"  implementation \"androidx.navigation:navigation-fragment-ktx:$nav_version\"  implementation \"androidx.navigation:navigation-ui-ktx:$nav_version\"}​1. 프래그먼트를 보여줄 NavHost 지정하기지금부터 설명드리는 예시는 액티비티에 여러 프래그먼트를 띄우는 방식입니다. 따라서 저는 액티비티 레이아웃 XML에 FragmentContainer를 만들어서 이 친구를 NavHost 로 지정하겠습니다. android:name  을 호스트 프래그먼트로 지정해 주고 app:navGraph 는 뒤에 그래프를 만들면 그때 추가해 주세요.&lt;androidx.fragment.app.FragmentContainerView    android:id=\"@+id/fcv_main\"    android:name=\"androidx.navigation.fragment.NavHostFragment\"    android:layout_width=\"0dp\"    android:layout_height=\"0dp\"    app:defaultNavHost=\"true\"    app:layout_constraintBottom_toTopOf=\"@id/bnv_main\"    app:layout_constraintEnd_toEndOf=\"parent\"    app:layout_constraintStart_toStartOf=\"parent\"    app:layout_constraintTop_toTopOf=\"parent\"    app:navGraph=\"@navigation/nav_main\" /&gt;​2. Navigation Graph 정의안드로이드 res 폴더 내에 New 를 통해  Android Resource Directory 를 누르시면 navigation 디렉토리를 따로 만들 수 있습니다. 생성하고 그 안에 리소스 파일을 새로 생성해 주세요. 생성했다면 밑의 예시처럼 필요한 액티비티나 프래그먼트를 불러서 마우스로 연결해 주세요.​3. navController를 통해 화면 전환 요청 코드 작성하기그래프를 다 만들었다면 Split을 통해서 XML 코드도 확인해 보세요. 그러면 &lt;fragment&gt;  태그로 감싸진 코드가 굉장히 많아진 것을 볼 수 있습니다. 그중에서 하나만 보겠습니다. 해당 프래그먼트는 연결 지점이 한 곳입니다. 이는 &lt;action&gt;에 정의되어 있습니다. 만약에 연결한 프래그먼트가 세 곳이면 &lt;action&gt; 은 세 개가 됩니다.    &lt;fragment        android:id=\"@+id/nav_my_page\"        android:name=\"com.example.travelfeeldog.presentation.mypage.MyPageFragment\"        android:label=\"fragment_my_page\"        tools:layout=\"@layout/fragment_my_page\" &gt;        &lt;action            android:id=\"@+id/action_nav_my_page_to_myReviewFragment\"            app:destination=\"@id/myReviewFragment\"            app:enterAnim=\"@anim/nav_default_enter_anim\"            app:exitAnim=\"@anim/nav_default_exit_anim\"            app:popEnterAnim=\"@anim/nav_default_pop_enter_anim\"            app:popExitAnim=\"@anim/nav_default_pop_exit_anim\" /&gt;    &lt;/fragment&gt;연결한 프래그먼트로 이동을 위해서 액션 아이디인 android:id 를 통해서 요청하면 됩니다.binding.clReviewArea.setOnClickListener{    findNavController().navigate(R.id.action_nav_my_page_to_myReviewFragment)}​BottomNavigationView 연동내비게이션은 바텀 내비게이션 뷰와 연결이 가능합니다. 방법은 다음과 같습니다.1. 필요한 메뉴 구성res  에서 menu  디렉토리(없으면 생성)에 바텀 내비게이션 전용 메뉴 XML 을 생성합니다. 생성했으면 해당 파일에 필요한 메뉴를 정의합니다. 저는 홈, 검색, 마이 페이지가 필요하므로 세 개를 만들었습니다.&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;    &lt;item android:id=\"@+id/nav_home\"        android:title=\"@string/navigation_home\"        android:icon=\"@drawable/ic_home\"/&gt;    &lt;item android:id=\"@+id/nav_search\"        android:title=\"@string/navigation_search\"        android:icon=\"@drawable/ic_search\"/&gt;    &lt;item android:id=\"@+id/nav_my_page\"        android:title=\"@string/navigation_my_page\"        android:icon=\"@drawable/ic_my_page\"/&gt;&lt;/menu&gt;  메뉴 아이템 태그의 아이디, 네비게이션 그래프에 정의한 프래그먼트 태그의 아이디는 동일해야 한다.​2. BottomNavigationView 생성액티비티 레이아웃 XML에 바텀 내비게이션 뷰를 생성합니다. 생성했으면 속성으로 app:menu 를 추가하여 만든 메뉴 파일을 연결합니다.&lt;com.google.android.material.bottomnavigation.BottomNavigationView    android:id=\"@+id/bnv_main\"    android:layout_width=\"0dp\"    android:layout_height=\"wrap_content\"    android:background=\"@color/white\"    android:paddingTop=\"6dp\"    app:itemIconTint=\"@color/selector_bottom_nav_color\"    app:itemRippleColor=\"@null\"    app:itemTextAppearanceActive=\"@style/Widget.BottomNavigationView.Active\"    app:itemTextAppearanceInactive=\"@style/Widget.BottomNavigationView.InActive\"    app:itemTextColor=\"@color/selector_bottom_nav_color\"    app:labelVisibilityMode=\"labeled\"    app:layout_constraintBottom_toBottomOf=\"parent\"    app:layout_constraintEnd_toEndOf=\"parent\"    app:layout_constraintStart_toStartOf=\"parent\"    app:layout_constraintTop_toBottomOf=\"@id/fcv_main\"    app:menu=\"@menu/menu_bottom\" /&gt;​3. BottomNavigationView 호스트에 NavController 연결마무리로 바텀 내비게이션 뷰를 가지고 있는 액티비티에 컨트롤러를 연결해야 합니다. 해당 코드는 호스트가 되는 액티비티에서 일부를 가져왔습니다.override fun onCreate(savedInstanceState: Bundle?) {    super.onCreate(savedInstanceState)    setContentView(binding.root)    binding.bnvMain.setupWithNavController(findNavController())}private fun findNavController(): NavController {    val navHostFragment =        supportFragmentManager.findFragmentById(R.id.fcv_main) as NavHostFragment    return navHostFragment.navController}​마무리안 중요한 라이브러리는 없지만 내비게이션 라이브러리는그중에서도 유용하고 정말 중요한 것 같습니다. 제가 첫 안드로이드 프로젝트를 했을 때 내비게이션의 존재를 모르고 수작업으로 전환 코드를 작성해서 엄청 고생했던 기억이 있습니다. 처음 시작하는 분들은 저처럼 삽질하지 말고 내비게이션으로 편한 프로젝트 되시길 바랍니다 :)참조Android 공식 문서 - NavigationAndroid 공식 문서 - Navigation 시작하기"
  },
  
  {
    "title": "Android의 UI, 뷰(View) 그리고 레이아웃(ViewGroup)",
    "url": "/posts/Android-UI/",
    "categories": "Android, 기본",
    "tags": "Android, UI, 레이아웃, 뷰",
    "date": "2023-04-06 12:00:00 +0900",
    





    
    "snippet": "모바일 UI는 어떻게 구성되어 있는가?예시로 우리가 스마트폰을 이용해서 배달의민족 앱을 이용할 때를 생각해 봅시다. 해당 앱에 접속을 해보면 여러 카테고리 버튼이 있고 밑으로 스크롤을 하면 여러 음식점들의 간략한 정보가 리스트 형식, 혹은 카드 형태로 제공됩니다.특정 음식점을 클릭하면 해당 음식점에 대한 상세 페이지로 이동하게 되고 여기서는 가게에 대...",
    "content": "모바일 UI는 어떻게 구성되어 있는가?예시로 우리가 스마트폰을 이용해서 배달의민족 앱을 이용할 때를 생각해 봅시다. 해당 앱에 접속을 해보면 여러 카테고리 버튼이 있고 밑으로 스크롤을 하면 여러 음식점들의 간략한 정보가 리스트 형식, 혹은 카드 형태로 제공됩니다.특정 음식점을 클릭하면 해당 음식점에 대한 상세 페이지로 이동하게 되고 여기서는 가게에 대한 텍스트 정보, 음식 사진에 대한 이미지 정보, 메뉴들을 선택할 수 있는 체크박스, 해당 가게 정보를 저장할 수 있는 찜 버튼과 같은 다양한 상호작용 요소들을 볼 수 있습니다.  이렇듯 모바일 UI는 하나의 화면 안에 사용자와 상호작용이 가능한 다양한 요소들이 존재합니다.​Android는 UI를 어떻게 제작하는가?그렇다면 Android는 이러한 모바일 UI를 어떤 방식으로 구현할까요? 가장 먼저 사용자에게 앱과 상호작용할 수 있는 화면으로 안내하는 것이 우선입니다.상호작용을 위한 화면안드로이드는 사용자가 앱과 상호작용할 수 있도록 진입점을 제공하는데 이것이 Activity 입니다. 액티비티는 안드로이드 앱을 구성하는 4대 구성 요소 중에 하나이며 사용자에게 UI를 제공하여 상호작용을 하기 위한 진입점입니다. 안드로이드 앱 내에 여러 화면을 구성할 수 있는 것도 액티비티가 있기 때문입니다.화면 내에 존재하는 여러 상호작용 요소들사용자가 Activity 에 도달했다면 이제는 그곳에 배치된 여러 요소들을 통해서 본격적으로 상호작용을 할 수 있게 됩니다. 이 요소들은 뷰(View) 와 뷰그룹(ViewGroup) 이라는 것들의 계층 구조로 이루어져 있습니다. 배달의민족을 통해 음식점 상세 페이지에 갔을 때 볼 수 있는 텍스트, 이미지, 체크박스, 이미지 버튼 등의 요소들을 뷰(View) 라고 하고 이런 여러 뷰들을 담는 컨테이너를 뷰그룹(ViewGroup) 이라고 합니다.​뷰(View)안드로이드는 사용자와 상호작용할 수 있는 요소 제작과 배치를 위해서 View 객체를 제공합니다. 뷰는 사용자 인터페이스의 기본적인 구성 요소이며 그리기 및 이벤트 처리를 담당합니다. 뷰를 다른 말로 위젯이라고도 합니다.뷰 객체는 여러 속성과 메서드를 가지고 있습니다. 대표적으로  draw() 라는 메서드가 있는데 이를 통해서 화면에 뷰를 그릴 수 있습니다. 이벤트 처리 같은 경우에는 대표적인 예시로 클릭에 대한 이벤트가 있는데 사용자가 뷰를 클릭하면 이를 감지하여 어떤 동작을 처리할 수 있게 지원합니다.여러 뷰들은 View 객체로부터 파생된 것(View Hierarchy)뷰 객체가 가지고 있는 속성과 메서드의 상속을 통해서 특정 기능을 가진 뷰로 확장시키는 방식으로 다양한 뷰들을 만들 수 있는데 안드로이드에서 기본적으로 제공하는 뷰들이 이에 해당됩니다. 따라서  많이 사용되는  TextView, Button, ImageView 등의 뷰들은 전부 View 객체에서 파생된 뷰입니다.기본 제공되는 뷰들을 사용해서 UI 구성을 진행하고 만약에 기본적으로 제공되는 뷰의 기능이 부족하다면 직접 뷰 객체를 커스텀 해서 만들어야 합니다. 이를 커스텀 뷰라고 하는데 이 부분은 나중에 따로 포스팅해보겠습니다.뷰의 상속 관계(View Hierarchy)​​뷰그룹(ViewGroup)ViewGroup 은 상속 관계도에서 확인할 수 있듯이  View 를 상속받은 객체입니다. 뷰그룹은 다른 말로  레이아웃이라고 하는데 여러 View 들을 담을 수 있고 이런 여러 뷰들의 배치를 도와줍니다. 뷰그룹은 여러 뷰도 담을 수 있지만 다른 뷰그룹도 담을 수 있습니다. 그래서 중첩으로 레이아웃을 만들어 좀 더 복잡한 배치를 할 수 있습니다. 레이아웃의 종류는 크게 6개로 볼 수 있습니다.LinearLayout  뷰를 일렬로 배치하는 레이아웃      배치 방식을 위한 orientation 속성을 제공                  orientation = vertical : 세로로 배치                            orientation = horizontal : 가로로 배치                    ​RelativeLayout  뷰의 상대적인 위치에 따라 배치하는 레이아웃      상대적인 위치 설정을 위한 속성들을 제공 RelativeLayout.LayoutParams        속성 몇 가지 예시          layout_alignParentTop      layout_centerVertical      layout_below      layout_toRightOf            배치 예시      ​FrameLayout  뷰를 중첩해서 배치하는 레이아웃      visibility  속성을 이용해서 상황에 따라 특정 뷰만 보이게 하고 나머지 뷰는 보이지 않게 설정        배치 예시      ​TableLayout  행과 열을 통해 표 형태로 뷰를 배치하는 레이아웃      TableRow  를 이용해 한 행을 생성하고 이 안에 여러 뷰들을 만들어서 열을 채우는 방식으로 배치        TableRow 내에는 View 혹은 ViewGroup  를 넣을 수 있음        배치 예시      ​GridLayout  격자 배치 레이아웃      TableLayout 와 마찬가지로 행과 열을 이용해 배치, 하지만 그리드레이아웃이 더 유연한 배치가 가능        행과 열에 대한 속성을 제공해서 유연한 배치 가능        배치 예시      ​ContraintLayout  제약 조건을 통한 배치 레이아웃      부모 레이아웃을 기반으로 배치하는 것이 아닌 동일한 뷰를 기반으로 유연한 배치가 가능        뷰와 뷰그룹의 계층 구조로 이루어진 Android의 UI 에서 제약레이아웃을 통해 플랫한 계층 구조 설계가 가능        사용 가능한 제약 조건들          Relative positioning      Margins      Centering positioning      Circular positioning      Visibility behavior      Dimension constraints      Chains      Virtual Helpers objects      Optimizer            배치 예시      ​Android의 UI는 뷰와 뷰그룹의 계층 구조지금까지의 이야기를 종합해 보면 사용자와 상호작용을 위한 기본적인 구성 요소인 뷰들을 레이아웃에 담아서 배치하는 식으로 UI를 제작합니다. UI가 단순하다면 단순히 하나의 레이아웃 안에 여러 뷰들을 넣어서 배치할 것이고 UI가 좀 더 복잡하다면 트리 구조처럼 레이아웃 안에 레이아웃을 더 만들어 배치할 것입니다.따라서 안드로이드의 UI는 뷰와 뷰그룹의 계층 구조로 이루어져 있습니다. 레이아웃 XML 파일을 들여다보면 루트에 레이아웃이 있고 그 안에 뷰나 레이아웃을 만드는 식의 계층 구조 형태로 제작하게 돼있습니다.​계층 구조 레이아웃의 최적화트리 구조를 생각해보자.트리 구조의 깊이가 증가할수록 어떤 단점이 발생할까요? 노드 탐색이 느려질 수 있다는 단점이 생깁니다. 만약에 찾고 싶은 노드가 가장 밑단에 위치해 있다면 트리의 깊이가 깊을수록 탐색 시간도 늘어나게 됩니다.트리를 이용한  Union-Find도 탐색 시간 최적화를 위해서 모든 자식 노드의 부모 노드를 루트 노드로 설정해서 깊이를 최소로 줄이는 방법을 사용합니다.Android UI 계층 구초는 가능한 한 얕게 유지해야 한다.뷰와 뷰그룹의 계층 구조의 안드로이드 UI도 가능하면 깊이를 얕게 유지해야 합니다. 중첩 레이아웃이 레이아웃 계층 구조의 깊이를 증가시키는 원인이므로 되도록이면 중첩 레이아웃을 사용하지 않고 배치하는 노력을 하는 것이 좋습니다. 얕게 유지하면 유지할수록 레이아웃이 더 빠르게 화면에 그려지게 됩니다.  가로로 넓은 뷰 계층 구조가 세로로 깊은 뷰 계층 구조보다 낫습니다.ConstraintLayout을 주로 사용하는 이유ConstraintLayout 은 이것만으로 다른 대부분의 레이아웃들의 배치 특성을 구현할 수 있고 뷰에 대한 포지셔닝이 굉장히 유연해서 가로로 넓은 뷰 계층 구조를 만들 수 있습니다. 그래서 저는 제약레이아웃을 주로 사용하고 있습니다.​마무리결국에는 여러 뷰와 뷰그룹을 통해서 UI를 구상하고 완성된 레이아웃 XML 파일은 Activity 에 연결되어 사용자에게 제공됩니다. 그래서 액티비티에서 뷰를 참조하여 특정한 UI 처리를 할 수 있습니다. 요즘에는 XML 방식이 아닌 최신 UI 제작 도구인 Jetpack compose를 도입하려는 움직임이 많습니다. 저도 나중에 기회가 되면 꼭 배워보려고 합니다.마지막으로 혹시나 틀린 부분이 있다면 댓글로 남겨주세요. 바로 수정하도록 하겠습니다. 긴 글 읽어주셔서 감사하고 이 글을 읽는 여러분 모두 좋은 하루 보내시길 바랍니다!​참조안드로이드 공식문서 - 레이아웃안드로이드 공식문서 - 성능 및 뷰 계층 구조찰스의 안드로이드"
  },
  
  {
    "title": "Union-Find 유니온 파인드",
    "url": "/posts/Uinon-Find/",
    "categories": "CS, 알고리즘",
    "tags": "알고리즘, 자료구조, 유니온 파인드",
    "date": "2023-02-21 12:00:00 +0900",
    





    
    "snippet": "서로소 집합(disjoint-set)을 관리하는 자료 구조다양한 원소들이 서로소 집합을 이루는 경우가 있습니다. 필요에 따라서 이 집합들을 이용하여 서로 합치거나 특정 원소를 통해 특정 집합을 탐색할 수도 있습니다. 유니온 파인드(union-find)는 그래프 알고리즘으로 서로소 집합을 관리하며 서로 다른 두 노드가 동일한 집합에 있는지 판별합니다.유...",
    "content": "서로소 집합(disjoint-set)을 관리하는 자료 구조다양한 원소들이 서로소 집합을 이루는 경우가 있습니다. 필요에 따라서 이 집합들을 이용하여 서로 합치거나 특정 원소를 통해 특정 집합을 탐색할 수도 있습니다. 유니온 파인드(union-find)는 그래프 알고리즘으로 서로소 집합을 관리하며 서로 다른 두 노드가 동일한 집합에 있는지 판별합니다.유니온 파인드는 서로 다른 두 노드가 같은 집합에 있는지 판별하기 위해서 각 집합의 대표 원소를 참고합니다. 여기서 대표 원소라 함은 연결 리스트에서는 헤드가 되며 트리에서는 루트 노드가 해당됩니다. 두 노드가 속한 집합의 대표 원소를 찾아서 대표 원소가 서로 동일하면 같은 집합에 있는 걸로 판단하게 됩니다. 이러한 판단 과정에서 여러 집합들이 합쳐지거나(Union) 특정 원소가 속한 대표 원소를 찾기 위해 집합 탐색(Find) 을 진행하기도 합니다. 그래서 유니온 파인드에서는 다음과 같은 연산들이 존재합니다.​연산의 종류            연산      특징                  MakeSet      특정 한 원소만 존재하는 집합을 만든다.              Union      두 개의 집합을 하나의 집합으로 합친다.              Find      특정 원소가 속한 집합의 대표 원소를 반환한다.      ​구현과 관리를 위해 사용되는 방법유니온 파인드를 관리하는 방식은 두 가지가 있습니다. 첫 번째는 연결 리스트를 통한 관리고 두 번째는 트리 구조를 이용한 관리입니다. 각 방식들이 유니온 파인드의 연산을 어떻게 처리하는지 알아보도록 합시다.연결 리스트            연산      방법                  MakeSet      원소 하나만 가지고 노드를 생성한다. 헤드가 해당 집합의 대표 원소다.              Union      한 집합의 헤드 부분이 다른 집합의 꼬리(Tail) 부분을 가리키는 방식으로 연결한다.              Find      지목한 원소의 집합에 존재하는 헤드 원소를 찾아 반환한다.      ​트리 구조            연산      방법                  MakeSet      원소 하나만 가지고 노드를 생성한다. 루트 노드가 해당 집합의 대표 원소다.              Union      한 집합의 루트 노드를 다른 집합의 자식 노드로 연결한다.              Find      특정 원소가 속한 집합의 루트 노드를 찾아 반환한다.      ​연결 리스트를 통한 관리MakeSet​Union​Find​트리 구조를 이용한 관리MakeSet​Union​​​Find​코드로 구현연결 리스트와 트리 구조를 코드로 구현해 보겠습니다. 연결 리스트와 트리 구조의 노드는 구조체나 클래스 등을 통해서 만들 수 있지만 배열로도 구현이 가능합니다.배열의 인덱스가 각 원소의 번호이며 인덱스에 해당하는 값은 해당 인덱스(원소 번호) 가 가리키고 있는 노드의 원소 번호입니다. 따라서 집합 내에서 대표 원소는 최상위에 위치하므로 가리킬 대상이 없고 자기 자신을 가리키게 됩니다. 여기서는 배열의 이름을 parent 라고 하겠습니다. ( 예시로 원소는 8개, 1번 ~ 8번까지 있다고 가정하겠습니다. )MakeSetvoid MakeSet(int X) {  parent[x] = x;}            index      1      2      3      4      5      6      7      8                  parent      1      2      3      4      5      6      7      8      ​Unionvoid Union(int x, int y) {    x = Find(parent[x]);    y = Find(parent[y]);    parent[x] = y;}ex) Union(1, 2)            index      1      2      3      4      5      6      7      8                  parent      2      2      3      4      5      6      7      8      ex) Union(2, 3)            index      1      2      3      4      5      6      7      8                  parent      2      3      3      4      5      6      7      8      ​Findint Find(int x) {    if(parent[x] == x) return x;    return Find(parent[x]);}  재귀 방식을 통해서 루트 노드 혹은 헤드 노드까지 이동해서 해당 원소를 반환합니다.​문제점과 해결 방안 : 연결 리스트 방식지금까지 설명드린 방법은 가장 간단한 방법입니다.  여기서 문제점이 존재합니다. 바로 Find 연산입니다.  연결 리스트와 트리 구조 둘 다 깊이가 커지면 대표 원소를 찾는 시간이 그만큼 오래 걸리게 됩니다. 원소가 n개라면 최악의 경우에는 Find연산이 O(n) 이 됩니다. 연산 시간을 단축시키기 위해서는 어떻게 해야 할까요?각 노드에 헤드를 가리키는 포인터를 추가시킨다.이전에 설명드린 것처럼 연결 리스트는 꼬리(Tail) 부분에서 헤드를 찾게 되면 해당 집합의 모든 원소들을 거치게 됩니다. 운 좋게 원소 2를 지목하면 한 번 이동하고 바로 헤드를 찾게 되지만 그림처럼 꼬리 부분의 원소를 지목하게 될 경우에는 전체를 거쳐서 탐색 시간이 오래 걸리게 됩니다.​그래서 나온 해결책이  모든 노드에 헤드를 가리키는 포인터를 추가하는 것입니다. 그렇게 되면 어느 원소를 지목해도 상수 시간에 바로 헤드에 위치한 원소를 알 수 있습니다.​\t​  하지만 만약 Union을 진행하면 합쳐지는 집합의 모든 원소들이 가리키는 헤드 업데이트가 필요하다.​​​​\t​문제점과 해결 방안 : 트리 구조 방식유니온 바이 랭크(Union by rank)두 집합을 Union 할 때 트리의 깊이가 작은 집합을 트리의 깊이가 큰 집합의 루트 노드에 붙이는 방식입니다. 이러한 방식으로 유니온을 하면 두 트리의 깊이가 동일한 경우에만 깊이가 증가하게 됩니다. 따라서 깊이가 증가하는 것을 최대한 방지해서 Find 연산 시간을 단축시킵니다.​​  만약 유니온 바이 랭크를 적용하지 않는다면 유니온 했을 때 깊이가 증가할 수 있습니다.​​유니온 바이 랭크 구현 function MakeSet(x)     x.parent := x     x.rank   := 0 function Union(x, y)     xRoot := Find(x)     yRoot := Find(y)     // if x and y are already in the same set (i.e., have the same root or representative)     if xRoot == yRoot         return     // x and y are not in same set, so we merge them     if xRoot.rank &lt; yRoot.rank         xRoot.parent := yRoot     else if xRoot.rank &gt; yRoot.rank         yRoot.parent := xRoot     else         yRoot.parent := xRoot         xRoot.rank := xRoot.rank + 1  해당 코드는 wekipedia 서로소 집합 자료 구조에서 참조했음을 알려드립니다.  wekipedia 서로소 집합 자료 구조​경로 압축(path compression)Find(x) 연산은 원소 x 가 속한 집합의 대표 원소를 찾아줍니다. 가장 간단한 방법은 대표 원소를 찾아 반환하고 끝내는 방식이지만 경로 압축에서는 대표 원소를 반환하기 전에 x 를 루트 노드(대표 원소)에 연결하고 대표 원소를 반환합니다. 이렇게 하면 모든 원소들이 대표 원소를 의미하는 루트 노드를 가리키게 됩니다. 이런 방식으로 모든 원소들을 루트 노드(대표 원소)로 연결시키면 연산 시간을 단축시킬 수 있습니다.​​경로 압축 구현 function Find(x)     if x.parent != x        x.parent := Find(x.parent)     return x.parent  해당 코드는 wekipedia 서로소 집합 자료 구조에서 참조했음을 알려드립니다.  wekipedia 서로소 집합 자료 구조​참조wekipedia 서로소 집합 자료 구조신찬수 교수님 : 자료구조 - union-find 자료구조 1/2"
  },
  
  {
    "title": "Android 액티비티 생명주기",
    "url": "/posts/android-lifecycle/",
    "categories": "Android, 기본",
    "tags": "Android, 모바일, 안드로이드, 생명주기, 개발",
    "date": "2023-02-14 00:00:00 +0900",
    





    
    "snippet": "생명주기가 무엇인가?1. 소프트웨어 개발 계획의 시작부터 끝까지 따라야 할 단계와 그것에 따른 계획의 형태 변화.2. 소프트웨어가 만들어져서 폐기될 때까지의 기간.    사용자의 요구에 대한 분석 및 설계, 그리고 프로그램 작성을 거쳐 운용되는 일련의 과정을 포함한다.네이버 국어사전에서 말하는 생명 주기는 다음과 같습니다. 즉, 액티비티가 만들어지고 ...",
    "content": "생명주기가 무엇인가?1. 소프트웨어 개발 계획의 시작부터 끝까지 따라야 할 단계와 그것에 따른 계획의 형태 변화.2. 소프트웨어가 만들어져서 폐기될 때까지의 기간.    사용자의 요구에 대한 분석 및 설계, 그리고 프로그램 작성을 거쳐 운용되는 일련의 과정을 포함한다.네이버 국어사전에서 말하는 생명 주기는 다음과 같습니다. 즉, 액티비티가 만들어지고 없어질 때까지의 과정을 말합니다. 어떤 생명이 탄생해서 죽을 때까지의 과정이 존재하듯  안드로이드의 액티비티도 생성되어 소멸하기까지의 과정을 가지고 있습니다.​생명주기는 왜 있는가?그렇다면 이쯤에서 드는 생각이 있을 겁니다. 그러면 생명주기는 왜 있는 것인가? 이 질문에 대한 해답은 모바일 사용 환경을 생각해 보면 됩니다. 다음과 같은 경우를 생각해 봅시다.  사용자가 앱을 사용하는 도중에 전화가 왔을 때  사용자가 앱에서 나갔다가 돌아왔을 때 이전의 데이터들이 저장되지 않는 문제  세로 모드로 사용하다가 가로로 돌려서 가로 모드로 전환  앱을 사용하는 도중에 홈 화면으로 이동 후, 다른 앱을 실행시킬 때네 가지 경우를 보면 모바일 사용자 환경에서는 많은 상태 변화가 발생한다는 것을 알 수 있습니다. 아마 사용자 입장에서는 위의 상황들이 발생해도 아무런 오류가 없이 매끄럽게 앱이 작동되길 바랄 겁니다.앱이 아무런 오류 없이 매끄럽게 동작하려면 어떻게 해야 할까요? 바로 다양한 상태 변화가 발생했을 때 상태에 따라 알맞은 작업을 하고 적절한 전환을 처리해야 할 것입니다. 그래서 현재 앱이 어떤 상태에 있는지를 계속 파악하는 것이 중요하고 이를 파악하기 위해서 생명주기가 있는 것입니다.​Android의 생명주기생명주기의 시작은 탄생이고 끝은 죽음입니다. 그리고 그 사이에는 다양한 상태들이 존재합니다. 탄생 후에 본격적으로 활동을 위한 준비단계가 있을 것이며 많은 활동 끝에 죽음을 준비하기 위한 단계도 있을 것입니다.안드로이드에서 정의한 액티비티의 생명주기 단계들은 시작과 실행 사이에  onCreate(),  onStart(),  onResume()  순서로 있고 실행과 종료 사이에  onPause(), onStop(), onDestroy() 순으로 여러 상태들이 존재합니다. 따라서 사용자가 앱을 이용하면 그 과정에서 여러 가지의 상태 변화가 발생하는데 이는 생명주기에 따라 적절히 처리됩니다.​생명주기 처리를 위한 콜백 메서드상황에 따라 적절한 처리를 해주려면 생명주기 내에서 해당 상황에 맞는 특정 상태를 알 수 있어야 합니다. 어떤 상태인지를 알아야 그에 맞는 처리를 해줄 수 있으니까요. 안드로이드는 이를 위해 생명주기 내의 다양한 단계들을 콜백 형태로 제공합니다.액티비티 클래스는 onCreate(),  onStart(), onResume() , onPause(), onStop(),onDestroy() 함수들을 상속받습니다. 상속을 받고 이 함수들을 필요에 따라 재정의 하여 특정 상황의 발생으로 인해서 호출이 됐을 때 재정의 한 내용을 토대로 처리를 하게 됩니다. 예를 들어서 가로 모드로 전환을 했을 때는 화면의 구성이 바뀌므로 수명주기의 상태는 onCreate() 에 해당이 되어 시스템에서 onCreate() 콜백을 호출합니다.  이렇게 각 콜백은 상태 변화에 적합한 특정 작업을 실행할 수 있도록 하고 적시에 알맞은 작업과 적절한 전환을 통해 앱이 더욱 안정적으로 기능할 수 있도록 해줍니다.​콜백 메서드 소개지금까지 생명주기가 왜 존재하고 어떻게 처리하는지 알아봤습니다. 콜백 호출을 통해서 상태 변화에 대응한다는 것을 알았으므로 이제는 각 콜백 메서드의 역할과 특징에 대해 알아보겠습니다.onCreate()시스템이 액티비티를 생성할 때 실행되고 필수적으로 구현해야 하는 콜백 메서드입니다. onCreate() 메서드에서는 액티비티의 전체 수명 주기 동안 한 번만 발생해야 하는 기본 애플리케이션 시작 로직을 실행합니다. 예를 들어 데이터 바인딩, ViewModel 연결, 클래스 인스턴스화 등을 onCreate() 에서 처리한다고 보면 되겠습니다. 대표적으로 레이아웃 XML을 액티비티로 불러올 때 setContentView() 함수를 onCreate() 에서 호출합니다.onCreate() 메서드는 savedInstanceState 를 매개변수로 받는데 이는 Bundle 객체입니다. savedInstanceState 는 액티비티의 이전 상태 정보들을 가지고 있습니다. 액티비티가 어떤 이유로 화면을 재구성하게 된다면 기존에 존재하던 값들이 초기화되는 것을 방지할 필요가 있을 수도 있습니다. 그래서 따로 저장을 해두면 나중에 액티비티가 다시 생성될 때 savedInstanceState 를 이용하여 저장했던 값들을 불러올 수 있습니다.마지막으로 onCreate() 가 호출이 완료되면 시스템은 거기서 멈추지 않고 뒤이어 onStart() 와  onResume() 콜백 메서드를 호출합니다.override fun onCreate(savedInstanceState: Bundle?) {    super.onCreate(savedInstanceState)    binding = ActivityMainBinding.inflate(layoutInflater)    val view = binding.root    setContentView(view)}​onStart()액티비티가 사용자에게 표시되고 앱은 액티비티를 포그라운드에 보내서 상호작용을 준비합니다. 액티비티는 사용자에게 표시되지만 아직은 상호작용을 할 수 없는 단계입니다. 상호작용 준비를 위해서 이 단계에서 UI를 관리하는 코드를 초기화합니다.onStart() 는 매우 빠르게 완료되고 onCreate() 때와 마찬가지로 시스템은 여기서 머무르지 않고  onResume()  콜백 메서드를 호출하게 됩니다.​onResume()액티비티가 포그라운드에 표시되고 사용자와 상호작용을 시작합니다. 중간에 전화가 와서 포커스가 전화 알람으로 이동하거나 다른 액티비티로 화면 전환을 하여 포커스가 이동한 액티비티로 전환되거나 기기 화면이 꺼져서 포커스를 잃는 등의 현재 액티비티에 대한 포커스 소실이 발생하면 앱은  onResume() 에서 벗어나고 그렇지 않다면 onResume()  상태에서 머물게 됩니다.만약 현재 상태에서 방해 이벤트가 발생한다면 액티비티는 일시 중지 상태를 의미하는 onPause() 콜백 메서드를 호출해서 상태 변화를 합니다. 일시 중지 상태에서 다시 액티비티로 돌아온다면 시스템은 다시  onResume() 를 호출합니다.​onPause()사용자가 액티비티를 떠날 때 첫 번째로 호출되는 콜백 메서드입니다.  액티비티가 포그라운드에서 벗어나는 경우 일시중지 상태로 전환됩니다. 이 일시 중지는 onPasue() 를 의미합니다. onPause() 가 호출되는 경우는 onResume() 에서 설명한 예시들에 해당됩니다.액티비티가 포그라운드에 있지 않다면 일시 중지 상태가 되어 원래 사용됐던 기능들을 실행할 필요가 없어지게 됩니다. 그래서 이때는 필요에 따라 onPause() 메서드를 이용하여 시스템 리소스, GPS, 배터리 수명에 영향을 미칠 수 있는 리소스들을 해제할 수도 있습니다.하지만 주의할 점이 있습니다.  onPause() 는 잠깐동안 실행되므로 시간이 길어질 수 있는 애플리케이션 또는 사용자 데이터 저장, 네트워크 호출, 데이터베이스 트랜잭션 등의 작업은 onPause() 가 끝난 후에도 완료가 안될 수도 있습니다. 그래서 공식 문서에서는 이러한 작업들은 onPause() 에서 하지 말고 onStop() 상태일 때 처리하라고 추천합니다.액티비티가 다시 포그라운드에 복귀하면 시스템은 다시 onResume() 을 호출하게 됩니다. 일시 중지 상태에서 재개 상태로 돌아오면 그 과정에서 시스템은 액티비티의 인스턴스를 메모리에 보관했다가 onResume() 을 호출할 때 메모리에 머물고 있던 인스턴스를 호출합니다.​onStop()액티비티가 사용자에게 더 이상 표시되지 않으면 onStop() 을 호출합니다. 기존 액티비티에서 다른 액티비티로 완전히 전환되거나 액티비티의 실행이 완료되어 종료되는 시점에 해당 콜백을 호출합니다. 예를 들어서 앱 사용 중에 홈 화면으로 이동하면 액티비티가 포그라운드에서 벗어나 화면에서 사라지므로  onPause() 가 실행된 후에 onStop() 이 호출됩니다.onStop() 에서도 onPause() 와 마찬가지로 앱이 사용자에게 보이지 않는 동안 앱에서 필요하지 않은 리소스를 해제하거나 조정할 수 있습니다. onPause() 에서는 비교적 가벼운 작업을 처리했다면 여기서는 CPU를 비교적 많이 소모하는 종료 작업 실행을 추천합니다. 데이터베이스에 정보를 저장하는 작업 같은 것을 현재 상태일 때 처리할 수도 있습니다.또한 액티비티가 중단 상태에서 재개 상태로 바뀔 때 onPause() 와 마찬가지로 액티비티 객체가 메모리에 머물다가 다시 시작되면 액티비티 객체 정보가 호출됩니다.onStop() 상태에서는 두 가지 경우가 발생할 수 있습니다. 첫 번째는 액티비티를 다시 재개하는 것이고 두 번째는 액티비티를 종료하는 것입니다. 첫 번째 경우는 onRestart() 가 호출되어 다시 재개하는 과정을 거치고 두 번째는 onDestroy() 가 호출됩니다.​onDestroy()액티비티가 소멸되기 전에 호출되는데 해당 콜백이 호출되는 경우는 다음과 같습니다.  사용자가 액티비티를 완전히 닫거나 finish()  를 호출하여 액티비티가 종료되는 경우  기기 회전이나 멀티 윈도우 모드로 인해서 일시적으로 액티비티를 소멸시키는 경우onDestroy() 는 액티비티가 종료된다면 수명 주기에서 마지막으로 수신하는 콜백 메서드가 됩니다. 따라서 이전에 미처 해제하지 못했던 모든 리소스들을 여기서 처리하고 끝내야 합니다.​여러 상황에서 생명주기지금까지 생명주기의 각 콜백들의 역할과 특징들을 알아봤습니다. 이제는 직접 여러 상황들을 구현하여 생명주기가 어떻게 되는지 알아보겠습니다. 실습에 사용되는 액티비티는 총 두 개, 메인 액티비티와 서브 액티비티가 되겠습니다.앱 실행을 하면 시작 액티비티는 메인 액티비티가 되고 메인에는 서브 액티비티로 전환할 수 있는 버튼이 하나 있습니다. 서브 액티비티에는 메인 액티비티로 전환할 수 있는 버튼 하나와 숫자를 카운트할 수 있는 카운트 버튼이 존재합니다. 각 액티비티의 코드는 다음과 같습니다.MainActivity 코드class MainActivity : AppCompatActivity() {    private lateinit var binding: ActivityMainBinding    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        Log.d(\"MainActivity\", \"onCreate\")        binding = ActivityMainBinding.inflate(layoutInflater)        val view = binding.root        setContentView(view)        binding.btnMoveAnotherActivity.setOnClickListener {            startActivity(Intent(this, SubActivity::class.java))            finish()        }    }    override fun onStart() {        super.onStart()        Log.d(\"MainActivity\", \"onStart\")    }    override fun onResume() {        super.onResume()        Log.d(\"MainActivity\", \"onResume\")    }    override fun onPause() {        super.onPause()        Log.d(\"MainActivity\", \"onPause\")    }    override fun onStop() {        super.onStop()        Log.d(\"MainActivity\", \"onStop\")    }    override fun onDestroy() {        super.onDestroy()        Log.d(\"MainActivity\", \"onDestroy\")    }    override fun onRestart() {        super.onRestart()        Log.d(\"MainActivity\", \"onRestart\")    }}​SubActivity 코드class SubActivity : AppCompatActivity() {private lateinit var binding: ActivitySubBindingprivate var counter: Int = 0    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        Log.d(\"SubActivity\", \"onCreate\")        binding = ActivitySubBinding.inflate(layoutInflater)        val view = binding.root        setContentView(view)        binding.tvCounter.text = counter.toString()        binding.btnMoveMainActivity.setOnClickListener {            startActivity(Intent(this, MainActivity::class.java))            finish()        }        binding.btnAddCount.setOnClickListener {            counter += 1            binding.tvCounter.text = counter.toString()            Log.d(\"Counter 증가 요청\", \"${binding.tvCounter.text}\")        }    }    override fun onStart() {        super.onStart()        Log.d(\"SubActivity\", \"onStart\")    }    override fun onResume() {        super.onResume()        Log.d(\"SubActivity\", \"onResume\")    }    override fun onPause() {        super.onPause()        Log.d(\"SubActivity\", \"onPause\")    }    override fun onStop() {        super.onStop()        Log.d(\"SubActivity\", \"onStop\")    }    override fun onDestroy() {        super.onDestroy()        Log.d(\"SubActivity\", \"onDestroy\")    }    override fun onRestart() {        super.onRestart()        Log.d(\"SubActivity\", \"onRestart\")    }}​앱 실행홈 화면에서 앱을 실행합니다.초기 액티비티를 생성하므로 onCreate() 부터 호출이 됩니다.MainActivity onCreateMainActivity onStartMainActivity onResume​액티비티 전환메인 액티비티에서 서브 액티비티로 전환합니다.메인 액티비티의 소멸까지 기다렸다가 서브 액티비티가 생성되는 것이 아닙니다. 메인 액티비티를 일시 중지 시켜놓고 서브 액티비티를 onResume() 까지 진행시킨 다음, 그 뒤에 메인 액티비티를 종료시키는 겁니다. 액티비티의 전환은 이렇게 처리됩니다.  MainActivity의 onPause() 메서드가 실행된다.  SubActivity의 onCreate(), onStart(), onResume() 메서드가 순차적으로 실행된다.  MainActivity는 finish()  호출로 onDestroy() 까지 호출되어 소멸된다.MainActivity onPauseSubActivity onCreateSubActivity onStartSubActivity onResumeMainActivity onStopMainActivity onDestroy​세로 모드에서 가로 모드로 전환메인 액티비티에서 가로 모드로 전환했습니다.위의 콜백 메서드 설명 부분에서도 언급했지만 화면 구성이 변경될 경우(가로 모드로 전환) 시스템은 액티비티를 소멸시키고 다시 생성하여 가로 모드에 대한 구성을 진행합니다.MainActivity onPauseMainActivity onStopMainActivity onDestroyMainActivity onCreateMainActivity onStartMainActivity onResume​가로 모드로 전환될 때 데이터 상태서브 액티비티에서 카운터를 증가시킨 후 가로 모드로 전환했을 때 과연 카운터 데이터는 유지될까요? 유지되지 않습니다. 가로 모드로 전환하면 액티비티가 소멸되고 다시 생성되기 때문에 데이터도 초기화가 됩니다.​홈 화면으로 이동메인 액티비티에서 홈 화면으로 이동을 해봤습니다.액티비티 화면이 포그라운드에서 벗어나 사용자 시야에서 완전히 사라지므로 onStop() 까지 진행됐습니다.MainActivity onPauseMainActivity onStop​홈 화면에서 앱으로 다시 이동이제 다시 홈 화면에서 메인 액티비티로 돌아갑니다.중단 상태에서 액티비티가 재개하므로 onRestart() 를 시작으로 onResume() 까지 호출됩니다.MainActivity onRestartMainActivity onStartMainActivity onResume​앱 종료앱을 완전히 종료시킵니다.앱이 종료됨에 따라서 액티비티도 소멸하므로 onDestroy() 까지 호출되고 액티비티는 소멸합니다.MainActivity onPauseMainActivity onStopMainActivity onDestroy​마치면서…지금까지 생명주기의 뜻부터 예시까지 알아봤습니다. 이 글은 안드로이드 공식 문서를 참고하여 작성했으며 제 나름대로 해석을 하면서 작성한 거라 잘못된 부분이 있을 수도 있습니다. 혹시라도 잘못된 부분이 있어서 알려주신다면 바로 수정하겠습니다. 긴 글 읽어주셔서 감사합니다!​참조Android 공식 문서제이슨의 개발이야기Dev.Cho - Dev World"
  },
  
  {
    "title": "Chirpy 테마를 이용한 Github 블로그 만들기",
    "url": "/posts/Make-Github-blog/",
    "categories": "블로그, Github 블로그 만들기",
    "tags": "Github 블로그",
    "date": "2023-01-14 00:00:00 +0900",
    





    
    "snippet": "시작하기에 앞서 참고해주세요!jekyll의 Chirpy 테마를 기준으로 진행합니다. 현재 이 블로그의 테마가 Chirpy 테마이며 이 블로그의 테마 디자인이 마음에 들어서 해당 테마가 적용된 깃허브 블로그를 만들고 싶다면 이 글을 참고하시면 좋을 것 같습니다.저는 Chirpy 테마를 적용하기 위해서 해당 테마에 대한 여러 블로그 글과 제작자의 가이드를...",
    "content": "시작하기에 앞서 참고해주세요!jekyll의 Chirpy 테마를 기준으로 진행합니다. 현재 이 블로그의 테마가 Chirpy 테마이며 이 블로그의 테마 디자인이 마음에 들어서 해당 테마가 적용된 깃허브 블로그를 만들고 싶다면 이 글을 참고하시면 좋을 것 같습니다.저는 Chirpy 테마를 적용하기 위해서 해당 테마에 대한 여러 블로그 글과 제작자의 가이드를 참고해서 하라는 대로 따라 했는데 중간 과정들의 결과가 블로그의 글과 달라서 당황했던 기억이 있습니다. 아무래도 제작자분이 해당 테마의 적용 방식에 대한 업데이트를 여러 번 진행해서 적용 방법이 이전과 약간 달라진 것 같습니다.그래서 앞으로 Chirpy 테마를 적용하려는 분들에게 적용 방법과  제가 겪었던 문제점들을 공유하고자 합니다. 아마 이 글을 쓰는 와중에도 제가 적용한 방식이 최신이 아닌 이전 방식이 될 수도 있습니다. 이 점을 참고하고 읽어주시면 감사하겠습니다.​사전 준비다음 세 가지를 준비해 주세요. 테마 적용 과정과 에러 해결에 중점을 두기 때문에 다음 세 가지에 대한 자세한 설명은 생략하겠습니다.  구글에 자세하게 정리된 글이 많으므로 검색해서 참고하시길 바랍니다.      Git, Github        Ruby 를 설치해 주세요. 제가 사용하고 있는 루비 버전은 3.1.3p  입니다. 설치가 완료되면 다음 명령과 같이 루비 버전이 출력되는지 확인해 주세요.  Ruby -vruby 3.1.3p185 (2022-11-24 revision 1a6b16756e) [x86_64-darwin22]  jekyll을 설치해 주세요.gem install jekyll bundler​Github에서 저장소 생성하기모든 준비가 끝났다면 블로그 운영에 필요한 파일들을 저장할 저장소부터 생성합니다. 다음과 같이 본인의 깃허브 네임과 그 뒤에  github.io 을 붙여서 저장소 이름을 만들어주세요. 공개 범위는 public으로 설정합니다.저는 이미 블로그를 위한 저장소가 존재하므로 다음과 같이 이미 해당 이름의 저장소가 존재한다고 메시지가 나옵니다.​테마 파일들 가져오기포크 방식과 압축파일을 다운로드하는 방법이 있는데 저는 두 번째 방법인 압축파일 다운로드 방식을 기준으로 설명하겠습니다.두 가지 방법  테마 저장소 를  fork 해서 fork한 저장소 이름을 {본인의 깃허브 네임}.github.io로 변경해서 사용          포크 한 저장소를 git clone을 통해서 연결한다.        테마 저장소 Download zip을 통해서 가져오기          저장소를 직접 만들고 git clone으로 연결한 후에 다운로드한 폴더를 저장소와 연결된 로컬 폴더에 넣는다.      ​zip 다운로드​테마 파일 초기화현재 다운로드한 테마 파일들은 완전히 초기의 상태가 아니라 제작자에 의해서 계속해서 업데이트가 된 상태입니다. 따라서 본인만의 블로그를 세팅하려면 초기 상태로 만들어줘야 합니다. 초기화 코드는 다음과 같습니다. 해당 코드는 제작자의 시작 가이드에서 가져왔습니다.bash tools/init​그런데 문제가….테마 파일을 다운로드하면 그중에 tools  라는 이름의 폴더가 있는데 그 안에 init 이 존재합니다. 이 init 을 이용해서 초기화를 진행시키는 것입니다. 그런데 저는 아무리 시도해 봐도 tools 디렉터리가 인식이 안되는 건지 초기화가 안됐습니다. 폴더가 존재하는데 디렉터리가 없다고 계속 오류가 발생해서 결국 터미널을 통한 초기화를 할 수 없었습니다. 혹시라도 이유를 아시는 분은 알려주시면 감사하겠습니다…  bash 사용이 제한이 되거나 저처럼 초기화가 안되는 경우에는 직접 테마 폴더를 건드려서 초기화를 하면 됩니다.​직접 초기화?직접 초기화는 다운로드한 테마 폴더 내의 파일 혹은 폴더들을 수정하거나 삭제하는 방식입니다. 다른 블로그들의 글에서 삭제하라는 파일 혹은 폴더가 현재 다운로드한 폴더 내에 없을 수 있습니다. 아마 이 부분도 제작자가 업데이트하면서 일부는 없앤 것 같습니다. 그래서 있는 것들만 수정하거나 삭제하시면 됩니다.  테마 폴더 내 숨겨진 파일들도 수정 및 삭제하므로 초기화 전에 숨김 파일 표시를 해주세요.​수정 및 삭제 목록  .github 폴더 내에 workflows 폴더를 제외하고 모두 삭제  github/workflows 내에 commitlint.yml 과 page-deploy.yml.hook 제외하고 모두 삭제  page-deploy.yml.hook 파일의 .hook 부분을 없애서 page-deploy.yml 로 수정      _config.yml 에서 url: '' 부분에 본인의 깃허브 블로그 주소 넣기    .github/workflows/page-deploy.yml 에서 루비 버전을 로컬 버전이랑 맞춰주세요. jobs:  내의  build: 부분을 찾아보면 밑의 코드처럼 루비 설정에 관한 부분을 찾을 수 있습니다. 제가 사용하는 루비 버전은 3.1.3 이므로 ruby-version: \"\"  에 3.1.3  를 적었습니다.jobs:  build:      - name: Setup Ruby        uses: ruby/setup-ruby@v1        with:          ruby-version: \"3.1.3\" # reads from a '.ruby-version' or '.tools-version' file if 'ruby-version' is omitted          bundler-cache: true  .github/workflows/page-deploy.yml 에서 설정된 브랜치를 확인해 주세요. 2번 라인에 밑의 코드를 확인할 수 있습니다. 연결된 저장소에 저 둘 중에 해당되는 브랜치가 있으면 됩니다. 제 저장소는 main 브랜치를 사용했습니다.on:  push:    branches:      - main      - master    paths-ignore:      - .gitignore      - README.md      - LICENSE  page-deploy.yml 에 등록된 브랜치와 루비 정보를 토대로 build가 진행됩니다.​깃허브 저장소에 PUSH그 전에 로컬 주소로 테스트 해보기bundle exec jekyll serveServer address: http://127.0.0.1:4000/깃허브에 올리기 전에 위의 첫 번째 명령을 실행했다면 두 번째의 로컬 주소를 얻을 수 있습니다.  해당 주소로 이동해서 블로그 상태를 체크해 보세요. 아마 _posts 폴더에 있던 가이드 파일들을 그대로 뒀다면 블로그 글 목록에 가이드 글들이 나타날 것이고, 전부 삭제를 했다면 블로그 글이 하나도 없는 깨끗한 상태일 것입니다.저는 나중에 글 쓰면서 가이드를 참고하기 위해서 완전히 삭제하지 않고 따로 바탕화면에 옮겼습니다. 가이드 글은 제작자의 데모 사이트에도 있으니 그냥 삭제하셔도 됩니다.​Github Actions이제 커밋을 하고 푸시를 하면 저장소 상단 탭에 있는 Actions 에서 블로그 빌드가 진행됩니다. 빌드는 완료되는 데 약간 시간이 걸립니다. 빌드가 정상적으로 끝났다면 이제 본인의 깃허브 블로그 주소에 접속해 보세요. 테마가 적용된 모습을 볼 수 있습니다.하지만 저는 여기서 오류가 발생했었는데 루비와 관련된 에러였습니다. .github/workflows/page-deploy.yml 에서 분명 루비 버전도  3.1.3 으로 맞췄는데 이런 오류가 뜨니 당황스러웠습니다.Error: The process '/opt/hostedtoolcache/Ruby/3.1.3/x64/bin/bundle' failed with exit code 16해당 문제에 대해서 구글링을 한 결과,  스택 오버플로우의 도움을 받아서 다음 코드를 통해 해결할 수 있었습니다. 저와 같은 오류가 발생했다면 해당 글을 참고해 보시면 좋을 것 같습니다.bundle lock --add-platform x86_64-linux​해치웠나?해당 오류는 다행히 해결이 돼서 정상적으로 빌드가 됐습니다. 이제 블로그를 작성할 모든 준비가 됐습니다. 이제 _posts 내에 마크다운 파일을 만들어서 글을 적고 깃허브에 올리는 과정을 반복하여 블로그 글을 채워나가면 됩니다.​참조테마 적용 과정      제작자의 데모 사이트    하얀눈길님 블로그  Jaewoo님 블로그  Ju-ing님 블로그오류 참고  hashnsalt님 블로그"
  }
  
]

