[
  
  {
    "title": "(프로그래머스 | Kotlin) - 수식 최대화",
    "url": "/posts/KotlinAlgorithm6/",
    "categories": "CS, 알고리즘 문제",
    "tags": "Kotlin, Algorithm, 알고리즘, 프로그래머스",
    "date": "2023-11-10 21:00:00 +0900",
    





    
    "snippet": "해결 방법뭔가 풀이 방법이 다양할 것 같은 문제인데 나는 재귀를 이용해서 해결했다. 연산 기호가 최대 세 개인데 연산 우선순위를 리스트로 표현했다. 예를 들어서 표현식에서 사용된 연산 기호가 * - , 2개라면 만들 수 있는 우선순위 조합은 2개, [[*, -], [-, *]]  이렇게 리스트로 표현이 가능하다. 인덱스가 클수록 연산 우선순위가 높다는...",
    "content": "해결 방법뭔가 풀이 방법이 다양할 것 같은 문제인데 나는 재귀를 이용해서 해결했다. 연산 기호가 최대 세 개인데 연산 우선순위를 리스트로 표현했다. 예를 들어서 표현식에서 사용된 연산 기호가 * - , 2개라면 만들 수 있는 우선순위 조합은 2개, [[*, -], [-, *]]  이렇게 리스트로 표현이 가능하다. 인덱스가 클수록 연산 우선순위가 높다는 뜻이다.이런 식으로 만들 수 있는 연산 우선순위를 모두 만들고 모든 경우에 대해 식을 계산하고 결과값을 비교해서 가장 큰 값을 리턴하면 문제 해결이 가능하다. 그런데 문제는 식을 계산하는 방법이다. 여기서 풀이 방법이 다양하게 갈릴 것 같은데 내가 푼 방법은 다음과 같다.1. 나올 수 있는 연산 우선순위 조합 모두 구하기\"100-200*300-500+20\" 예제를 예시로 생각해보자. 사용된 연산자는 * - + 총 세 개, 나올 수 있는 연산 우선순위 조합은 총 여섯 개다. 우선 이 여섯 개를 구하는 알고리즘을 짜야 한다. 이는 순열 알고리즘을 이용해서 구하면 된다.제네릭 함수, 리스트 확장함수, 연산자 함수를 응용한 깔끔한 순열 알고리즘이다. 자세한 원리는 링크를 통해서 확인하면 된다. 개인적으로 가장 깔끔한 순열 알고리즘인 것 같다.private fun &lt;T&gt; permutation(sub: List&lt;T&gt;, fin: List&lt;T&gt; = listOf()): List&lt;List&lt;T&gt;&gt; {    return if(sub.isEmpty()) listOf(fin)    else sub.flatMap { permutation(sub - it, fin + it) }}permutation(listOf('*', '-', '+'))// [*, +, -]// [*, -, +]// [+, *, -]// [+, -, *]// [-, *, +]// [-, +, *]2. 재귀를 이용한 식 계산permutation(existingOperator.toList()).forEach {    answer = max(answer, abs(rec(expression, it.toList())))}rec : 식을 계산한 결과값을 반환하는 재귀 함수이고 계산할 식이 담긴 문자열과 연산 우선순위 정보를 인자로 넘긴다. 그리고 계산 결과의 절대값으로 비교를 해야 하므로 abs 로 감싸준다. 이렇게 메인 함수에서 틀을 잡는다.다음은 rec 함수 구현 부분이다. 해당 함수로 넘기는 인자는 \"100-200*300-500+20\" , [*, +, -] 라고 가정해보자."
  },
  
  {
    "title": "Kotlin Generic (1) 제네릭 클래스와 함수, 그리고 변성",
    "url": "/posts/Kotlin-Generic/",
    "categories": "CS, 프로그래밍 언어",
    "tags": "Kotlin, Java, Generic, 제네릭",
    "date": "2023-11-09 12:00:00 +0900",
    





    
    "snippet": "Kotlin도 Java의 제네릭 기능을 제공한다.  “Classes in Kotlin can have type parameters, just like in Java:” - Kotlin 공식 문서코틀린의 클래스는 자바와 마찬가지로 타입 파라미터를 가질 수 있습니다. 제네릭을 사용함으로써 컴파일 타임에 타입 안전성을 관리할 수 있고 여러 타입에 대응하여 ...",
    "content": "Kotlin도 Java의 제네릭 기능을 제공한다.  “Classes in Kotlin can have type parameters, just like in Java:” - Kotlin 공식 문서코틀린의 클래스는 자바와 마찬가지로 타입 파라미터를 가질 수 있습니다. 제네릭을 사용함으로써 컴파일 타임에 타입 안전성을 관리할 수 있고 여러 타입에 대응하여 코드를 재사용하는 이점을 얻을 수 있습니다.코틀린 역시  &lt;&gt; 기호를 이용한 제네릭 기능을 제공합니다. 다음 Box 클래스는 제네릭을 사용하여 만들어졌기 때문에  Int , String, Float 등의 다양한 타입을 가질 수 있습니다.class Box&lt;T&gt;(t: T) {    var value = t}val boxInt: Box&lt;Int&gt; = Box&lt;Int&gt;(1)val boxString: Box&lt;String&gt; = Box&lt;String&gt;(\"empty\")val boxFloat: Box&lt;Float&gt; = Box&lt;Float&gt;(2.0F)위의 예시를 통해서 제네릭(Generic)은 단순히 하나의 타입으로 고정하는 것이 아닌 다양한 타입을 수용할 수 있는 하나의 일반화(Generalization)된 타입 파라미터라고 할 수 있습니다.위의 예제에서는 타입 파라미터 정의를 T 로 했는데 이는 제네릭을 사용할 때 무조건 T 를 사용해야 한다는 뜻이 아닙니다. 제네릭에서 사용되는 기호는 정해진 것이 아닌 사용자가 직접 정의합니다. 그래서 상황에 따라 네이밍을 하면 됩니다.            유형      의미                  &lt;T&gt;      Type              &lt;E&gt;      Element              &lt;K&gt;      Key              &lt;V&gt;      Value              &lt;N&gt;      Number      ​타입 안전성제네릭을 사용하지 않은 클래스의 경우는?Animal 추상 클래스가 있고, 해당 추상 클래스의 구현체인 Tiger,  Lion 이렇게 두 개의 클래스가 존재하는 상황이라고 가정하겠습니다. 동물의 정보와 관련된 클래스를 정의했으므로 이제 동물들을 관리하는 동물원, Zoo 클래스를 정의합니다.abstract class Animalabstract class Mammalia: Animal()class Tiger: Mammalia()class Lion: Mammalia()class Zoo {    private val animals = mutableListOf&lt;Animal&gt;()    fun getLast(): Animal {        return animals.last()    }    fun getFirst(): Animal {        return animals.first()    }    fun add(animal: Animal) {        animals.add(animal)    }}메인 함수에서 호랑이를 동물원에 추가하고 다시 꺼내오는 작업을 했을 때 Tiger로 받으려면 다운캐스팅이기 때문에 변환 타입을 명시해야 합니다.val zoo = Zoo()zoo.add(Tiger())val tiger: Tiger = zoo.getLast() as Tiger그런데 동물 리스트에서 데이터를 꺼내올 때 해당 데이터가 무조건 Tiger 라는 보장이 없습니다. 데이터를 삽입할 때 Tiger 가 아닌 Lion 을 넣을수도 있기 때문입니다. 그래서 as? 를 이용하거나 엘비스 연산자 ?: 를 이용해서 예외에 대응하는 방법이 있습니다만…​제네릭 클래스로 수정하자제네릭을 이용한다면 타입 미스매치 발생을 방지하고 코드 가독성도 좋게 만들 수 있습니다. 동물들을 관리하는 Zoo 클래스에 타입 파라미터 T 를 정의하여 수정하면 클래스 생성부터  Tiger 타입 지정이 가능합니다.이렇게 제네릭 클래스로 만들면 컴파일 타임에 타입 오류를 찾아낼 수 있고 Tiger 를 관리하는 동물원 Zoo 로 관리가 가능합니다. 그래서 as 를 사용해서 캐스팅할 타입을 명시하지 않아도 깔끔하고 안전하게 데이터를 가져올 수 있습니다.class Zoo&lt;T&gt; {    private val animals = mutableListOf&lt;T&gt;()    fun getLast(): T {        return animals.last()    }    fun getFirst(): T {        return animals.first()    }    fun add(animal: T) {        animals.add(animal)    }}val zoo = Zoo&lt;Tiger&gt;()zoo.add(Tiger())val tiger: Tiger = zoo.getLast()​변성변성(Variance)변성(Variance)은 제네릭 클래스끼리의 상속 관계를 나타내는 개념입니다. 변성은 크게 공변, 반공변, 무공변 이렇게 세 가지로 나눌 수 있는데 해당 세 가지의 정의는 다음과 같습니다.            유형      의미                  공변(Covariance)      Tiger 가 Mammalia 의 서브타입이라면 Zoo&lt;Tiger&gt; 는 Zoo&lt;Mammalia&gt; 의 서브타입이다.              반공변(Contravariance)      Tiger 가 Mammalia 의 서브타입이라면 Zoo&lt;Mammalia&gt; 는 Zoo&lt;Tiger&gt; 의 서브타입이다.              무공변(Invariance)      공변도 아니고 반공변도 아닌 상태      ​제네릭 클래스는 기본적으로 무공변동물원 예시 코드를 조금 수정하겠습니다. 다음과 같이 Tiger Lion 의 상위타입인 Mammalia 를 타입 파라미터로 가지는 제네릭 클래스를 생성해서 거기에 Tiger Lion 클래스를 add 해보겠습니다.val zooWithMammalia = Zoo&lt;Mammalia&gt;()zooWithMammalia.add(Tiger())zooWithMammalia.add(Lion())Mammalia 를 타입 파라미터로 가지는 Zoo&lt;Mammalia 의 add 메서드는 파라미터가 animal: Mammalia 로 설정이 되고 여기에 인자로 Tiger , Lion 이 온다면 서로 상속 관계이기 때문에 컴파일 및 실행에 문제가 없습니다.fun add(animal: T) { // animal: Mammalia    animals.add(animal)}이렇게 단일 동물을 다른 동물원에 추가하는 데 문제가 발생하지 않지만 동물원 자체를 다른 동물원에 합치는 경우는 어떨까요? 다음과 같이 동물원 자체를 합치는 메서드를 추가로 작성해보겠습니다.fun mergeOtherZoo(zoo: Zoo&lt;T&gt;) {    this.animals.addAll(zoo.animals)}그리고 Zoo&lt;Mammalia&gt; 에 Zoo&lt;Tiger&gt; 를 병합시켜보겠습니다. 결과는 단일 동물을 추가할 때와 달리 타입 미스매치가 발생합니다.val zooWithTigers = Zoo&lt;Tiger&gt;()val zooWithMammalia = Zoo&lt;Mammalia&gt;()zooWithTigers.add(Tiger())zooWithMammalia.mergeOtherZoo(zooWithTigers) // Type mismatch 발생분명 Zoo&lt;Mammalia&gt; 에 Tiger() 를 추가하는 것은 문제가 없었는데 Zoo&lt;Tiger&gt; 를 추가하는 것에는 문제가 발생합니다. 이는 제네릭 클래스는 기본적으로 무공변 상태이기 때문에 아무런 관계가 없는  Zoo&lt;Mammalia&gt; 와 Zoo&lt;Tiger&gt; 는 병합 시도시 오류가 발생할 수밖에 없는 겁니다.​공변으로 전환이를 해결하기 위해서는 무공변인 상태를 공변으로 전환해야 합니다. 전환하는 방법은 간단합니다. 병합하는 메서드의 타입 파라미터 왼쪽에 out 이라는 키워드를 추가하면 됩니다. 이 결과로 본인의 하위타입을 수용할 수 있고 타입 미스매치 오류가 사라지면서 정상 실행이 됩니다.fun mergeOtherZoo(zoo: Zoo&lt;out T&gt;) {    this.animals.addAll(zoo.animals)}​공변으로 전환시 주의할 점무공변 상태에서 공변으로 전환을 하면 제네릭 클래스 간 상속 관계가 생겨서 인자로 넘길 수 있게 되지만 주의할 점이 있습니다. 만약에 mergeOtherZoo 메서드 내부 코드가 반대로 인자로 받은 동물원에 기존 동물원을 합치는 경우면 어떻게 될까요?타입 미스매치가 발생하게 됩니다. out 을 사용한 시점에서 인자로 받는 zoo 는 자신을 인자로 필요로 한 클래스의 서브 타입일 수 있기 때문에 하위타입에 상위타입의 데이터를 넣는 동작은 타입 안전성을 해칠 수 있습니다.fun mergeOtherZoo(zoo: Zoo&lt;out T&gt;) {    zoo.animals.addAll(this.animals)\t\t}  out 키워드를 이용해서 공변 상태로 전환할 때는 파라미터인  zoo  가 본인의 데이터를 넘겨주는 쪽으로 동작을 처리하면 됩니다.​반공변으로 전환out 을 이용해서 공변 상태로 만들었을 때는 zoo 가 this 의 하위 타입이 되는 것이 가능하므로 zoo 에 this 데이터를 가져가는 동작은 타입 안전성을 해칠 수 있습니다. 이러한 동작을 처리하려면 공변이 아닌 반공변으로 설정하는 것이 좋습니다.반공변은 말 그대로 공변의 반대입니다. 여기서는 서브타입이었던 클래스가 반대로 상위타입이 됩니다. 그래서 공변이었을 때 불가능했던 파라미터 zoo 에 this 의 데이터를 가져가는 동작이 반공변에선 가능합니다.fun mergeOtherZoo(zoo: Zoo&lt;in T&gt;) {    zoo.animals.addAll(this.animals)}  in 키워드를 이용해서 반공변 상태로 전환할 때는 파라미터인 zoo 가 this 의 데이터를 소비하는 쪽으로 동작을 처리하면 됩니다.​변성 선언 위치변성 선언은 파라미터에서 설정하는 것 이외에도 클래스 전체를 설정하는 것도 가능합니다. 만약에 클래스 전체를 공변하게 만들고 싶거나 반공변하게 만들고 싶다면 다음과 같이 클래스 헤더에 설정하면 됩니다. 이렇게 하면 예시로 사용했던 mergeOtherZoo 메서드 파라미터로 Zoo 클래스를 받을 필요가 없어집니다.class Zoo&lt;out T&gt; {}class Zoo&lt;in T&gt; {}// 클래스 자체를 공변 설정하지 않았을 때fun mergeOtherZoo(zoo: Zoo&lt;T&gt;) {    this.animals.addAll(zoo.animals)}// 파라미터로 클래스가 아닌 리스트로 수정fun mergeOtherZoo(zoo: List&lt;T&gt;) {    this.animals.addAll(zoo)}공변 설정만약 클래스를 out (공변) 설정했다면 다음 두 메서드에서 오류가 발생합니다.fun add(animal: T) {    animals.add(animal)}fun mergeOtherZoo(zoo: List&lt;T&gt;) {    this.animals.addAll(zoo)}// Type parameter T is declared as 'out' but occurs in 'in' position in type T다음과 같이 메서드 파라미터에 공변을 설정했을 때를 보면 zoo 가 데이터를 넘겨주는 역할을 해야 한다고 언급했습니다. 그래서 클래스 자체를 공변으로 설정했다면 내부 메서드도 전부 데이터를 넘기는(getter) 동작으로 설정해야 합니다. 그래서 getLast() getFirst() 는 별다른 오류가 없는 겁니다.fun mergeOtherZoo(zoo: Zoo&lt;out T&gt;) {    zoo.animals.addAll(this.animals)\t\t}반공변 설정이번엔 클래스를 in (반공변) 설정했다면 다음 두 메서드에서 오류가 발생합니다.fun getLast(): T {    return animals.last()}fun getFirst(): T {    return animals.first()}// Type parameter T is declared as 'in' but occurs in 'out' position in type T이번엔 공변으로 설정했을 때와 달리 getter 역할을 수행하는 메서드에서 오류가 발생했습니다. 메서드 파라미터에 in 반공변을 설정했을 때를 보면 zoo 가 데이터를 넘기는 것이 아닌 오히려 데이터를 받는 입장인 것을 알 수 있습니다. 그래서 이때는 클래스 내 메서드는 데이터를 받는 쪽으로 처리하면 됩니다.fun mergeOtherZoo(zoo: Zoo&lt;in T&gt;) {    zoo.animals.addAll(this.animals)}​강제 변성위의 예시를 보면 알 수 있듯이, 제네릭은 타입 안전성을 굉장히 신경을 씁니다. 그래서 in 혹은 out 으로 했을 때 안전성을 해칠 수 있는 타입 파라미터를 오류 메세지를 보여주는 것으로 막습니다. 그런데 이를 무시하고 강제로 설정을 해야 하는 경우가 있을 수 있습니다.그래서 코틀린은 @UnsafeVariance 라는 어노테이션을 제공합니다. 타입 파라미터에 붙여서 사용하면 변성 설정으로 인해 발생할 수 있는 위험성을 감수하고 강제로 실행시킬 수 있습니다.만약에 클래스 자체를 out 으로 설정했다면 add mergeOtherZoo 메서드의 타입 파라미터에서 오류가 발생합니다. 이때 이 어노테이션을 사용하면 강제로 실행할 수 있습니다. 물론 런타임에 발생된 오류에 대한 처리는 어노테이션을 설정한 개발자의 몫입니다.fun add(animal: @UnsafeVariance T) {    animals.add(animal)}fun mergeOtherZoo(zoo: List&lt;@UnsafeVariance T&gt;) {    this.animals.addAll(zoo)}​범위 지정타입으로 받을 수 있는 범위 제한지금까지 동물원을 예시로 설명을 드렸습니다. 그런데 다음과 같이 동물이랑 전혀 상관없는 Int 를 타입으로 넘겨도 객체 생성에 문제가 없습니다. 그래서 넘기는 타입 파라미터의 범위를 지정해줘야 합니다.&lt;T: Animal&gt; 이런 식으로 범위를 지정하면 됩니다. 설정하면 Animal  범위 내의 타입들만 넘길 수 있습니다.fun main() {    val zooWithNotAnimal = Zoo&lt;Int&gt;() // 오류 없음}class Zoo&lt;T&gt; {}fun main() {    val zooWithNotAnimal = Zoo&lt;Int&gt;() // Type argument is not within its bounds.}class Zoo&lt;T: Animal&gt; {}​제네릭 클래스뿐만 아니라 제네릭 함수도 있다.예시로 사용한 동물원은 제네릭 클래스입니다. 제네릭 클래스는 클래스 이름 오른쪽에 타입을 지정합니다. 반면에 클래스가 아닌 함수를 제네릭으로 정의할 때는 fun 키워드와 함수 이름 사이에 타입 파라미터를 넣어줘야 합니다.fun List&lt;T&gt;.isNone(): Boolean {    return this.isEmpty()}// 틀린 코드: Unresolved reference: Tfun &lt;T&gt; List&lt;T&gt;.isNone(): Boolean {    return this.isEmpty()}// 맞는 코드: fun 키워드 다음에 타입 파라미터를 적어줘야 함제네릭 함수를 잘만 활용하면 유틸성 함수들을 마구 찍어낼 수 있습니다. 코틀린 자체에서 제공하는 여러 유용한 확장함수들도 제네릭 함수로 정의되어 제공됩니다. 대표적으로 Collection 과 관련된 파일을 보면 유용한 기능의 함수가 제네릭으로 정의되어 있는 것을 알 수 있습니다.​마무리지금까지 예시를 통해서 제네릭을 이용한 클래스와 함수가 어떻게 정의되고 어떤 특징을 가지고 있는지 설명을 해봤습니다. 단순히 하나의 클래스나 함수를 제네릭으로 정의함으로써 코드 재사용성을 높일 수 있고 변성을 통한 타입 안전성도 얻을 수 있다는 것을 알았습니다.설명을 위해 사용된 코드는 단순히 제네릭의 특징을 직관적으로 보여주기 위해서 굉장히 단순하고 허술하게 작성을 했으니 이 점 이해해주시면 감사하겠습니다. 혹시라도 틀린 내용이 있어서 알려주신다면 바로 수정하겠습니다. 감사합니다 :)혹시 괜찮은 코틀린 강의를 찾고 계시다면 하나 추천드리겠습니다. 개인적으로 굉장히 만족하면서 들었던 강의입니다.인프런 - 코틀린 고급편​참조Wikipedia 변성인프런 - 코틀린 고급편"
  },
  
  {
    "title": "Android BuildConfig 적용 안되는 현상",
    "url": "/posts/Android-BuildConfig/",
    "categories": "Android, 이슈",
    "tags": "Android, BuildConfig",
    "date": "2023-11-01 12:00:00 +0900",
    





    
    "snippet": "빌드를 다시 해봐도 BuildConfig 가 없음BuildConfig 는 보통 노출되면 안되는 값을 저장할 때 사용되곤 합니다. 그래서 프로젝트를 몇번 해봤다면 해당 기능을 사용해봤을 겁니다. 보통 서버 주소나 API 키와 같은 중요한 값들을 로컬 프로퍼티에 저장을 하고 재빌드를 해서 BuildConfig 를 참조하게 됩니다. 그런데 재빌드를 했음에도...",
    "content": "빌드를 다시 해봐도 BuildConfig 가 없음BuildConfig 는 보통 노출되면 안되는 값을 저장할 때 사용되곤 합니다. 그래서 프로젝트를 몇번 해봤다면 해당 기능을 사용해봤을 겁니다. 보통 서버 주소나 API 키와 같은 중요한 값들을 로컬 프로퍼티에 저장을 하고 재빌드를 해서 BuildConfig 를 참조하게 됩니다. 그런데 재빌드를 했음에도 불구하고 BuildConfig 가 참조되지 않는 경우가 있었을 겁니다.AGP 8.0 부터 BuildConfig 는 기본으로 적용되지 않음빌드 퍼포먼스 향상을 위해서 그래들 플러그인 8.0 버전부터는 BuildConfig 생성이 되지 않도록 변경됐습니다.Android 공식문서 내용 발췌  Starting with AGP 8.0, the default values for these flags have changed to improve build performance. To get help adjusting your code to support some of these changes, use the AGP Upgrade Assistant (Tools &gt; AGP Upgrade Assistant). The Upgrade Assistant guides you through updating your code to accommodate the new behavior or setting flags to preserve the previous behavior.            Flag      New default value      Previous default value      Notes                  android.defaults.buildfeatures.buildconfig      false      true      AGP 8.0 doesn’t generate BuildConfig by default. You need to specify this option using the DSL in the projects where you need it.      Medium : Android Developers 내용 발췌  If you call the BuildConfig class from your module code, you need to enable buildConfig in the android {} block in your module’s build.gradle.kts file. Otherwise, the BuildConfig file isn’t automatically generated anymore.​BuildConfig 사용을 명시해야 사용 가능따라서 그래들 플러그인 버전이 8.0 이상이라면 해당 기능을 사용하기 위해서 그래들 파일에 직접 명시를 해줘야 합니다. ViewBinding DataBinding 을 사용하기 위해서 그래들 파일에 명시해주는 거랑 똑같다고 보시면 됩니다.// Module build.gradle.ktsandroid {  buildFeatures {    buildConfig = true  }}​참조Android 공식문서Medium : Android Developers"
  },
  
  {
    "title": "Android 구글 로그인 구현하기",
    "url": "/posts/Android-Google-Login/",
    "categories": "Android, 라이브러리",
    "tags": "Android, 소셜 로그인, 구글, Google Login",
    "date": "2023-10-31 22:00:00 +0900",
    





    
    "snippet": "사전 준비안드로이드에서 구글 로그인을 구현하기 위해서는 준비해야 될 게 몇 가지가 있습니다. 구글 클라우드에 들어가서 OAuth 클라이언트 아이디를 만들고 그 과정에서 본인의 앱을 등록해야 합니다. 그러므로 구체적으로 무엇을 먼저 준비해야 하는지 알아보겠습니다.  파이어베이스에 앱을 등록해서 관리하는 것까지 할 예정이니 파이어베이스 과정이 필요없다면 ...",
    "content": "사전 준비안드로이드에서 구글 로그인을 구현하기 위해서는 준비해야 될 게 몇 가지가 있습니다. 구글 클라우드에 들어가서 OAuth 클라이언트 아이디를 만들고 그 과정에서 본인의 앱을 등록해야 합니다. 그러므로 구체적으로 무엇을 먼저 준비해야 하는지 알아보겠습니다.  파이어베이스에 앱을 등록해서 관리하는 것까지 할 예정이니 파이어베이스 과정이 필요없다면 해당 부분은 스킵하세요!​1. 구글 클라우드에서 클라이언트 아이디 생성      구글 클라우드에 들어가서 오른쪽 상단의 콘솔 을 클릭합니다.        API 및 서비스로 들어갑니다. (만약 프로젝트가 없다면 새 프로젝트부터 만들고 시작)        왼쪽에 메뉴가 다섯 가지가 존재하는데 거기서 사용자 인증 정보를 클릭합니다.        + 사용자 인증 정보 만들기 를 눌러서 OAuth 클라이언트 ID 를 클릭해서 아이디를 생성합니다. 여기서 애플리케이션 유형을 선택할 수 있는데 웹 애플리케이션, Android 이 두 개를 각각 만들어야 합니다.      ​2. SHA-1 값 찾기웹 애플리케이션 유형은 그냥 생성하면 되므로 Android 유형 만드는 방법을 중점으로 알아보겠습니다. 여기서는 중요한 게 패키지 이름과 SHA-1 인증서 디지털 지문 입니다. 패키지 이름은 본인 프로젝트의 패키지 이름을 그대로 적으면 됩니다.인증서 디지털 지문은 그래들 태스크를 이용해서 찾을 수 있습니다. 그래들 태스크는 다음과 같이 두 가지 방법으로 실행할 수 있습니다. 태스크를 실행시켰다면 gradle signingreport 를 입력해서 실행시키면 됩니다. 그러면 터미널 창에서 SHA1 을 확인할 수 있습니다.      안드로이드 스튜디오 오른쪽 메뉴를 클릭한 다음, 터미널 아이콘을 클릭해서 그래들 태스크를 실행합니다.    안드로이드 스튜디오 오른쪽 상단의 검색 아이콘을 눌러 Gradle Task 를 검색해서 그래들 태스크를 실행합니다.  \t​파이어베이스에 앱 등록하기파이어베이스에 가서 프로젝트를 새로 만드시고 프로젝트에 들어가서 앱 추가를 해주세요. 당연히 안드로이드로 해주시면 됩니다. 그러면 구글 클라이언트 아이디 생성할 때와 똑같이 패키지 이름과 SHA-1 값을 요구할 겁니다. 동일하게 작성하고 완료하면 됩니다. 다 만들면 google-services.json 파일을 다운받을 수 있을텐데 이거를 프로젝트 폴더 내 app 에 붙여넣기 해주세요.​의존성 추가그래들 앱 수준 -  Module:app 에서 추가해야 하는 의존성 및 플러그인입니다.plugins {    id(\"com.google.gms.google-services\") // &lt;- 추가}dependencies {    implementation(platform(\"com.google.firebase:firebase-bom:32.3.1\"))    implementation(\"com.google.firebase:firebase-auth-ktx\")    implementation(\"com.google.android.gms:play-services-auth:20.7.0\")}그래들 프로젝트 수준 - Project:{본인 프로젝트명} 에서 추가해야 하는 플러그인입니다.plugins {    id(\"com.google.gms.google-services\") version \"4.4.0\" apply false // &lt;- 추가}​구글 아이디 토큰 발급하기이제 코드를 작성할 단계입니다. 파이어베이스에 로그인 유저 관리를 하기 위해서는 먼저 구글 아이디 토큰이란 것을 받아와야 합니다. 아이디 토큰을 이용해서 파이어베이스에 연결하기 때문에 이 작업을 먼저 처리해야 합니다.      GoogleSignInOptions 을 생성합니다. 저는 아이디 토큰 요청, 이메일 요청만 추가했지만 다른 옵션이 더 필요하다면 추가하면 됩니다. 여기서 requestIdToken 에 넘기는 인자가 웹 클라이언트 유형으로 만들었던 클라이언트 아이디 값입니다.    private val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)    .requestIdToken(BuildConfig.GOOGLE_CLIENT_ID)    .requestEmail()    .build()            GoogleSignInClient 을 생성합니다.    val googleSignInClient = GoogleSignIn.getClient(this, gso)            사용자가 구글 로그인을 요청했을 때 결과를 처리하는 코드를 작성    val googleLogInRequest =    registerForActivityResult(ActivityResultContracts.StartActivityForResult()) {        if (it.resultCode == RESULT_OK) {            val task = GoogleSignIn.getSignedInAccountFromIntent(it.data)            try {                val account = task.getResult(ApiException::class.java)                account?.let { user -&gt;                    user.idToken?.let { idToken -&gt;                        Timber.d(\"Get Account idToken! : ${account.idToken}\")                    }                }            } catch (e: ApiException) {                Timber.d(e)            }        }    }            사용자가 구글 로그인 버튼을 클릭했을 때 이벤트를 처리하는 코드 작성    _binding.btnRequestGoogleLogin.setOnClickListener {    googleLogInRequest.launch(googleSignInClient.signInIntent)}      ​파이어베이스에 연결하기아이디 토큰을 받았다면 이제 해당 토큰을 가지고 파이어베이스에 연결을 해야 합니다. 그러기 위해서 먼저 파이어베이스 auth 를 생성합니다.class MainActivity : AppCompatActivity() {    private lateinit var auth: FirebaseAuth    override fun onCreate(savedInstanceState: Bundle?) {\t\t\t\t// ...        auth = Firebase.auth    }}그리고 아이디 토큰을 가지고 파이어베이스에 연결을 시도합니다.private fun handleGoogleIdToken(idToken: String) {    val firebaseCredential = GoogleAuthProvider.getCredential(idToken, null)    auth.signInWithCredential(firebaseCredential)        .addOnCompleteListener(this) {            if(it.isSuccessful) {                // 정상 완료            }        }}​정리지금까지 구글 로그인 연결을 위해 필요한 과정들을 알아봤습니다. 최종적으로 구한 아이디 토큰이나 파이어베이스 auth 가 가지고 있는 값들을 프로젝트에 연결된 서버에 전송하여 유저 등록을 하게 됩니다. 지금까지의 코드를 간단하게 정리한 예시를 끝으로 마치겠습니다. 감사합니다.class MainActivity : AppCompatActivity() {    private val viewModel: GoogleLoginViewModel by viewModel()    private lateinit var _binding: ActivityMainBinding    private lateinit var auth: FirebaseAuth    private val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)        .requestIdToken(BuildConfig.GOOGLE_CLIENT_ID)        .requestEmail()        .build()    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        _binding = DataBindingUtil.setContentView(this, R.layout.activity_main)        setContentView(_binding.root)        _binding.vm = viewModel        auth = Firebase.auth        val googleSignInClient = GoogleSignIn.getClient(this, gso)        val googleLogInRequest =            registerForActivityResult(ActivityResultContracts.StartActivityForResult()) {                if (it.resultCode == RESULT_OK) {                    val task = GoogleSignIn.getSignedInAccountFromIntent(it.data)                    try {                        val account = task.getResult(ApiException::class.java)                        account?.let { user -&gt;                            user.idToken?.let { idToken -&gt;                                Timber.d(\"Get Account idToken! : ${account.idToken}\")                                handleLoginResponse()                                viewModel.googleLoginByToken(idToken)                            }                        }                    } catch (e: ApiException) {                        Timber.d(e)                    }                }            }        _binding.btnRequestGoogleLogin.setOnClickListener {            googleLogInRequest.launch(googleSignInClient.signInIntent)        }        _binding.btnRequestGoogleSignOut.setOnClickListener {            googleSignInClient.signOut().addOnCompleteListener {                if(it.isComplete) {                    viewModel.googleSignOut()                    toast(\"Complete sign out!\")                }                else { toast(\"Failure sign out!\") }            }        }    }    private fun handleLoginResponse() {        viewModel.account.observe(this) { _binding.accountInfo = it }    }    private fun handleGoogleIdToken(idToken: String) {        val firebaseCredential = GoogleAuthProvider.getCredential(idToken, null)        auth.signInWithCredential(firebaseCredential)            .addOnCompleteListener(this) {                if(it.isSuccessful) {                    // 정상 완료                }            }    }}​참조Android용 로그인Android에서 Google로 인증"
  },
  
  {
    "title": "(프로그래머스 | Kotlin) - 카드 짝 맞추기",
    "url": "/posts/KotlinAlgorithm5/",
    "categories": "CS, 알고리즘 문제",
    "tags": "Kotlin, Algorithm, 알고리즘, 프로그래머스",
    "date": "2023-10-28 22:00:00 +0900",
    





    
    "snippet": "해결 방법이 문제의 핵심은 그냥 구현, 또 구현, 그리고 또 구현이다. 막 엄청 수준이 높은 알고리즘을 요구하는 것이 아닌 기본적인 알고리즘 여러 개를 가지고 복잡한 구현을 요구한다. 그래서 이 문제를 풀면서 굉장한 피로감을 느꼈다… 나같은 경우에는 백트래킹, 너비 우선 탐색, 그리디 이 세 가지를 중심으로 구현을 진행했다. 해당 알고리즘을 사용한 이...",
    "content": "해결 방법이 문제의 핵심은 그냥 구현, 또 구현, 그리고 또 구현이다. 막 엄청 수준이 높은 알고리즘을 요구하는 것이 아닌 기본적인 알고리즘 여러 개를 가지고 복잡한 구현을 요구한다. 그래서 이 문제를 풀면서 굉장한 피로감을 느꼈다… 나같은 경우에는 백트래킹, 너비 우선 탐색, 그리디 이 세 가지를 중심으로 구현을 진행했다. 해당 알고리즘을 사용한 이유는 다음과 같다.1. 최소 탐색을 위해서는 가능한 뒤집는 순서 조합을 모두 구해서 계산해야 한다.만약 보드판 위에 1 2 3 이렇게 세 종류의 카드가 존재한다면 가능한 뒤집는 순서의 갯수는 6가지다. 이 6가지 순서쌍에서 최소 탐색을 할 수 있는 순서쌍이 존재하기 때문에 모든 순서쌍을 계산해서 최소값을 찾는 방식으로 진행한다.  1 -&gt; 2 -&gt; 3  1 -&gt; 3 -&gt; 2  2 -&gt; 1 -&gt; 3  2 -&gt; 3 -&gt; 1  3 -&gt; 1 -&gt; 2  3 -&gt; 2 -&gt; 1  private fun setPermutation(p: ArrayList&lt;Int&gt;, isVisited: Array&lt;Boolean&gt;) {      if(p.size == image.size) {          permutation.add(p.toIntArray())          return      }      image.forEach { imageCode -&gt;          if(!isVisited[imageCode]) {              isVisited[imageCode] = true              p.add(imageCode)              setPermutation(p, isVisited)              p.removeLast()              isVisited[imageCode] = false          }      }  }2. 같은 종류의 카드가 2개씩 있는데 이 2개의 뒤집는 순서도 고려해야 한다.카드가 1 2 3 이렇게 있으면 한 개씩 세 장을 의미하는 게 아니라 실제로는 각 종류별로 2개씩 총 6장의 카드가 보드판에 존재한다. 따라서 각 종류별로 2장을 어떤 순서로 뒤집을 건지도 고려해야 한다. 이 부분은 예를 들어서 특정  n번 카드 두 장을 각각 a b 라고 가정하자. 그럼 a -&gt; b b -&gt; a 이렇게 두 가지 경우에서 더 작은 이동값을 가지는 경우를 택한다.  private fun getMinimumMove(cursor: Pair&lt;Int,Int&gt;, target: Int, board:  Array&lt;IntArray&gt;): Point {      val a = position[target][0]      val b =  position[target][1]      val moveFromAtoB = bfs(cursor, a, board) + bfs(a, b, board) + 2      val moveFromBtoA = bfs(cursor, b, board) + bfs(b, a, board) + 2      return when(min(moveFromAtoB, moveFromBtoA)) {          moveFromAtoB -&gt; Point(b.first, b.second, moveFromAtoB)          else -&gt; Point(a.first, a.second, moveFromBtoA)      }  }3. 보드판 위에서 특정 위치의 카드를 찾는 방법은 BFS를 이용한다.카드를 뒤집기 위해서는 현재 위치에 있는 커서가 카드가 있는 곳으로 최소의 움직임으로 이동해야 한다. 따라서 이를 위해 BFS를 이용하여 구현했다. 대충 함수 헤더가 어떤지 설명하자면 fun bfs(curr: Pair&lt;Int,Int&gt;, target: Pair&lt;Int,Int&gt;) 이런 느낌이다.private fun bfs(cursor: Pair&lt;Int,Int&gt;, target: Pair&lt;Int,Int&gt;, board:  Array&lt;IntArray&gt;): Int {    val q = ArrayDeque&lt;Point&gt;()    val col = listOf(0,1,0,-1)    val row = listOf(1,0,-1,0)    val isVisited = Array(4) { Array(4) {false} }    q.add(Point(cursor.first, cursor.second, 0))    isVisited[cursor.first][cursor.second] = true    while(!q.isEmpty()) {        val curr = q.first()        q.removeFirst()        if(curr.x == target.first &amp;&amp; curr.y == target.second) {            return curr.cnt        }        for(i in 0..3) {            val nextCol = curr.x+ col[i]            val nextRow = curr.y + row[i]            if(-1 &lt; nextCol &amp;&amp; nextCol &lt; 4 &amp;&amp; -1 &lt; nextRow &amp;&amp; nextRow &lt; 4 &amp;&amp; !isVisited[nextCol][nextRow]) {                q.add(Point(nextCol, nextRow, curr.cnt+1))                isVisited[nextCol][nextRow] = true            }        }        for(i in 0..3) {            var nextCol = curr.x            var nextRow = curr.y            while(true) {                nextCol += col[i]                nextRow += row[i]                if(3 &lt; nextCol || nextCol &lt; 0 || 3 &lt; nextRow || nextRow &lt; 0) {                    nextCol -= col[i]                    nextRow -= row[i]                    break                }                if(board[nextCol][nextRow] &gt; 0) { break }            }            if(isVisited[nextCol][nextRow]) { continue }            q.add(Point(nextCol, nextRow, curr.cnt+1))            isVisited[nextCol][nextRow] = true        }    }    return 0}설명순서 1.백트래킹을 이용해서 순열을 구한다. 중복 순열이 필요한 것은 아니므로 방문한 번호에 대해서는 재방문을 허용하지 않도록 isVisited 와 같은 논리형 변수를 만들어서 처리한다. 순열이 한쌍 완성될 때마다 만들어둔 permutation 배열에 저장한다.순서 2.n 번 카드 2장(a b )이 있고 a -&gt; b b -&gt; a  를 각각 구해야 한다. 이를 bfs 로 구하려면 a -&gt; b 를 현재 커서 -&gt; a  a -&gt; b 이렇게 나눠서 계산해야 하고 b -&gt; a 도 마찬가지다. 그리고 두 장의 카드에 도달했을 때 뒤집는 행동도 카운트해야 하니까 a 뒤집을 때 한 번, b 뒤집을 때 한 번 해서 총 2를 더하는 것도 잊지 말아야 한다. 이렇게 계산을 끝내고 값이 더 적은 결과값을 반환하면 된다.순서 3.보통 bfs 문제들은 동, 서, 남, 북 이렇게 네 방향으로 한 칸씩 움직이면서 목표 지점을 향한다. 그런데 이 문제는 컨트롤을 누른채로 움직이는 것도 있어서 이것도 추가로 고려를 해줘야 한다. 따라서 해당 부분에 대한 로직도 같이 작성한다.for(i in 0..3) {    var nextCol = curr.x    var nextRow = curr.y    while(true) {        nextCol += col[i]        nextRow += row[i]        if(3 &lt; nextCol || nextCol &lt; 0 || 3 &lt; nextRow || nextRow &lt; 0) {            nextCol -= col[i]            nextRow -= row[i]            break        }        if(board[nextCol][nextRow] &gt; 0) { break }    }    if(isVisited[nextCol][nextRow]) { continue }    q.add(Point(nextCol, nextRow, curr.cnt+1))    isVisited[nextCol][nextRow] = true}전체 코드class Solution {    private val position = Array(7) { arrayListOf&lt;Pair&lt;Int,Int&gt;&gt;() }    private val permutation = ArrayList&lt;IntArray&gt;()    private val image = arrayListOf&lt;Int&gt;()    fun solution(board: Array&lt;IntArray&gt;, r: Int, c: Int): Int {        board.forEachIndexed { i, l -&gt;            l.forEachIndexed { j, value -&gt;                if (value != 0 &amp;&amp; position[value].size == 0) { image.add(value) }                position[value].add(Pair(i, j))            }        }        var answer: Int = 4*4*2*image.size        setPermutation(arrayListOf(), Array(7){false})        permutation.forEach { l -&gt;            var cursor = Pair(r,c)            var sum = 0            val tmpBoard = Array(4) { IntArray(4) }            for(i in 0..3) { for(j in 0..3) { tmpBoard[i][j] = board[i][j] } }            l.forEachIndexed { i, imageCode -&gt;                val result =  getMinimumMove(cursor, l[i], tmpBoard)                sum += result.cnt                cursor = Pair(result.x, result.y)                tmpBoard[position[imageCode][0].first][position[imageCode][0].second] = 0                tmpBoard[position[imageCode][1].first][position[imageCode][1].second] = 0            }            answer = min(answer, sum)        }        return answer    }    private fun getMinimumMove(cursor: Pair&lt;Int,Int&gt;, target: Int, board:  Array&lt;IntArray&gt;): Point {        val a = position[target][0]        val b =  position[target][1]        val moveFromAtoB = bfs(cursor, a, board) + bfs(a, b, board) + 2        val moveFromBtoA = bfs(cursor, b, board) + bfs(b, a, board) + 2        return when(min(moveFromAtoB, moveFromBtoA)) {            moveFromAtoB -&gt; Point(b.first, b.second, moveFromAtoB)            else -&gt; Point(a.first, a.second, moveFromBtoA)        }    }    private fun bfs(cursor: Pair&lt;Int,Int&gt;, target: Pair&lt;Int,Int&gt;, board:  Array&lt;IntArray&gt;): Int {        val q = ArrayDeque&lt;Point&gt;()        val col = listOf(0,1,0,-1)        val row = listOf(1,0,-1,0)        val isVisited = Array(4) { Array(4) {false} }        q.add(Point(cursor.first, cursor.second, 0))        isVisited[cursor.first][cursor.second] = true        while(!q.isEmpty()) {            val curr = q.first()            q.removeFirst()            if(curr.x == target.first &amp;&amp; curr.y == target.second) {                return curr.cnt            }            for(i in 0..3) {                val nextCol = curr.x+ col[i]                val nextRow = curr.y + row[i]                if(-1 &lt; nextCol &amp;&amp; nextCol &lt; 4 &amp;&amp; -1 &lt; nextRow &amp;&amp; nextRow &lt; 4 &amp;&amp; !isVisited[nextCol][nextRow]) {                    q.add(Point(nextCol, nextRow, curr.cnt+1))                    isVisited[nextCol][nextRow] = true                }            }            for(i in 0..3) {                var nextCol = curr.x                var nextRow = curr.y                while(true) {                    nextCol += col[i]                    nextRow += row[i]                    if(3 &lt; nextCol || nextCol &lt; 0 || 3 &lt; nextRow || nextRow &lt; 0) {                        nextCol -= col[i]                        nextRow -= row[i]                        break                    }                    if(board[nextCol][nextRow] &gt; 0) { break }                }                if(isVisited[nextCol][nextRow]) { continue }                q.add(Point(nextCol, nextRow, curr.cnt+1))                isVisited[nextCol][nextRow] = true            }        }        return 0    }    private fun setPermutation(p: ArrayList&lt;Int&gt;, isVisited: Array&lt;Boolean&gt;) {        if(p.size == image.size) {            permutation.add(p.toIntArray())            return        }        image.forEach { imageCode -&gt;            if(!isVisited[imageCode]) {                isVisited[imageCode] = true                p.add(imageCode)                setPermutation(p, isVisited)                p.removeLast()                isVisited[imageCode] = false            }        }    }    data class Point(        val x: Int,        val y: Int,        val cnt: Int    )}"
  },
  
  {
    "title": "(프로그래머스 | C++) - 숫자 블록",
    "url": "/posts/KotlinAlgorithm4/",
    "categories": "CS, 알고리즘 문제",
    "tags": "Kotlin, Algorithm, 알고리즘, 프로그래머스",
    "date": "2023-10-16 20:00:00 +0900",
    





    
    "snippet": "해결 방법이 문제의 핵심은 가장 큰 약수를 구하는 데 있다.  문제에서 블록의 번호가 n 이고 해당 블록은 n*2 n*3 … 이렇게 설치를 한다. 이것은 곧 약수가 됨을 의미한다. 예를 들어서 구간 10 에 설치될 블록의 번호 무엇일까? 바로  5 다. 왜 이렇게 나오는 것일까? 구간이 가지고 있는 약수들 중에서 본인을 제외한 가장 큰 숫자가 설치될 ...",
    "content": "해결 방법이 문제의 핵심은 가장 큰 약수를 구하는 데 있다.  문제에서 블록의 번호가 n 이고 해당 블록은 n*2 n*3 … 이렇게 설치를 한다. 이것은 곧 약수가 됨을 의미한다. 예를 들어서 구간 10 에 설치될 블록의 번호 무엇일까? 바로  5 다. 왜 이렇게 나오는 것일까? 구간이 가지고 있는 약수들 중에서 본인을 제외한 가장 큰 숫자가 설치될 블록 번호이기 때문이다.10 의 약수는 1, 2, 5, 10 인데 약수 1 부터 살펴보면 1*10 = 10 인 것을 알 수 있고 n=1 로 표현이 가능하다. 그래서 처음에는 구간 10 에 1 블록이 설치된다.  그 다음 블록 번호는 2 다. 마찬가지로 2*5=10 인 것을 알 수 있고 n=2 로 표현이 가능하다. 따라서 이미 설치된 1 블록에 2 블록을 덮어씌운다. 그 다음 블록 번호 3 4 는 특정 숫자를 곱해서 10 을 만들 수 없으므로 패스한다. 이런 방식으로 진행을 하면 5 가 5*2=10 이므로 구간 10 에 마지막으로 설치되는 블록 번호는 5 임을 알 수 있다. 결국 구간이 가진 본인 제외, 가장 큰 약수가 해당 구간에 설치될 블록의 번호다.      특정 숫자에 대해서 가장 큰 약수를 반환하는 메서드를 정의한다.    int GetMostDivisor(int num) {    if(num == 1) return 0;    vector&lt;int&gt; divisor(1, 1);           for(int i=2; i&lt;=sqrt(num); i++) {        if(num%i == 0) {            if(num/i &lt;= MAX_BLOCK_NUM) return num/i;            divisor.push_back(i);        }       }    return divisor.back();}            begin ~ end 범위의 반복문을 통해 본인 제외 가장 큰 약수를 저장한다.    for(int i=begin; i&lt;end+1; i++) {    answer[i-begin] = GetMostDivisor(i);}      설명순서 1.가장 큰 약수를 구하려면 가장 작은 수부터 나눠서 확인하면 된다. 이때 문제 조건인 블록 최대값 10,000,000 이 넘어가지 않는다면 해당 결과값이 된다. 아니라면 따로 약수 후보들을 배열에 저장해놓고 반복문이 끝나면 해당 배열에서 최대값을 리턴하면 된다.순서 2.각 구간의 시작과 끝을 반복문으로 돌면서 answer 에 저장하면 간단하게 끝난다.전체 코드#include &lt;string&gt;#include &lt;vector&gt;#include &lt;math.h&gt;#include &lt;iostream&gt;using namespace std;const int MAX_BLOCK_NUM = 10000000;int GetMostDivisor(int num) {    if(num == 1) return 0;    vector&lt;int&gt; divisor(1, 1);        for(int i=2; i&lt;=sqrt(num); i++) {        if(num%i == 0) {            if(num/i &lt;= MAX_BLOCK_NUM) return num/i;            divisor.push_back(i);        }       }    return divisor.back();}vector&lt;int&gt; solution(long long begin, long long end) {    vector&lt;int&gt; answer(end-begin+1, 0);        for(int i=begin; i&lt;end+1; i++) {        answer[i-begin] = GetMostDivisor(i);    }    return answer;}"
  },
  
  {
    "title": "(프로그래머스 | Kotlin) - 이모티콘 할인행사",
    "url": "/posts/KotlinAlgorithm3/",
    "categories": "CS, 알고리즘 문제",
    "tags": "Kotlin, Algorithm, 알고리즘, 프로그래머스",
    "date": "2023-10-11 20:00:00 +0900",
    





    
    "snippet": "해결방법이 문제의 핵심은 emoticons 배열에 담겨 있는 이모티콘들의 할인율을 배정하는 것이다. 각 이모티콘은 각각 10, 20, 30, 40 퍼센트로 네 가지 할인율을 가질 수 있다. 따라서 각 이모티콘은 네 가지 중에서 하나의 할인율을 가진다. emoticons 의 최대 길이가 7 이므로 나올 수 있는 이모티콘들의 할인율의 경우의 수는 최대 4...",
    "content": "해결방법이 문제의 핵심은 emoticons 배열에 담겨 있는 이모티콘들의 할인율을 배정하는 것이다. 각 이모티콘은 각각 10, 20, 30, 40 퍼센트로 네 가지 할인율을 가질 수 있다. 따라서 각 이모티콘은 네 가지 중에서 하나의 할인율을 가진다. emoticons 의 최대 길이가 7 이므로 나올 수 있는 이모티콘들의 할인율의 경우의 수는 최대 4^7 개다.나올 수 있는 최대 경우의 수가 4의 7승이라면 모든 경우를 탐색해도 지장이 없는 크기다. 따라서 완전 탐색을 통해 문제에서 요구하는 최대 효율을 가진 경우의 수(최대 효율을 내는 할인율 조합)를 찾을 수 있다. 완전 탐색을 위해서 모든 경우의 수를 구해야 하므로 백트래킹을 이용하여 나올 수 있는 모든 할인율 조합을 배열에 저장한다.모든 할인율 조합을 구했다면 하나씩 꺼내서 users 를 통해 결과값을 도출해본다. 결과값은 문제 조건대로 이모티콘 구독자 수가 많은 게 우선이고 그 다음은 이모티콘 판매액이다. 따라서 현재 계산 시점에서 나온 결과값과 이전에 계산했던 결과값 중에서 최대 효율을 내는 값과 비교하여 둘 중에 더 좋은 효율을 가진 결과값으로 업데이트하는 방식으로 해결한다. 해결 순서는 다음과 같다.      주어진 이모티콘 배열의 사이즈에 맞는 구할 수 있는 모든 할인율 조합을 구한다.    max 는 주어진 이모티콘 배열의 사이즈를 의미한다.    private fun setRatePermutation(count: Int){    if(count == max){        ratePermutation.add(tempPermutation.copyOf().toIntArray())        return    }    for(i in rate.indices){        tempPermutation[count] = rate[i]        setRatePermutation(count + 1)    }}        main 함수에서 먼저 할인율 조합을 저장한다.    this.max = emoticons.sizesetRatePermutation(0)            할인율 조합을 반복문으로 돌려 각 할인율 조합에 대한 users 배열을 계산해서 result 를 갱신한다.    for(p in ratePermutation) {    var selling = 0    var subscriberCounter = 0    for(user in users) {        var boughtSum = 0        for((i,price) in emoticons.withIndex()) {            if(p[i] &gt;= user[0]) {                boughtSum += ((100-p[i])*0.01*price).toInt()            }        }        if(boughtSum &gt;= user[1]) { subscriberCounter++ }        else{ selling += boughtSum }    }    if(answer[0] &lt; subscriberCounter || (answer[0]==subscriberCounter) &amp;&amp; answer[1] &lt; selling) {        answer[0] = subscriberCounter        answer[1] = selling    }}      설명순서 1.백트래킹을 이용한다. 여기서 할인율은 각 이모티콘마다 서로 다른 값으로 배정돼야 하는 것이 아니므로 중복값을 허용하도록 설계해야 한다. 이모티콘이 4개 있으면 할인율이  10, 20, 30, 40 일수도 있고, 10, 10, 10, 10 일수도 있다. 이렇게 구한 경우의 수가 최대(emoticons 사이즈가 7일 때) 약 16000 ~ 17000개다. 굉장히 값이 작아서 충분히 완전 탐색할 수 있는 크기다.순서 2.users 배열에 대한 계산은 그냥 문제에서 하라는 것만 하면 문제없이 결과값을 구할 수 있다. 결과값이 나왔다면 현재 최대값(1. 최대한 많은 이모티콘 구독자 수 2. 높은 판매액)과 비교해서 최대값을 갱신하면 된다. 최대값을 새로 갱신해야 하는 경우는 다음과 같다.      결과값([이모티콘 구독자 수, 이모티콘 판매액])의 이모티콘 구독자 수가 현재 최대값의 이모티콘 구독자 수보다 많을 경우    이모티콘 구독자 수가 결과값과 현재 최대값이 서로 같은데 판매액의 결과값이 더 많은 경우  전체 코드class Solution {    private var max = 7    private val tempPermutation = Array(max) {0}    private val ratePermutation = ArrayList&lt;IntArray&gt;()    private val rate = listOf(10, 20, 30, 40)    fun solution(users: Array&lt;IntArray&gt;, emoticons: IntArray): IntArray {        val answer = Array(2) {0}        this.max = emoticons.size        setRatePermutation(0)        for(p in ratePermutation) {            var selling = 0            var subscriberCounter = 0            for(user in users) {                var boughtSum = 0                for((i,price) in emoticons.withIndex()) {                    if(p[i] &gt;= user[0]) {                        boughtSum += ((100-p[i])*0.01*price).toInt()                    }                }                if(boughtSum &gt;= user[1]) { subscriberCounter++ }                else{ selling += boughtSum }            }            if(answer[0] &lt; subscriberCounter || (answer[0]==subscriberCounter) &amp;&amp; answer[1] &lt; selling) {                answer[0] = subscriberCounter                answer[1] = selling            }        }        return answer.toIntArray()    }        private fun setRatePermutation(count: Int){        if(count == max){            ratePermutation.add(tempPermutation.copyOf().toIntArray())            return        }        for(i in rate.indices){            tempPermutation[count] = rate[i]            setRatePermutation(count + 1)        }    }}"
  },
  
  {
    "title": "(프로그래머스 | Kotlin) - 억억단을 외우자",
    "url": "/posts/KotlinAlgorithm2/",
    "categories": "CS, 알고리즘 문제",
    "tags": "Kotlin, Algorithm, 알고리즘, 프로그래머스",
    "date": "2023-10-10 16:00:00 +0900",
    





    
    "snippet": "해결 방법이 문제의 핵심은 약수의 개수를 구하는 데 있다.  특정 숫자의 약수 개수를 알아야 등장 빈도를 알 수 있기 때문이다. 예를 들어서 숫자 4 를 예시로 들어보겠다. 억억단 예시 사진을 보면 해당 숫자가 세 번 등장하는데 그 이유가 구구단, 1단부터 e 단까지를 행렬로 표현해서 1X4 4X1 2X2 이렇게 나오기 때문이다.그럼 여기서 대충 약수...",
    "content": "해결 방법이 문제의 핵심은 약수의 개수를 구하는 데 있다.  특정 숫자의 약수 개수를 알아야 등장 빈도를 알 수 있기 때문이다. 예를 들어서 숫자 4 를 예시로 들어보겠다. 억억단 예시 사진을 보면 해당 숫자가 세 번 등장하는데 그 이유가 구구단, 1단부터 e 단까지를 행렬로 표현해서 1X4 4X1 2X2 이렇게 나오기 때문이다.그럼 여기서 대충 약수와 관련이 있다는 것을 눈치챌 수 있다. 4 의 약수는 총 세 개, 1, 2, 4 이다. 가운데를 기준으로 특정 위치에 있는 숫자는 자신의 반대쪽에 있는 숫자와 곱을 하면 4 가 된다. 그래서 원래는 4 가 두 개가 나오는 것이 맞지만 억억단은 행과 열 둘 다 구구단이 존재하기 때문에 동일 숫자 곱(2X2)을 제외하고 각각 2배를 해줘야 한다. 따라서  1, 4 는 1X4 4X1 이렇게 두 가지가 된다.이런 특징을 이용해서 숫자  e 까지의 등장 빈도를 배열에 저장하고 이 배열을 이용해 result 를 구하면 되는데 문제는 등장 빈도를 구하는 속도가 빨라야 한다. 나같은 경우에는 처음에  제곱근을 이용한 약수 개수를 구하는 알고리즘을 이용해서 시도했었는데 시간 초과가 됐었다. 그래서 배수를 이용한 약수 개수 구하는 알고리즘으로 변경하여 제출했더니 통과가 됐다. 따라서 이 문제는 약수 개수를 구하는 알고리즘만 잘 짜면 그 뒤는 무난하게 풀 수 있다. 해결 순서는 다음과 같다.      e 까지 각 숫자의 등장 빈도를 배열에 저장한다.    for (i in 1..e) {    for (j in 1..e / i) {        counter[i*j]++    }}            starts 배열 내 원소들을 하나씩 방문하여 result 를 구한다.    getResult 는 i ~ j 사이에서 빈도가 가장 높은 수와 빈도 값을 배열에 담아 리턴하는 메서드이다.    private fun getResult(i: Int, j: Int, counter: Array&lt;Int&gt;): IntArray {    var maxCnt = 0    var numOfMaxCnt = 0    for(num in i .. j) {        if(counter[num] &gt; maxCnt) {            maxCnt = counter[num]            numOfMaxCnt = num        }    }    return intArrayOf(numOfMaxCnt, maxCnt)}        var prev = getResult(sortedStarts.last()[0], e, counter)answer[sortedStarts.last()[1]] = prev[0]   for(i in sortedStarts.lastIndex-1 downTo 0) {    val curr = getResult(sortedStarts[i][0], sortedStarts[i + 1][0], counter)    answer[sortedStarts[i][1]] = if (curr[1] &gt;= prev[1]) curr[0] else prev[0]       if(curr[1] &gt; prev[1]) {        answer[sortedStarts[i][1]] = curr[0]        prev = curr    }    else if(curr[1] == prev[1]) {        answer[sortedStarts[i][1]] = min(curr[0], prev[0])        prev = if(curr[0] &lt; prev[0]) curr else prev    }    else {        answer[sortedStarts[i][1]] = prev[0]    }}answer.toIntArray()        설명    순서 1.    이 부분은 위에서 설명했듯이 배수를 이용한 약수 개수 구하는 알고리즘을 사용해서 e 까지 빈도를 배열에 저장하면 된다.    순서 2.    이 부분은 풀이 방법이 사람마다 다를 수 있는데 나같은 경우에는 starts 를 정렬해놓고 내림차순으로 각 원소의 result 를 구하는 방법을 사용했다. 예를 들어서 문제 예시에서 준 starts 는 [1, 3, 7] 인데 이를 먼저 정렬한다. (근데 이미 정렬이 되어 있으므로 패스) 그리고  e 는 8 이다.    이제 starts 를 내림차순으로 반복문을 돌려서 7~8 -&gt; 3~8 -&gt; 1~8 이런 식으로 result 를 구한다. 그런데 7~8 을 먼저 계산을 하면 3~8 을 계산할 때 3~7 까지만 계산하면 된다. 7~8 부분은 이미 앞서 계산을 끝마쳤기 때문이다. 서로 두 결과값을 비교해서 빈도가 더 많은쪽을 설정해주면 된다. 만약 빈도가 서로 같다면 문제에서 내건 조건대로 숫자가 더 작은쪽을 설정해주면 된다. 이런 방식으로 계산을 하면은 마지막인 1~8 계산은 1~3 까지만 계산하고 앞서 계산한 3~8 값과 비교해서 값을 업데이트하면 된다.    전체 코드    import kotlin.math.*   class Solution {    fun solution(e: Int, starts: IntArray): IntArray {        val answer = Array(starts.size) {0}        val counter = Array(e+1) {0}        val sortedStarts = Array(starts.size) { Array(2) {0} }              for((i, num) in starts.withIndex()) {            sortedStarts[i][0] = num            sortedStarts[i][1] = i        }        sortedStarts.sortBy {it[0]}                   for (i in 1..e) {            for (j in 1..e / i) {                counter[i*j]++            }        }           return if(starts.size &lt; 2) {            intArrayOf(getResult(starts[0], e, counter)[0])        } else {            var prev = getResult(sortedStarts.last()[0], e, counter)            answer[sortedStarts.last()[1]] = prev[0]                           for(i in sortedStarts.lastIndex-1 downTo 0) {                val curr = getResult(sortedStarts[i][0], sortedStarts[i + 1][0], counter)                answer[sortedStarts[i][1]] = if (curr[1] &gt;= prev[1]) curr[0] else prev[0]                   if(curr[1] &gt; prev[1]) {                    answer[sortedStarts[i][1]] = curr[0]                    prev = curr                }                else if(curr[1] == prev[1]) {                    answer[sortedStarts[i][1]] = min(curr[0], prev[0])                    prev = if(curr[0] &lt; prev[0]) curr else prev                }                else {                    answer[sortedStarts[i][1]] = prev[0]                }            }            answer.toIntArray()        }       }       private fun getResult(i: Int, j: Int, counter: Array&lt;Int&gt;): IntArray {        var maxCnt = 0        var numOfMaxCnt = 0        for(num in i .. j) {            if(counter[num] &gt; maxCnt) {                maxCnt = counter[num]                numOfMaxCnt = num            }        }        return intArrayOf(numOfMaxCnt, maxCnt)    }}      "
  },
  
  {
    "title": "(프로그래머스 | Kotlin) - 요격 시스템",
    "url": "/posts/KotlinAlgorithm1/",
    "categories": "CS, 알고리즘 문제",
    "tags": "Kotlin, Algorithm, 알고리즘, 프로그래머스",
    "date": "2023-10-09 22:00:00 +0900",
    





    
    "snippet": "해결 방법문제를 해석하면 특정 구간이 여러 개 주어지고 그 구간들을 전부 관통할 수 있는 최소의 폭격 미사일 수를 구해야 한다. 문제에서 그리디 알고리즘 문제를 좀 풀어봤다면 예시로 던져준 사진을 보자마자 그리디 문제임을 알아챘을 것이다. 따라서 이 문제는 그리디 알고리즘을 이용해서 해결하면 된다. 해결 순서는 다음과 같다.      targets 내...",
    "content": "해결 방법문제를 해석하면 특정 구간이 여러 개 주어지고 그 구간들을 전부 관통할 수 있는 최소의 폭격 미사일 수를 구해야 한다. 문제에서 그리디 알고리즘 문제를 좀 풀어봤다면 예시로 던져준 사진을 보자마자 그리디 문제임을 알아챘을 것이다. 따라서 이 문제는 그리디 알고리즘을 이용해서 해결하면 된다. 해결 순서는 다음과 같다.      targets 내 특정 구간 i 에 대해서 targets[i][1] 을 기준으로 정렬한다.        첫 폭격 미사일 설치 위치를 targets[0][1] 로 설정한다.    var lastSpot = targets[0][1]            반복문을 통해 정렬된 targets 내의 모든 원소들을 차례로 돌면서 현재 원소의 시작 위치가 lastSpot 위치보다 같거나 크다면 해당 원소의 끝 위치가 다음 폭격 미사일의 설치 위치가 된다.    for(i in targets.indices) {    if(targets[i][0] &gt;= lastSpot) {        lastSpot = targets[i][1]        answer++    }}            3번 반복문 내의 조건문이 충족될 때마다 answer (설치해야 할 폭격 미사일 갯수) 를 증가시킨다.  설명순서 1.모든 원소는 시작과 끝 값을 가지고 있다. 여기서 끝 값을 기준으로 오름차순 정렬을 해주면 특정 원소 인덱스 i  다음부터 모든 원소들의 끝 값은 i 번째 원소의 끝 값보다 무조건 같거나 크다. 그래서 i+1 부터 끝 원소까지 차례로 탐색하면서 시작 위치 값이 i 위치의 끝 값보다 같거나 큰 원소가 나오면 해당 원소의 끝에 폭격 미사일을 설치하면 된다.순서 2.끝 좌표 기준으로 정렬된 상태라면 폭격 미사일을 특정 원소의 끝 좌표를 겨냥해서 설치하는 것이 최대한 많은 원소들을 관통할 확률을 높여준다. 문제 예시 사진처럼 직접 정렬된 형태로 그려놓고 시작 위치에 폭격 미사일을 설치하는 것과 끝 위치에 폭격 미사일 설치하는 것을 비교하면 무슨 말인지 이해할 수 있다.순서 3.문제 조건에서 조심해야 할 점은 시작, 혹은 끝 위치는 폭격이 불가능하다는 것이다. 그래서 특정 원소 i 의 끝 위치가 , i+1  의 시작 위치와 같다고 해도 i  끝 위치에 설치해서 하나로 두 개를 터트릴 수 없다는 뜻이다.그래서 2번에 설명한 끝 위치라는 것은 실제로 끝 값을 의미하는 것이 아닌 최대한 끝 값에 가까운 값으로 가정해서 코드를 작성한다. 배열은 끝 값이 저장되지만 머릿속으로는 끝 값에 가까운 값이라고 생각하면서 문제를 풀면 된다. 이런 이유로 반복문 내 조건문은 현재 원소의 시작 위치가 마지막으로 설치된 폭격 미사일 위치와 같아도 미사일을 새로 설치해야 한다.전체 코드class Solution {    fun solution(targets: Array&lt;IntArray&gt;): Int {        targets.sortBy {it[1]}        var answer= 1        var lastSpot = targets[0][1]        for(i in targets.indices) {            if(targets[i][0] &gt;= lastSpot) {                lastSpot = targets[i][1]                answer++            }        }        return answer    }}"
  },
  
  {
    "title": "Android Navigation에 대해서 알아보자",
    "url": "/posts/Android-Navigation/",
    "categories": "Android, 라이브러리",
    "tags": "Android, UI, 레이아웃, 네비게이션, JetPack",
    "date": "2023-05-05 00:00:00 +0900",
    





    
    "snippet": "Jetpack에서 제공하는 Navigation내비게이션(Navigation)은 안드로이드 Jetpack에서 제공하는 라이브러리 중 하나입니다. 내비게이션은 말 그대로 탐색을 지원하는 라이브러리며 기존의 방식보다 화면 전환을 쉽고 빠르고 유연하게 도와줍니다. 아마 안드로이드 앱 개발을 시작한 지 얼마 안 됐다면 꼭 알아야 하는 라이브러리 중 하나이지 않...",
    "content": "Jetpack에서 제공하는 Navigation내비게이션(Navigation)은 안드로이드 Jetpack에서 제공하는 라이브러리 중 하나입니다. 내비게이션은 말 그대로 탐색을 지원하는 라이브러리며 기존의 방식보다 화면 전환을 쉽고 빠르고 유연하게 도와줍니다. 아마 안드로이드 앱 개발을 시작한 지 얼마 안 됐다면 꼭 알아야 하는 라이브러리 중 하나이지 않을까 싶습니다. 그래서 이번 포스팅은 내비게이션 라이브러리가 무엇이고 왜 사용하며 어떻게 사용하는지 알아보겠습니다.​기존의 화면 전환 방식안드로이드에서 UI를 제공할 수 있는 창은 Activity 와 이에 종속되어서 부분 UI를 나타내는 Fragment 입니다. 그래서 안드로이드 앱 내에서 화면 전환이라 하면 보통 다음과 같이 세 가지가 있습니다.  Activity to Activity  Fragment to Fragment  Activity to Fragment액티비티와 액티비티 사이의 전환은 Intent 객체를 이용해서 구현합니다. 그리고 프래그먼트로의 이동은 fragmentManager 를 이용해서 beginTransaction 을 통해 구현하게 됩니다. 앱 프로젝트 규모가 작다면 상관없지만 규모가 큰 프로젝트라면 사용해야 될 화면도 많아질 것이고 복잡한 화면 전환 구성을 가지게 될 가능성이 높습니다.화면만 전환하면 끝일까요? 화면 전환에 데이터를 담아서 전송할 수도 있고 화면 전환 애니메이션도 적용할 수도 있습니다. 따라서 화면 전환은 많은 작업을 필요로 합니다.​그래서 하나로 합쳐드렸습니다~그래서 구글은 화면 전환에 필요한 라이브러리, 툴, 플러그인 등을 하나로 합쳐서 Navigation이라는 라이브러리를 만들었습니다. 기존에 인텐트 혹은 프래그먼트 매니저를 통한 화면 전환에서 내비게이션 XML 공간에서 쉽게 탐색구조를 구축하는 방식으로 전환된 것입니다.아래 사진과 같이 내비게이션 XML에서 기존에 가지고 있는 프래그먼트나 액티비티를 추가해서 원하는 탐색구조를 마우스로 연결해 주기만 하면 화살표가 생성되어 화면 전환 구조에 대한 직관적인 파악이 가능해집니다.​쉽고 깔끔한 프래그먼트로의 전환내비게이션 라이브러리를 사용했을 때 얻을 수 있는 장점은 프래그먼트 전환이 굉장히 쉬워집니다. 설명드린 대로 현재 생성한 프래그먼트들을 다 추가해서 연결하기만 하면 생성된 id 를 통해서 전환을 할 수 있는데 이 전환을 요청하는 코드도 굉장히 짧고 간단합니다.  그래서 이 라이브러리를 사용하면 프래그먼트를 실컷 생성해서 복잡한 탐색구조를 구축할 수 있습니다.​Single Activity이러한 장점 때문에 구글에서는 프래그먼트 전환 관리가 쉬운 네비게이션을 통해 단일 액티비티 구조를 권장합니다. 액티비티를 하나만 생성하고 나머지는 전부 프래그먼트로 채우라는 소리입니다. 단일 액티비티 구조를 주장하는 이유는 다음과 같습니다.  Activity 는 Fragment 에 비해 덩치가 큰 객체라 메모리, 속도 면에서 불리하다.  Fragment 는 Activity 에 비해 비교적 쉬운 데이터 공유, 유연한 UI 구축의 장점을 가지고 있다.​Navigation 대표 구성요소 세 가지Navigation Graph탐색구조를 구축할 수 있는 XML 리소스 파일입니다. 여기서 화면 전환, 애니메이션 등을 세팅할 수 있습니다.NavHost여러 프래그먼트를 담을 수 있는 하나의  컨테이너입니다. 이 컨테이너에서 여러 프래그먼트의 전환이 일어나게 됩니다.  탐색구조를 여러 개의 그룹으로 쪼개고 싶다면 NavHost 를 여러 개 만들어서 구축할 수도 있습니다.NavController각각의 NavHost 는 하나의  NavController 를 가지고 있습니다. 이 친구는 앱 내의 탐색을 관리하여 A에서 B로 전환해야 되는 상황이 발생하면 이를 인식하고 화면 전환을 수행합니다.findNavController().navigate(R.id.action)세 가지를 종합해보면?Navigation Graph를 통해서 탐색구조를 정의를 하여 전환이 필요할 때 NavController 에게 요청을 합니다. 그럼 컨트롤러는 이를 수행하고 NavHost 는 이를 인식하여 기존 프래그먼트에서 알맞은 프래그먼트로 교체하여 화면에 표시합니다.​Navigation 사용 방법0. Dependency 설정dependencies {  // 글 작성 기준으로 2.5.3 버전입니다.  def nav_version = \"2.5.3\"  implementation \"androidx.navigation:navigation-fragment-ktx:$nav_version\"  implementation \"androidx.navigation:navigation-ui-ktx:$nav_version\"}​1. 프래그먼트를 보여줄 NavHost 지정하기지금부터 설명드리는 예시는 액티비티에 여러 프래그먼트를 띄우는 방식입니다. 따라서 저는 액티비티 레이아웃 XML에 FragmentContainer를 만들어서 이 친구를 NavHost 로 지정하겠습니다. android:name  을 호스트 프래그먼트로 지정해 주고 app:navGraph 는 뒤에 그래프를 만들면 그때 추가해 주세요.&lt;androidx.fragment.app.FragmentContainerView    android:id=\"@+id/fcv_main\"    android:name=\"androidx.navigation.fragment.NavHostFragment\"    android:layout_width=\"0dp\"    android:layout_height=\"0dp\"    app:defaultNavHost=\"true\"    app:layout_constraintBottom_toTopOf=\"@id/bnv_main\"    app:layout_constraintEnd_toEndOf=\"parent\"    app:layout_constraintStart_toStartOf=\"parent\"    app:layout_constraintTop_toTopOf=\"parent\"    app:navGraph=\"@navigation/nav_main\" /&gt;​2. Navigation Graph 정의안드로이드 res 폴더 내에 New 를 통해  Android Resource Directory 를 누르시면 navigation 디렉토리를 따로 만들 수 있습니다. 생성하고 그 안에 리소스 파일을 새로 생성해 주세요. 생성했다면 밑의 예시처럼 필요한 액티비티나 프래그먼트를 불러서 마우스로 연결해 주세요.​3. navController를 통해 화면 전환 요청 코드 작성하기그래프를 다 만들었다면 Split을 통해서 XML 코드도 확인해 보세요. 그러면 &lt;fragment&gt;  태그로 감싸진 코드가 굉장히 많아진 것을 볼 수 있습니다. 그중에서 하나만 보겠습니다. 해당 프래그먼트는 연결 지점이 한 곳입니다. 이는 &lt;action&gt;에 정의되어 있습니다. 만약에 연결한 프래그먼트가 세 곳이면 &lt;action&gt; 은 세 개가 됩니다.    &lt;fragment        android:id=\"@+id/nav_my_page\"        android:name=\"com.example.travelfeeldog.presentation.mypage.MyPageFragment\"        android:label=\"fragment_my_page\"        tools:layout=\"@layout/fragment_my_page\" &gt;        &lt;action            android:id=\"@+id/action_nav_my_page_to_myReviewFragment\"            app:destination=\"@id/myReviewFragment\"            app:enterAnim=\"@anim/nav_default_enter_anim\"            app:exitAnim=\"@anim/nav_default_exit_anim\"            app:popEnterAnim=\"@anim/nav_default_pop_enter_anim\"            app:popExitAnim=\"@anim/nav_default_pop_exit_anim\" /&gt;    &lt;/fragment&gt;연결한 프래그먼트로 이동을 위해서 액션 아이디인 android:id 를 통해서 요청하면 됩니다.binding.clReviewArea.setOnClickListener{    findNavController().navigate(R.id.action_nav_my_page_to_myReviewFragment)}​BottomNavigationView 연동내비게이션은 바텀 내비게이션 뷰와 연결이 가능합니다. 방법은 다음과 같습니다.1. 필요한 메뉴 구성res  에서 menu  디렉토리(없으면 생성)에 바텀 내비게이션 전용 메뉴 XML 을 생성합니다. 생성했으면 해당 파일에 필요한 메뉴를 정의합니다. 저는 홈, 검색, 마이 페이지가 필요하므로 세 개를 만들었습니다.&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;    &lt;item android:id=\"@+id/nav_home\"        android:title=\"@string/navigation_home\"        android:icon=\"@drawable/ic_home\"/&gt;    &lt;item android:id=\"@+id/nav_search\"        android:title=\"@string/navigation_search\"        android:icon=\"@drawable/ic_search\"/&gt;    &lt;item android:id=\"@+id/nav_my_page\"        android:title=\"@string/navigation_my_page\"        android:icon=\"@drawable/ic_my_page\"/&gt;&lt;/menu&gt;  메뉴 아이템 태그의 아이디, 네비게이션 그래프에 정의한 프래그먼트 태그의 아이디는 동일해야 한다.​2. BottomNavigationView 생성액티비티 레이아웃 XML에 바텀 내비게이션 뷰를 생성합니다. 생성했으면 속성으로 app:menu 를 추가하여 만든 메뉴 파일을 연결합니다.&lt;com.google.android.material.bottomnavigation.BottomNavigationView    android:id=\"@+id/bnv_main\"    android:layout_width=\"0dp\"    android:layout_height=\"wrap_content\"    android:background=\"@color/white\"    android:paddingTop=\"6dp\"    app:itemIconTint=\"@color/selector_bottom_nav_color\"    app:itemRippleColor=\"@null\"    app:itemTextAppearanceActive=\"@style/Widget.BottomNavigationView.Active\"    app:itemTextAppearanceInactive=\"@style/Widget.BottomNavigationView.InActive\"    app:itemTextColor=\"@color/selector_bottom_nav_color\"    app:labelVisibilityMode=\"labeled\"    app:layout_constraintBottom_toBottomOf=\"parent\"    app:layout_constraintEnd_toEndOf=\"parent\"    app:layout_constraintStart_toStartOf=\"parent\"    app:layout_constraintTop_toBottomOf=\"@id/fcv_main\"    app:menu=\"@menu/menu_bottom\" /&gt;​3. BottomNavigationView 호스트에 NavController 연결마무리로 바텀 내비게이션 뷰를 가지고 있는 액티비티에 컨트롤러를 연결해야 합니다. 해당 코드는 호스트가 되는 액티비티에서 일부를 가져왔습니다.override fun onCreate(savedInstanceState: Bundle?) {    super.onCreate(savedInstanceState)    setContentView(binding.root)    binding.bnvMain.setupWithNavController(findNavController())}private fun findNavController(): NavController {    val navHostFragment =        supportFragmentManager.findFragmentById(R.id.fcv_main) as NavHostFragment    return navHostFragment.navController}​마무리안 중요한 라이브러리는 없지만 내비게이션 라이브러리는그중에서도 유용하고 정말 중요한 것 같습니다. 제가 첫 안드로이드 프로젝트를 했을 때 내비게이션의 존재를 모르고 수작업으로 전환 코드를 작성해서 엄청 고생했던 기억이 있습니다. 처음 시작하는 분들은 저처럼 삽질하지 말고 내비게이션으로 편한 프로젝트 되시길 바랍니다 :)참조Android 공식 문서 - NavigationAndroid 공식 문서 - Navigation 시작하기"
  },
  
  {
    "title": "Android의 UI, 뷰(View) 그리고 레이아웃(ViewGroup)",
    "url": "/posts/Android-UI/",
    "categories": "Android, 기본",
    "tags": "Android, UI, 레이아웃, 뷰",
    "date": "2023-04-06 12:00:00 +0900",
    





    
    "snippet": "모바일 UI는 어떻게 구성되어 있는가?예시로 우리가 스마트폰을 이용해서 배달의민족 앱을 이용할 때를 생각해 봅시다. 해당 앱에 접속을 해보면 여러 카테고리 버튼이 있고 밑으로 스크롤을 하면 여러 음식점들의 간략한 정보가 리스트 형식, 혹은 카드 형태로 제공됩니다.특정 음식점을 클릭하면 해당 음식점에 대한 상세 페이지로 이동하게 되고 여기서는 가게에 대...",
    "content": "모바일 UI는 어떻게 구성되어 있는가?예시로 우리가 스마트폰을 이용해서 배달의민족 앱을 이용할 때를 생각해 봅시다. 해당 앱에 접속을 해보면 여러 카테고리 버튼이 있고 밑으로 스크롤을 하면 여러 음식점들의 간략한 정보가 리스트 형식, 혹은 카드 형태로 제공됩니다.특정 음식점을 클릭하면 해당 음식점에 대한 상세 페이지로 이동하게 되고 여기서는 가게에 대한 텍스트 정보, 음식 사진에 대한 이미지 정보, 메뉴들을 선택할 수 있는 체크박스, 해당 가게 정보를 저장할 수 있는 찜 버튼과 같은 다양한 상호작용 요소들을 볼 수 있습니다.  이렇듯 모바일 UI는 하나의 화면 안에 사용자와 상호작용이 가능한 다양한 요소들이 존재합니다.​Android는 UI를 어떻게 제작하는가?그렇다면 Android는 이러한 모바일 UI를 어떤 방식으로 구현할까요? 가장 먼저 사용자에게 앱과 상호작용할 수 있는 화면으로 안내하는 것이 우선입니다.상호작용을 위한 화면안드로이드는 사용자가 앱과 상호작용할 수 있도록 진입점을 제공하는데 이것이 Activity 입니다. 액티비티는 안드로이드 앱을 구성하는 4대 구성 요소 중에 하나이며 사용자에게 UI를 제공하여 상호작용을 하기 위한 진입점입니다. 안드로이드 앱 내에 여러 화면을 구성할 수 있는 것도 액티비티가 있기 때문입니다.화면 내에 존재하는 여러 상호작용 요소들사용자가 Activity 에 도달했다면 이제는 그곳에 배치된 여러 요소들을 통해서 본격적으로 상호작용을 할 수 있게 됩니다. 이 요소들은 뷰(View) 와 뷰그룹(ViewGroup) 이라는 것들의 계층 구조로 이루어져 있습니다. 배달의민족을 통해 음식점 상세 페이지에 갔을 때 볼 수 있는 텍스트, 이미지, 체크박스, 이미지 버튼 등의 요소들을 뷰(View) 라고 하고 이런 여러 뷰들을 담는 컨테이너를 뷰그룹(ViewGroup) 이라고 합니다.​뷰(View)안드로이드는 사용자와 상호작용할 수 있는 요소 제작과 배치를 위해서 View 객체를 제공합니다. 뷰는 사용자 인터페이스의 기본적인 구성 요소이며 그리기 및 이벤트 처리를 담당합니다. 뷰를 다른 말로 위젯이라고도 합니다.뷰 객체는 여러 속성과 메서드를 가지고 있습니다. 대표적으로  draw() 라는 메서드가 있는데 이를 통해서 화면에 뷰를 그릴 수 있습니다. 이벤트 처리 같은 경우에는 대표적인 예시로 클릭에 대한 이벤트가 있는데 사용자가 뷰를 클릭하면 이를 감지하여 어떤 동작을 처리할 수 있게 지원합니다.여러 뷰들은 View 객체로부터 파생된 것(View Hierarchy)뷰 객체가 가지고 있는 속성과 메서드의 상속을 통해서 특정 기능을 가진 뷰로 확장시키는 방식으로 다양한 뷰들을 만들 수 있는데 안드로이드에서 기본적으로 제공하는 뷰들이 이에 해당됩니다. 따라서  많이 사용되는  TextView, Button, ImageView 등의 뷰들은 전부 View 객체에서 파생된 뷰입니다.기본 제공되는 뷰들을 사용해서 UI 구성을 진행하고 만약에 기본적으로 제공되는 뷰의 기능이 부족하다면 직접 뷰 객체를 커스텀 해서 만들어야 합니다. 이를 커스텀 뷰라고 하는데 이 부분은 나중에 따로 포스팅해보겠습니다.뷰의 상속 관계(View Hierarchy)​​뷰그룹(ViewGroup)ViewGroup 은 상속 관계도에서 확인할 수 있듯이  View 를 상속받은 객체입니다. 뷰그룹은 다른 말로  레이아웃이라고 하는데 여러 View 들을 담을 수 있고 이런 여러 뷰들의 배치를 도와줍니다. 뷰그룹은 여러 뷰도 담을 수 있지만 다른 뷰그룹도 담을 수 있습니다. 그래서 중첩으로 레이아웃을 만들어 좀 더 복잡한 배치를 할 수 있습니다. 레이아웃의 종류는 크게 6개로 볼 수 있습니다.LinearLayout  뷰를 일렬로 배치하는 레이아웃      배치 방식을 위한 orientation 속성을 제공                  orientation = vertical : 세로로 배치                            orientation = horizontal : 가로로 배치                    ​RelativeLayout  뷰의 상대적인 위치에 따라 배치하는 레이아웃      상대적인 위치 설정을 위한 속성들을 제공 RelativeLayout.LayoutParams        속성 몇 가지 예시          layout_alignParentTop      layout_centerVertical      layout_below      layout_toRightOf            배치 예시      ​FrameLayout  뷰를 중첩해서 배치하는 레이아웃      visibility  속성을 이용해서 상황에 따라 특정 뷰만 보이게 하고 나머지 뷰는 보이지 않게 설정        배치 예시      ​TableLayout  행과 열을 통해 표 형태로 뷰를 배치하는 레이아웃      TableRow  를 이용해 한 행을 생성하고 이 안에 여러 뷰들을 만들어서 열을 채우는 방식으로 배치        TableRow 내에는 View 혹은 ViewGroup  를 넣을 수 있음        배치 예시      ​GridLayout  격자 배치 레이아웃      TableLayout 와 마찬가지로 행과 열을 이용해 배치, 하지만 그리드레이아웃이 더 유연한 배치가 가능        행과 열에 대한 속성을 제공해서 유연한 배치 가능        배치 예시      ​ContraintLayout  제약 조건을 통한 배치 레이아웃      부모 레이아웃을 기반으로 배치하는 것이 아닌 동일한 뷰를 기반으로 유연한 배치가 가능        뷰와 뷰그룹의 계층 구조로 이루어진 Android의 UI 에서 제약레이아웃을 통해 플랫한 계층 구조 설계가 가능        사용 가능한 제약 조건들          Relative positioning      Margins      Centering positioning      Circular positioning      Visibility behavior      Dimension constraints      Chains      Virtual Helpers objects      Optimizer            배치 예시      ​Android의 UI는 뷰와 뷰그룹의 계층 구조지금까지의 이야기를 종합해 보면 사용자와 상호작용을 위한 기본적인 구성 요소인 뷰들을 레이아웃에 담아서 배치하는 식으로 UI를 제작합니다. UI가 단순하다면 단순히 하나의 레이아웃 안에 여러 뷰들을 넣어서 배치할 것이고 UI가 좀 더 복잡하다면 트리 구조처럼 레이아웃 안에 레이아웃을 더 만들어 배치할 것입니다.따라서 안드로이드의 UI는 뷰와 뷰그룹의 계층 구조로 이루어져 있습니다. 레이아웃 XML 파일을 들여다보면 루트에 레이아웃이 있고 그 안에 뷰나 레이아웃을 만드는 식의 계층 구조 형태로 제작하게 돼있습니다.​계층 구조 레이아웃의 최적화트리 구조를 생각해보자.트리 구조의 깊이가 증가할수록 어떤 단점이 발생할까요? 노드 탐색이 느려질 수 있다는 단점이 생깁니다. 만약에 찾고 싶은 노드가 가장 밑단에 위치해 있다면 트리의 깊이가 깊을수록 탐색 시간도 늘어나게 됩니다.트리를 이용한  Union-Find도 탐색 시간 최적화를 위해서 모든 자식 노드의 부모 노드를 루트 노드로 설정해서 깊이를 최소로 줄이는 방법을 사용합니다.Android UI 계층 구초는 가능한 한 얕게 유지해야 한다.뷰와 뷰그룹의 계층 구조의 안드로이드 UI도 가능하면 깊이를 얕게 유지해야 합니다. 중첩 레이아웃이 레이아웃 계층 구조의 깊이를 증가시키는 원인이므로 되도록이면 중첩 레이아웃을 사용하지 않고 배치하는 노력을 하는 것이 좋습니다. 얕게 유지하면 유지할수록 레이아웃이 더 빠르게 화면에 그려지게 됩니다.  가로로 넓은 뷰 계층 구조가 세로로 깊은 뷰 계층 구조보다 낫습니다.ConstraintLayout을 주로 사용하는 이유ConstraintLayout 은 이것만으로 다른 대부분의 레이아웃들의 배치 특성을 구현할 수 있고 뷰에 대한 포지셔닝이 굉장히 유연해서 가로로 넓은 뷰 계층 구조를 만들 수 있습니다. 그래서 저는 제약레이아웃을 주로 사용하고 있습니다.​마무리결국에는 여러 뷰와 뷰그룹을 통해서 UI를 구상하고 완성된 레이아웃 XML 파일은 Activity 에 연결되어 사용자에게 제공됩니다. 그래서 액티비티에서 뷰를 참조하여 특정한 UI 처리를 할 수 있습니다. 요즘에는 XML 방식이 아닌 최신 UI 제작 도구인 Jetpack compose를 도입하려는 움직임이 많습니다. 저도 나중에 기회가 되면 꼭 배워보려고 합니다.마지막으로 혹시나 틀린 부분이 있다면 댓글로 남겨주세요. 바로 수정하도록 하겠습니다. 긴 글 읽어주셔서 감사하고 이 글을 읽는 여러분 모두 좋은 하루 보내시길 바랍니다!​참조안드로이드 공식문서 - 레이아웃안드로이드 공식문서 - 성능 및 뷰 계층 구조찰스의 안드로이드"
  },
  
  {
    "title": "Union-Find 유니온 파인드",
    "url": "/posts/Uinon-Find/",
    "categories": "CS, 알고리즘",
    "tags": "알고리즘, 자료구조, 유니온 파인드",
    "date": "2023-02-21 12:00:00 +0900",
    





    
    "snippet": "서로소 집합(disjoint-set)을 관리하는 자료 구조다양한 원소들이 서로소 집합을 이루는 경우가 있습니다. 필요에 따라서 이 집합들을 이용하여 서로 합치거나 특정 원소를 통해 특정 집합을 탐색할 수도 있습니다. 유니온 파인드(union-find)는 그래프 알고리즘으로 서로소 집합을 관리하며 서로 다른 두 노드가 동일한 집합에 있는지 판별합니다.유...",
    "content": "서로소 집합(disjoint-set)을 관리하는 자료 구조다양한 원소들이 서로소 집합을 이루는 경우가 있습니다. 필요에 따라서 이 집합들을 이용하여 서로 합치거나 특정 원소를 통해 특정 집합을 탐색할 수도 있습니다. 유니온 파인드(union-find)는 그래프 알고리즘으로 서로소 집합을 관리하며 서로 다른 두 노드가 동일한 집합에 있는지 판별합니다.유니온 파인드는 서로 다른 두 노드가 같은 집합에 있는지 판별하기 위해서 각 집합의 대표 원소를 참고합니다. 여기서 대표 원소라 함은 연결 리스트에서는 헤드가 되며 트리에서는 루트 노드가 해당됩니다. 두 노드가 속한 집합의 대표 원소를 찾아서 대표 원소가 서로 동일하면 같은 집합에 있는 걸로 판단하게 됩니다. 이러한 판단 과정에서 여러 집합들이 합쳐지거나(Union) 특정 원소가 속한 대표 원소를 찾기 위해 집합 탐색(Find) 을 진행하기도 합니다. 그래서 유니온 파인드에서는 다음과 같은 연산들이 존재합니다.​연산의 종류            연산      특징                  MakeSet      특정 한 원소만 존재하는 집합을 만든다.              Union      두 개의 집합을 하나의 집합으로 합친다.              Find      특정 원소가 속한 집합의 대표 원소를 반환한다.      ​구현과 관리를 위해 사용되는 방법유니온 파인드를 관리하는 방식은 두 가지가 있습니다. 첫 번째는 연결 리스트를 통한 관리고 두 번째는 트리 구조를 이용한 관리입니다. 각 방식들이 유니온 파인드의 연산을 어떻게 처리하는지 알아보도록 합시다.연결 리스트            연산      방법                  MakeSet      원소 하나만 가지고 노드를 생성한다. 헤드가 해당 집합의 대표 원소다.              Union      한 집합의 헤드 부분이 다른 집합의 꼬리(Tail) 부분을 가리키는 방식으로 연결한다.              Find      지목한 원소의 집합에 존재하는 헤드 원소를 찾아 반환한다.      ​트리 구조            연산      방법                  MakeSet      원소 하나만 가지고 노드를 생성한다. 루트 노드가 해당 집합의 대표 원소다.              Union      한 집합의 루트 노드를 다른 집합의 자식 노드로 연결한다.              Find      특정 원소가 속한 집합의 루트 노드를 찾아 반환한다.      ​연결 리스트를 통한 관리MakeSet​Union​Find​트리 구조를 이용한 관리MakeSet​Union​​​Find​코드로 구현연결 리스트와 트리 구조를 코드로 구현해 보겠습니다. 연결 리스트와 트리 구조의 노드는 구조체나 클래스 등을 통해서 만들 수 있지만 배열로도 구현이 가능합니다.배열의 인덱스가 각 원소의 번호이며 인덱스에 해당하는 값은 해당 인덱스(원소 번호) 가 가리키고 있는 노드의 원소 번호입니다. 따라서 집합 내에서 대표 원소는 최상위에 위치하므로 가리킬 대상이 없고 자기 자신을 가리키게 됩니다. 여기서는 배열의 이름을 parent 라고 하겠습니다. ( 예시로 원소는 8개, 1번 ~ 8번까지 있다고 가정하겠습니다. )MakeSetvoid MakeSet(int X) {  parent[x] = x;}            index      1      2      3      4      5      6      7      8                  parent      1      2      3      4      5      6      7      8      ​Unionvoid Union(int x, int y) {    x = Find(parent[x]);    y = Find(parent[y]);    parent[x] = y;}ex) Union(1, 2)            index      1      2      3      4      5      6      7      8                  parent      2      2      3      4      5      6      7      8      ex) Union(2, 3)            index      1      2      3      4      5      6      7      8                  parent      2      3      3      4      5      6      7      8      ​Findint Find(int x) {    if(parent[x] == x) return x;    return Find(parent[x]);}  재귀 방식을 통해서 루트 노드 혹은 헤드 노드까지 이동해서 해당 원소를 반환합니다.​문제점과 해결 방안 : 연결 리스트 방식지금까지 설명드린 방법은 가장 간단한 방법입니다.  여기서 문제점이 존재합니다. 바로 Find 연산입니다.  연결 리스트와 트리 구조 둘 다 깊이가 커지면 대표 원소를 찾는 시간이 그만큼 오래 걸리게 됩니다. 원소가 n개라면 최악의 경우에는 Find연산이 O(n) 이 됩니다. 연산 시간을 단축시키기 위해서는 어떻게 해야 할까요?각 노드에 헤드를 가리키는 포인터를 추가시킨다.이전에 설명드린 것처럼 연결 리스트는 꼬리(Tail) 부분에서 헤드를 찾게 되면 해당 집합의 모든 원소들을 거치게 됩니다. 운 좋게 원소 2를 지목하면 한 번 이동하고 바로 헤드를 찾게 되지만 그림처럼 꼬리 부분의 원소를 지목하게 될 경우에는 전체를 거쳐서 탐색 시간이 오래 걸리게 됩니다.​그래서 나온 해결책이  모든 노드에 헤드를 가리키는 포인터를 추가하는 것입니다. 그렇게 되면 어느 원소를 지목해도 상수 시간에 바로 헤드에 위치한 원소를 알 수 있습니다.​\t​  하지만 만약 Union을 진행하면 합쳐지는 집합의 모든 원소들이 가리키는 헤드 업데이트가 필요하다.​​​​\t​문제점과 해결 방안 : 트리 구조 방식유니온 바이 랭크(Union by rank)두 집합을 Union 할 때 트리의 깊이가 작은 집합을 트리의 깊이가 큰 집합의 루트 노드에 붙이는 방식입니다. 이러한 방식으로 유니온을 하면 두 트리의 깊이가 동일한 경우에만 깊이가 증가하게 됩니다. 따라서 깊이가 증가하는 것을 최대한 방지해서 Find 연산 시간을 단축시킵니다.​​  만약 유니온 바이 랭크를 적용하지 않는다면 유니온 했을 때 깊이가 증가할 수 있습니다.​​유니온 바이 랭크 구현 function MakeSet(x)     x.parent := x     x.rank   := 0 function Union(x, y)     xRoot := Find(x)     yRoot := Find(y)     // if x and y are already in the same set (i.e., have the same root or representative)     if xRoot == yRoot         return     // x and y are not in same set, so we merge them     if xRoot.rank &lt; yRoot.rank         xRoot.parent := yRoot     else if xRoot.rank &gt; yRoot.rank         yRoot.parent := xRoot     else         yRoot.parent := xRoot         xRoot.rank := xRoot.rank + 1  해당 코드는 wekipedia 서로소 집합 자료 구조에서 참조했음을 알려드립니다.  wekipedia 서로소 집합 자료 구조​경로 압축(path compression)Find(x) 연산은 원소 x 가 속한 집합의 대표 원소를 찾아줍니다. 가장 간단한 방법은 대표 원소를 찾아 반환하고 끝내는 방식이지만 경로 압축에서는 대표 원소를 반환하기 전에 x 를 루트 노드(대표 원소)에 연결하고 대표 원소를 반환합니다. 이렇게 하면 모든 원소들이 대표 원소를 의미하는 루트 노드를 가리키게 됩니다. 이런 방식으로 모든 원소들을 루트 노드(대표 원소)로 연결시키면 연산 시간을 단축시킬 수 있습니다.​​경로 압축 구현 function Find(x)     if x.parent != x        x.parent := Find(x.parent)     return x.parent  해당 코드는 wekipedia 서로소 집합 자료 구조에서 참조했음을 알려드립니다.  wekipedia 서로소 집합 자료 구조​참조wekipedia 서로소 집합 자료 구조신찬수 교수님 : 자료구조 - union-find 자료구조 1/2"
  },
  
  {
    "title": "Android 액티비티 생명주기",
    "url": "/posts/android-lifecycle/",
    "categories": "Android, 기본",
    "tags": "Android, 모바일, 안드로이드, 생명주기, 개발",
    "date": "2023-02-14 00:00:00 +0900",
    





    
    "snippet": "생명주기가 무엇인가?1. 소프트웨어 개발 계획의 시작부터 끝까지 따라야 할 단계와 그것에 따른 계획의 형태 변화.2. 소프트웨어가 만들어져서 폐기될 때까지의 기간.    사용자의 요구에 대한 분석 및 설계, 그리고 프로그램 작성을 거쳐 운용되는 일련의 과정을 포함한다.네이버 국어사전에서 말하는 생명 주기는 다음과 같습니다. 즉, 액티비티가 만들어지고 ...",
    "content": "생명주기가 무엇인가?1. 소프트웨어 개발 계획의 시작부터 끝까지 따라야 할 단계와 그것에 따른 계획의 형태 변화.2. 소프트웨어가 만들어져서 폐기될 때까지의 기간.    사용자의 요구에 대한 분석 및 설계, 그리고 프로그램 작성을 거쳐 운용되는 일련의 과정을 포함한다.네이버 국어사전에서 말하는 생명 주기는 다음과 같습니다. 즉, 액티비티가 만들어지고 없어질 때까지의 과정을 말합니다. 어떤 생명이 탄생해서 죽을 때까지의 과정이 존재하듯  안드로이드의 액티비티도 생성되어 소멸하기까지의 과정을 가지고 있습니다.​생명주기는 왜 있는가?그렇다면 이쯤에서 드는 생각이 있을 겁니다. 그러면 생명주기는 왜 있는 것인가? 이 질문에 대한 해답은 모바일 사용 환경을 생각해 보면 됩니다. 다음과 같은 경우를 생각해 봅시다.  사용자가 앱을 사용하는 도중에 전화가 왔을 때  사용자가 앱에서 나갔다가 돌아왔을 때 이전의 데이터들이 저장되지 않는 문제  세로 모드로 사용하다가 가로로 돌려서 가로 모드로 전환  앱을 사용하는 도중에 홈 화면으로 이동 후, 다른 앱을 실행시킬 때네 가지 경우를 보면 모바일 사용자 환경에서는 많은 상태 변화가 발생한다는 것을 알 수 있습니다. 아마 사용자 입장에서는 위의 상황들이 발생해도 아무런 오류가 없이 매끄럽게 앱이 작동되길 바랄 겁니다.앱이 아무런 오류 없이 매끄럽게 동작하려면 어떻게 해야 할까요? 바로 다양한 상태 변화가 발생했을 때 상태에 따라 알맞은 작업을 하고 적절한 전환을 처리해야 할 것입니다. 그래서 현재 앱이 어떤 상태에 있는지를 계속 파악하는 것이 중요하고 이를 파악하기 위해서 생명주기가 있는 것입니다.​Android의 생명주기생명주기의 시작은 탄생이고 끝은 죽음입니다. 그리고 그 사이에는 다양한 상태들이 존재합니다. 탄생 후에 본격적으로 활동을 위한 준비단계가 있을 것이며 많은 활동 끝에 죽음을 준비하기 위한 단계도 있을 것입니다.안드로이드에서 정의한 액티비티의 생명주기 단계들은 시작과 실행 사이에  onCreate(),  onStart(),  onResume()  순서로 있고 실행과 종료 사이에  onPause(), onStop(), onDestroy() 순으로 여러 상태들이 존재합니다. 따라서 사용자가 앱을 이용하면 그 과정에서 여러 가지의 상태 변화가 발생하는데 이는 생명주기에 따라 적절히 처리됩니다.​생명주기 처리를 위한 콜백 메서드상황에 따라 적절한 처리를 해주려면 생명주기 내에서 해당 상황에 맞는 특정 상태를 알 수 있어야 합니다. 어떤 상태인지를 알아야 그에 맞는 처리를 해줄 수 있으니까요. 안드로이드는 이를 위해 생명주기 내의 다양한 단계들을 콜백 형태로 제공합니다.액티비티 클래스는 onCreate(),  onStart(), onResume() , onPause(), onStop(),onDestroy() 함수들을 상속받습니다. 상속을 받고 이 함수들을 필요에 따라 재정의 하여 특정 상황의 발생으로 인해서 호출이 됐을 때 재정의 한 내용을 토대로 처리를 하게 됩니다. 예를 들어서 가로 모드로 전환을 했을 때는 화면의 구성이 바뀌므로 수명주기의 상태는 onCreate() 에 해당이 되어 시스템에서 onCreate() 콜백을 호출합니다.  이렇게 각 콜백은 상태 변화에 적합한 특정 작업을 실행할 수 있도록 하고 적시에 알맞은 작업과 적절한 전환을 통해 앱이 더욱 안정적으로 기능할 수 있도록 해줍니다.​콜백 메서드 소개지금까지 생명주기가 왜 존재하고 어떻게 처리하는지 알아봤습니다. 콜백 호출을 통해서 상태 변화에 대응한다는 것을 알았으므로 이제는 각 콜백 메서드의 역할과 특징에 대해 알아보겠습니다.onCreate()시스템이 액티비티를 생성할 때 실행되고 필수적으로 구현해야 하는 콜백 메서드입니다. onCreate() 메서드에서는 액티비티의 전체 수명 주기 동안 한 번만 발생해야 하는 기본 애플리케이션 시작 로직을 실행합니다. 예를 들어 데이터 바인딩, ViewModel 연결, 클래스 인스턴스화 등을 onCreate() 에서 처리한다고 보면 되겠습니다. 대표적으로 레이아웃 XML을 액티비티로 불러올 때 setContentView() 함수를 onCreate() 에서 호출합니다.onCreate() 메서드는 savedInstanceState 를 매개변수로 받는데 이는 Bundle 객체입니다. savedInstanceState 는 액티비티의 이전 상태 정보들을 가지고 있습니다. 액티비티가 어떤 이유로 화면을 재구성하게 된다면 기존에 존재하던 값들이 초기화되는 것을 방지할 필요가 있을 수도 있습니다. 그래서 따로 저장을 해두면 나중에 액티비티가 다시 생성될 때 savedInstanceState 를 이용하여 저장했던 값들을 불러올 수 있습니다.마지막으로 onCreate() 가 호출이 완료되면 시스템은 거기서 멈추지 않고 뒤이어 onStart() 와  onResume() 콜백 메서드를 호출합니다.override fun onCreate(savedInstanceState: Bundle?) {    super.onCreate(savedInstanceState)    binding = ActivityMainBinding.inflate(layoutInflater)    val view = binding.root    setContentView(view)}​onStart()액티비티가 사용자에게 표시되고 앱은 액티비티를 포그라운드에 보내서 상호작용을 준비합니다. 액티비티는 사용자에게 표시되지만 아직은 상호작용을 할 수 없는 단계입니다. 상호작용 준비를 위해서 이 단계에서 UI를 관리하는 코드를 초기화합니다.onStart() 는 매우 빠르게 완료되고 onCreate() 때와 마찬가지로 시스템은 여기서 머무르지 않고  onResume()  콜백 메서드를 호출하게 됩니다.​onResume()액티비티가 포그라운드에 표시되고 사용자와 상호작용을 시작합니다. 중간에 전화가 와서 포커스가 전화 알람으로 이동하거나 다른 액티비티로 화면 전환을 하여 포커스가 이동한 액티비티로 전환되거나 기기 화면이 꺼져서 포커스를 잃는 등의 현재 액티비티에 대한 포커스 소실이 발생하면 앱은  onResume() 에서 벗어나고 그렇지 않다면 onResume()  상태에서 머물게 됩니다.만약 현재 상태에서 방해 이벤트가 발생한다면 액티비티는 일시 중지 상태를 의미하는 onPause() 콜백 메서드를 호출해서 상태 변화를 합니다. 일시 중지 상태에서 다시 액티비티로 돌아온다면 시스템은 다시  onResume() 를 호출합니다.​onPause()사용자가 액티비티를 떠날 때 첫 번째로 호출되는 콜백 메서드입니다.  액티비티가 포그라운드에서 벗어나는 경우 일시중지 상태로 전환됩니다. 이 일시 중지는 onPasue() 를 의미합니다. onPause() 가 호출되는 경우는 onResume() 에서 설명한 예시들에 해당됩니다.액티비티가 포그라운드에 있지 않다면 일시 중지 상태가 되어 원래 사용됐던 기능들을 실행할 필요가 없어지게 됩니다. 그래서 이때는 필요에 따라 onPause() 메서드를 이용하여 시스템 리소스, GPS, 배터리 수명에 영향을 미칠 수 있는 리소스들을 해제할 수도 있습니다.하지만 주의할 점이 있습니다.  onPause() 는 잠깐동안 실행되므로 시간이 길어질 수 있는 애플리케이션 또는 사용자 데이터 저장, 네트워크 호출, 데이터베이스 트랜잭션 등의 작업은 onPause() 가 끝난 후에도 완료가 안될 수도 있습니다. 그래서 공식 문서에서는 이러한 작업들은 onPause() 에서 하지 말고 onStop() 상태일 때 처리하라고 추천합니다.액티비티가 다시 포그라운드에 복귀하면 시스템은 다시 onResume() 을 호출하게 됩니다. 일시 중지 상태에서 재개 상태로 돌아오면 그 과정에서 시스템은 액티비티의 인스턴스를 메모리에 보관했다가 onResume() 을 호출할 때 메모리에 머물고 있던 인스턴스를 호출합니다.​onStop()액티비티가 사용자에게 더 이상 표시되지 않으면 onStop() 을 호출합니다. 기존 액티비티에서 다른 액티비티로 완전히 전환되거나 액티비티의 실행이 완료되어 종료되는 시점에 해당 콜백을 호출합니다. 예를 들어서 앱 사용 중에 홈 화면으로 이동하면 액티비티가 포그라운드에서 벗어나 화면에서 사라지므로  onPause() 가 실행된 후에 onStop() 이 호출됩니다.onStop() 에서도 onPause() 와 마찬가지로 앱이 사용자에게 보이지 않는 동안 앱에서 필요하지 않은 리소스를 해제하거나 조정할 수 있습니다. onPause() 에서는 비교적 가벼운 작업을 처리했다면 여기서는 CPU를 비교적 많이 소모하는 종료 작업 실행을 추천합니다. 데이터베이스에 정보를 저장하는 작업 같은 것을 현재 상태일 때 처리할 수도 있습니다.또한 액티비티가 중단 상태에서 재개 상태로 바뀔 때 onPause() 와 마찬가지로 액티비티 객체가 메모리에 머물다가 다시 시작되면 액티비티 객체 정보가 호출됩니다.onStop() 상태에서는 두 가지 경우가 발생할 수 있습니다. 첫 번째는 액티비티를 다시 재개하는 것이고 두 번째는 액티비티를 종료하는 것입니다. 첫 번째 경우는 onRestart() 가 호출되어 다시 재개하는 과정을 거치고 두 번째는 onDestroy() 가 호출됩니다.​onDestroy()액티비티가 소멸되기 전에 호출되는데 해당 콜백이 호출되는 경우는 다음과 같습니다.  사용자가 액티비티를 완전히 닫거나 finish()  를 호출하여 액티비티가 종료되는 경우  기기 회전이나 멀티 윈도우 모드로 인해서 일시적으로 액티비티를 소멸시키는 경우onDestroy() 는 액티비티가 종료된다면 수명 주기에서 마지막으로 수신하는 콜백 메서드가 됩니다. 따라서 이전에 미처 해제하지 못했던 모든 리소스들을 여기서 처리하고 끝내야 합니다.​여러 상황에서 생명주기지금까지 생명주기의 각 콜백들의 역할과 특징들을 알아봤습니다. 이제는 직접 여러 상황들을 구현하여 생명주기가 어떻게 되는지 알아보겠습니다. 실습에 사용되는 액티비티는 총 두 개, 메인 액티비티와 서브 액티비티가 되겠습니다.앱 실행을 하면 시작 액티비티는 메인 액티비티가 되고 메인에는 서브 액티비티로 전환할 수 있는 버튼이 하나 있습니다. 서브 액티비티에는 메인 액티비티로 전환할 수 있는 버튼 하나와 숫자를 카운트할 수 있는 카운트 버튼이 존재합니다. 각 액티비티의 코드는 다음과 같습니다.MainActivity 코드class MainActivity : AppCompatActivity() {    private lateinit var binding: ActivityMainBinding    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        Log.d(\"MainActivity\", \"onCreate\")        binding = ActivityMainBinding.inflate(layoutInflater)        val view = binding.root        setContentView(view)        binding.btnMoveAnotherActivity.setOnClickListener {            startActivity(Intent(this, SubActivity::class.java))            finish()        }    }    override fun onStart() {        super.onStart()        Log.d(\"MainActivity\", \"onStart\")    }    override fun onResume() {        super.onResume()        Log.d(\"MainActivity\", \"onResume\")    }    override fun onPause() {        super.onPause()        Log.d(\"MainActivity\", \"onPause\")    }    override fun onStop() {        super.onStop()        Log.d(\"MainActivity\", \"onStop\")    }    override fun onDestroy() {        super.onDestroy()        Log.d(\"MainActivity\", \"onDestroy\")    }    override fun onRestart() {        super.onRestart()        Log.d(\"MainActivity\", \"onRestart\")    }}​SubActivity 코드class SubActivity : AppCompatActivity() {private lateinit var binding: ActivitySubBindingprivate var counter: Int = 0    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        Log.d(\"SubActivity\", \"onCreate\")        binding = ActivitySubBinding.inflate(layoutInflater)        val view = binding.root        setContentView(view)        binding.tvCounter.text = counter.toString()        binding.btnMoveMainActivity.setOnClickListener {            startActivity(Intent(this, MainActivity::class.java))            finish()        }        binding.btnAddCount.setOnClickListener {            counter += 1            binding.tvCounter.text = counter.toString()            Log.d(\"Counter 증가 요청\", \"${binding.tvCounter.text}\")        }    }    override fun onStart() {        super.onStart()        Log.d(\"SubActivity\", \"onStart\")    }    override fun onResume() {        super.onResume()        Log.d(\"SubActivity\", \"onResume\")    }    override fun onPause() {        super.onPause()        Log.d(\"SubActivity\", \"onPause\")    }    override fun onStop() {        super.onStop()        Log.d(\"SubActivity\", \"onStop\")    }    override fun onDestroy() {        super.onDestroy()        Log.d(\"SubActivity\", \"onDestroy\")    }    override fun onRestart() {        super.onRestart()        Log.d(\"SubActivity\", \"onRestart\")    }}​앱 실행홈 화면에서 앱을 실행합니다.초기 액티비티를 생성하므로 onCreate() 부터 호출이 됩니다.MainActivity onCreateMainActivity onStartMainActivity onResume​액티비티 전환메인 액티비티에서 서브 액티비티로 전환합니다.메인 액티비티의 소멸까지 기다렸다가 서브 액티비티가 생성되는 것이 아닙니다. 메인 액티비티를 일시 중지 시켜놓고 서브 액티비티를 onResume() 까지 진행시킨 다음, 그 뒤에 메인 액티비티를 종료시키는 겁니다. 액티비티의 전환은 이렇게 처리됩니다.  MainActivity의 onPause() 메서드가 실행된다.  SubActivity의 onCreate(), onStart(), onResume() 메서드가 순차적으로 실행된다.  MainActivity는 finish()  호출로 onDestroy() 까지 호출되어 소멸된다.MainActivity onPauseSubActivity onCreateSubActivity onStartSubActivity onResumeMainActivity onStopMainActivity onDestroy​세로 모드에서 가로 모드로 전환메인 액티비티에서 가로 모드로 전환했습니다.위의 콜백 메서드 설명 부분에서도 언급했지만 화면 구성이 변경될 경우(가로 모드로 전환) 시스템은 액티비티를 소멸시키고 다시 생성하여 가로 모드에 대한 구성을 진행합니다.MainActivity onPauseMainActivity onStopMainActivity onDestroyMainActivity onCreateMainActivity onStartMainActivity onResume​가로 모드로 전환될 때 데이터 상태서브 액티비티에서 카운터를 증가시킨 후 가로 모드로 전환했을 때 과연 카운터 데이터는 유지될까요? 유지되지 않습니다. 가로 모드로 전환하면 액티비티가 소멸되고 다시 생성되기 때문에 데이터도 초기화가 됩니다.​홈 화면으로 이동메인 액티비티에서 홈 화면으로 이동을 해봤습니다.액티비티 화면이 포그라운드에서 벗어나 사용자 시야에서 완전히 사라지므로 onStop() 까지 진행됐습니다.MainActivity onPauseMainActivity onStop​홈 화면에서 앱으로 다시 이동이제 다시 홈 화면에서 메인 액티비티로 돌아갑니다.중단 상태에서 액티비티가 재개하므로 onRestart() 를 시작으로 onResume() 까지 호출됩니다.MainActivity onRestartMainActivity onStartMainActivity onResume​앱 종료앱을 완전히 종료시킵니다.앱이 종료됨에 따라서 액티비티도 소멸하므로 onDestroy() 까지 호출되고 액티비티는 소멸합니다.MainActivity onPauseMainActivity onStopMainActivity onDestroy​마치면서…지금까지 생명주기의 뜻부터 예시까지 알아봤습니다. 이 글은 안드로이드 공식 문서를 참고하여 작성했으며 제 나름대로 해석을 하면서 작성한 거라 잘못된 부분이 있을 수도 있습니다. 혹시라도 잘못된 부분이 있어서 알려주신다면 바로 수정하겠습니다. 긴 글 읽어주셔서 감사합니다!​참조Android 공식 문서제이슨의 개발이야기Dev.Cho - Dev World"
  },
  
  {
    "title": "Chirpy 테마를 이용한 Github 블로그 만들기",
    "url": "/posts/Make-Github-blog/",
    "categories": "블로그, Github 블로그 만들기",
    "tags": "Github 블로그",
    "date": "2023-01-14 00:00:00 +0900",
    





    
    "snippet": "시작하기에 앞서 참고해주세요!jekyll의 Chirpy 테마를 기준으로 진행합니다. 현재 이 블로그의 테마가 Chirpy 테마이며 이 블로그의 테마 디자인이 마음에 들어서 해당 테마가 적용된 깃허브 블로그를 만들고 싶다면 이 글을 참고하시면 좋을 것 같습니다.저는 Chirpy 테마를 적용하기 위해서 해당 테마에 대한 여러 블로그 글과 제작자의 가이드를...",
    "content": "시작하기에 앞서 참고해주세요!jekyll의 Chirpy 테마를 기준으로 진행합니다. 현재 이 블로그의 테마가 Chirpy 테마이며 이 블로그의 테마 디자인이 마음에 들어서 해당 테마가 적용된 깃허브 블로그를 만들고 싶다면 이 글을 참고하시면 좋을 것 같습니다.저는 Chirpy 테마를 적용하기 위해서 해당 테마에 대한 여러 블로그 글과 제작자의 가이드를 참고해서 하라는 대로 따라 했는데 중간 과정들의 결과가 블로그의 글과 달라서 당황했던 기억이 있습니다. 아무래도 제작자분이 해당 테마의 적용 방식에 대한 업데이트를 여러 번 진행해서 적용 방법이 이전과 약간 달라진 것 같습니다.그래서 앞으로 Chirpy 테마를 적용하려는 분들에게 적용 방법과  제가 겪었던 문제점들을 공유하고자 합니다. 아마 이 글을 쓰는 와중에도 제가 적용한 방식이 최신이 아닌 이전 방식이 될 수도 있습니다. 이 점을 참고하고 읽어주시면 감사하겠습니다.​사전 준비다음 세 가지를 준비해 주세요. 테마 적용 과정과 에러 해결에 중점을 두기 때문에 다음 세 가지에 대한 자세한 설명은 생략하겠습니다.  구글에 자세하게 정리된 글이 많으므로 검색해서 참고하시길 바랍니다.      Git, Github        Ruby 를 설치해 주세요. 제가 사용하고 있는 루비 버전은 3.1.3p  입니다. 설치가 완료되면 다음 명령과 같이 루비 버전이 출력되는지 확인해 주세요.  Ruby -vruby 3.1.3p185 (2022-11-24 revision 1a6b16756e) [x86_64-darwin22]  jekyll을 설치해 주세요.gem install jekyll bundler​Github에서 저장소 생성하기모든 준비가 끝났다면 블로그 운영에 필요한 파일들을 저장할 저장소부터 생성합니다. 다음과 같이 본인의 깃허브 네임과 그 뒤에  github.io 을 붙여서 저장소 이름을 만들어주세요. 공개 범위는 public으로 설정합니다.저는 이미 블로그를 위한 저장소가 존재하므로 다음과 같이 이미 해당 이름의 저장소가 존재한다고 메시지가 나옵니다.​테마 파일들 가져오기포크 방식과 압축파일을 다운로드하는 방법이 있는데 저는 두 번째 방법인 압축파일 다운로드 방식을 기준으로 설명하겠습니다.두 가지 방법  테마 저장소 를  fork 해서 fork한 저장소 이름을 {본인의 깃허브 네임}.github.io로 변경해서 사용          포크 한 저장소를 git clone을 통해서 연결한다.        테마 저장소 Download zip을 통해서 가져오기          저장소를 직접 만들고 git clone으로 연결한 후에 다운로드한 폴더를 저장소와 연결된 로컬 폴더에 넣는다.      ​zip 다운로드​테마 파일 초기화현재 다운로드한 테마 파일들은 완전히 초기의 상태가 아니라 제작자에 의해서 계속해서 업데이트가 된 상태입니다. 따라서 본인만의 블로그를 세팅하려면 초기 상태로 만들어줘야 합니다. 초기화 코드는 다음과 같습니다. 해당 코드는 제작자의 시작 가이드에서 가져왔습니다.bash tools/init​그런데 문제가….테마 파일을 다운로드하면 그중에 tools  라는 이름의 폴더가 있는데 그 안에 init 이 존재합니다. 이 init 을 이용해서 초기화를 진행시키는 것입니다. 그런데 저는 아무리 시도해 봐도 tools 디렉터리가 인식이 안되는 건지 초기화가 안됐습니다. 폴더가 존재하는데 디렉터리가 없다고 계속 오류가 발생해서 결국 터미널을 통한 초기화를 할 수 없었습니다. 혹시라도 이유를 아시는 분은 알려주시면 감사하겠습니다…  bash 사용이 제한이 되거나 저처럼 초기화가 안되는 경우에는 직접 테마 폴더를 건드려서 초기화를 하면 됩니다.​직접 초기화?직접 초기화는 다운로드한 테마 폴더 내의 파일 혹은 폴더들을 수정하거나 삭제하는 방식입니다. 다른 블로그들의 글에서 삭제하라는 파일 혹은 폴더가 현재 다운로드한 폴더 내에 없을 수 있습니다. 아마 이 부분도 제작자가 업데이트하면서 일부는 없앤 것 같습니다. 그래서 있는 것들만 수정하거나 삭제하시면 됩니다.  테마 폴더 내 숨겨진 파일들도 수정 및 삭제하므로 초기화 전에 숨김 파일 표시를 해주세요.​수정 및 삭제 목록  .github 폴더 내에 workflows 폴더를 제외하고 모두 삭제  github/workflows 내에 commitlint.yml 과 page-deploy.yml.hook 제외하고 모두 삭제  page-deploy.yml.hook 파일의 .hook 부분을 없애서 page-deploy.yml 로 수정      _config.yml 에서 url: '' 부분에 본인의 깃허브 블로그 주소 넣기    .github/workflows/page-deploy.yml 에서 루비 버전을 로컬 버전이랑 맞춰주세요. jobs:  내의  build: 부분을 찾아보면 밑의 코드처럼 루비 설정에 관한 부분을 찾을 수 있습니다. 제가 사용하는 루비 버전은 3.1.3 이므로 ruby-version: \"\"  에 3.1.3  를 적었습니다.jobs:  build:      - name: Setup Ruby        uses: ruby/setup-ruby@v1        with:          ruby-version: \"3.1.3\" # reads from a '.ruby-version' or '.tools-version' file if 'ruby-version' is omitted          bundler-cache: true  .github/workflows/page-deploy.yml 에서 설정된 브랜치를 확인해 주세요. 2번 라인에 밑의 코드를 확인할 수 있습니다. 연결된 저장소에 저 둘 중에 해당되는 브랜치가 있으면 됩니다. 제 저장소는 main 브랜치를 사용했습니다.on:  push:    branches:      - main      - master    paths-ignore:      - .gitignore      - README.md      - LICENSE  page-deploy.yml 에 등록된 브랜치와 루비 정보를 토대로 build가 진행됩니다.​깃허브 저장소에 PUSH그 전에 로컬 주소로 테스트 해보기bundle exec jekyll serveServer address: http://127.0.0.1:4000/깃허브에 올리기 전에 위의 첫 번째 명령을 실행했다면 두 번째의 로컬 주소를 얻을 수 있습니다.  해당 주소로 이동해서 블로그 상태를 체크해 보세요. 아마 _posts 폴더에 있던 가이드 파일들을 그대로 뒀다면 블로그 글 목록에 가이드 글들이 나타날 것이고, 전부 삭제를 했다면 블로그 글이 하나도 없는 깨끗한 상태일 것입니다.저는 나중에 글 쓰면서 가이드를 참고하기 위해서 완전히 삭제하지 않고 따로 바탕화면에 옮겼습니다. 가이드 글은 제작자의 데모 사이트에도 있으니 그냥 삭제하셔도 됩니다.​Github Actions이제 커밋을 하고 푸시를 하면 저장소 상단 탭에 있는 Actions 에서 블로그 빌드가 진행됩니다. 빌드는 완료되는 데 약간 시간이 걸립니다. 빌드가 정상적으로 끝났다면 이제 본인의 깃허브 블로그 주소에 접속해 보세요. 테마가 적용된 모습을 볼 수 있습니다.하지만 저는 여기서 오류가 발생했었는데 루비와 관련된 에러였습니다. .github/workflows/page-deploy.yml 에서 분명 루비 버전도  3.1.3 으로 맞췄는데 이런 오류가 뜨니 당황스러웠습니다.Error: The process '/opt/hostedtoolcache/Ruby/3.1.3/x64/bin/bundle' failed with exit code 16해당 문제에 대해서 구글링을 한 결과,  스택 오버플로우의 도움을 받아서 다음 코드를 통해 해결할 수 있었습니다. 저와 같은 오류가 발생했다면 해당 글을 참고해 보시면 좋을 것 같습니다.bundle lock --add-platform x86_64-linux​해치웠나?해당 오류는 다행히 해결이 돼서 정상적으로 빌드가 됐습니다. 이제 블로그를 작성할 모든 준비가 됐습니다. 이제 _posts 내에 마크다운 파일을 만들어서 글을 적고 깃허브에 올리는 과정을 반복하여 블로그 글을 채워나가면 됩니다.​참조테마 적용 과정      제작자의 데모 사이트    하얀눈길님 블로그  Jaewoo님 블로그  Ju-ing님 블로그오류 참고  hashnsalt님 블로그"
  }
  
]

