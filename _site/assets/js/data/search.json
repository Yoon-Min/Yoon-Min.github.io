[
  
  {
    "title": "Union-Find 유니온 파인드",
    "url": "/posts/Uinon-Find/",
    "categories": "CS, 알고리즘",
    "tags": "자료구조, 유니온 파인드",
    "date": "2023-02-17 12:00:00 +0900",
    





    
    "snippet": "서로소 집합(disjoint-set)을 관리하는 자료 구조다양한 원소들이 서로소 집합을 이루는 경우가 있습니다. 필요에 따라서 이 집합들을 이용하여 서로 합치거나 특정 원소를 통해 특정 집합을 탐색할 수도 있습니다. 유니온 파인드(union-find)는 그래프 알고리즘으로 서로소 집합을 관리하며 서로 다른 두 노드가 동일한 집합에 있는지 판별합니다.유...",
    "content": "서로소 집합(disjoint-set)을 관리하는 자료 구조다양한 원소들이 서로소 집합을 이루는 경우가 있습니다. 필요에 따라서 이 집합들을 이용하여 서로 합치거나 특정 원소를 통해 특정 집합을 탐색할 수도 있습니다. 유니온 파인드(union-find)는 그래프 알고리즘으로 서로소 집합을 관리하며 서로 다른 두 노드가 동일한 집합에 있는지 판별합니다.유니온 파인드는 서로 다른 두 노드가 같은 집합에 있는지 판별하기 위해서 각 집합의 대표 원소를 참고합니다. 여기서 대표 원소라 함은 연결 리스트에서는 헤드가 되며 트리에서는 루트 노드가 해당됩니다. 두 노드가 속한 집합의 대표 원소를 찾아서 대표 원소가 서로 동일하면 같은 집합에 있는 걸로 판단하게 됩니다. 이러한 판단 과정에서 여러 집합들이 합쳐지거나(Union) 특정 원소가 속한 대표 원소를 찾기 위해 집합 탐색(Find) 을 진행하기도 합니다. 그래서 유니온 파인드에서는 다음과 같은 연산들이 존재합니다.​연산의 종류            연산      특징                  MakeSet      특정 한 원소만 존재하는 집합을 만든다.              Union      두 개의 집합을 하나의 집합으로 합친다.              Find      특정 원소에가 속한 집합의 대표 원소를 반환한다.      ​구현과 관리를 위해 사용되는 방법유니온 파인드를 관리하는 방식은 두 가지가 있습니다. 첫 번째는 연결 리스트를 통한 관리고 두 번째는 트리 구조를 이용한 관리입니다. 각 방식들이 유니온 파인드의 연산을 어떻게 처리하는지 알아보도록 합시다. 연결 리스트부터 살펴보겠습니다.​연결 리스트를 통한 관리MakeSet원소는 1부터 8까지 8개가 있다고 가정하겠습니다. 여기서 헤드는 해당 집합의 대표 원소가 됩니다. 현재는 원소 하나만 가지고 리스트를 만들었으므로 자기 자신이 대표 원소가 됩니다.​Union두 리스트를 붙이는 연산을 수행합니다. 한 리스트의 헤드 부분이 다른 리스트의 꼬리(Tail) 부분을 가리키는 방식으로 연결합니다.   예시에서는 Y에 해당되는 리스트의 헤드가 X 리스트의 꼬리에 연결됩니다.​Find만약 원소 4가 속한 집합의 대표 원소를 찾고자 한다면 해당 리스트의 헤드까지 쭉 탐색을 합니다. 해당 예시처럼 특정 집합의 대표 원소를 찾을 때 운 안 좋게 꼬리 부분의 원소를 지목하게 되면 연결 리스트의 모든 원소를 탐색하게 됩니다."
  },
  
  {
    "title": "Android 액티비티 생명주기",
    "url": "/posts/android-lifecycle/",
    "categories": "Android, 기본",
    "tags": "Android, 모바일, 안드로이드, 생명주기, 개발",
    "date": "2023-02-14 00:00:00 +0900",
    





    
    "snippet": "생명주기가 무엇인가?1. 소프트웨어 개발 계획의 시작부터 끝까지 따라야 할 단계와 그것에 따른 계획의 형태 변화.2. 소프트웨어가 만들어져서 폐기될 때까지의 기간.    사용자의 요구에 대한 분석 및 설계, 그리고 프로그램 작성을 거쳐 운용되는 일련의 과정을 포함한다.네이버 국어사전에서 말하는 생명 주기는 다음과 같습니다. 즉, 액티비티가 만들어지고 ...",
    "content": "생명주기가 무엇인가?1. 소프트웨어 개발 계획의 시작부터 끝까지 따라야 할 단계와 그것에 따른 계획의 형태 변화.2. 소프트웨어가 만들어져서 폐기될 때까지의 기간.    사용자의 요구에 대한 분석 및 설계, 그리고 프로그램 작성을 거쳐 운용되는 일련의 과정을 포함한다.네이버 국어사전에서 말하는 생명 주기는 다음과 같습니다. 즉, 액티비티가 만들어지고 없어질 때까지의 과정을 말합니다. 어떤 생명이 탄생해서 죽을 때까지의 과정이 존재하듯  안드로이드의 액티비티도 생성되어 소멸하기까지의 과정을 가지고 있습니다.​생명주기는 왜 있는가?그렇다면 이쯤에서 드는 생각이 있을 겁니다. 그러면 생명주기는 왜 있는 것인가? 이 질문에 대한 해답은 모바일 사용 환경을 생각해 보면 됩니다. 다음과 같은 경우를 생각해 봅시다.  사용자가 앱을 사용하는 도중에 전화가 왔을 때  사용자가 앱에서 나갔다가 돌아왔을 때 이전의 데이터들이 저장되지 않는 문제  세로 모드로 사용하다가 가로로 돌려서 가로 모드로 전환  앱을 사용하는 도중에 홈 화면으로 이동 후, 다른 앱을 실행시킬 때네 가지 경우를 보면 모바일 사용자 환경에서는 많은 상태 변화가 발생한다는 것을 알 수 있습니다. 아마 사용자 입장에서는 위의 상황들이 발생해도 아무런 오류가 없이 매끄럽게 앱이 작동되길 바랄 겁니다.앱이 아무런 오류 없이 매끄럽게 동작하려면 어떻게 해야 할까요? 바로 다양한 상태 변화가 발생했을 때 상태에 따라 알맞은 작업을 하고 적절한 전환을 처리해야 할 것입니다. 그래서 현재 앱이 어떤 상태에 있는지를 계속 파악하는 것이 중요하고 이를 파악하기 위해서 생명주기가 있는 것입니다.​Android의 생명주기생명주기의 시작은 탄생이고 끝은 죽음입니다. 그리고 그 사이에는 다양한 상태들이 존재합니다. 탄생 후에 본격적으로 활동을 위한 준비단계가 있을 것이며 많은 활동 끝에 죽음을 준비하기 위한 단계도 있을 것입니다.안드로이드에서 정의한 액티비티의 생명주기 단계들은 시작과 실행 사이에  onCreate(),  onStart(),  onResume()  순서로 있고 실행과 종료 사이에  onPause(), onStop(), onDestroy() 순으로 여러 상태들이 존재합니다. 따라서 사용자가 앱을 이용하면 그 과정에서 여러 가지의 상태 변화가 발생하는데 이는 생명주기에 따라 적절히 처리됩니다.​생명주기 처리를 위한 콜백 메서드상황에 따라 적절한 처리를 해주려면 생명주기 내에서 해당 상황에 맞는 특정 상태를 알 수 있어야 합니다. 어떤 상태인지를 알아야 그에 맞는 처리를 해줄 수 있으니까요. 안드로이드는 이를 위해 생명주기 내의 다양한 단계들을 콜백 형태로 제공합니다.액티비티 클래스는 onCreate(),  onStart(), onResume() , onPause(), onStop(),onDestroy() 함수들을 상속받습니다. 상속을 받고 이 함수들을 필요에 따라 재정의 하여 특정 상황의 발생으로 인해서 호출이 됐을 때 재정의 한 내용을 토대로 처리를 하게 됩니다. 예를 들어서 가로 모드로 전환을 했을 때는 화면의 구성이 바뀌므로 수명주기의 상태는 onCreate() 에 해당이 되어 시스템에서 onCreate() 콜백을 호출합니다.  이렇게 각 콜백은 상태 변화에 적합한 특정 작업을 실행할 수 있도록 하고 적시에 알맞은 작업과 적절한 전환을 통해 앱이 더욱 안정적으로 기능할 수 있도록 해줍니다.​콜백 메서드 소개지금까지 생명주기가 왜 존재하고 어떻게 처리하는지 알아봤습니다. 콜백 호출을 통해서 상태 변화에 대응한다는 것을 알았으므로 이제는 각 콜백 메서드의 역할과 특징에 대해 알아보겠습니다.onCreate()시스템이 액티비티를 생성할 때 실행되고 필수적으로 구현해야 하는 콜백 메서드입니다. onCreate() 메서드에서는 액티비티의 전체 수명 주기 동안 한 번만 발생해야 하는 기본 애플리케이션 시작 로직을 실행합니다. 예를 들어 데이터 바인딩, ViewModel 연결, 클래스 인스턴스화 등을 onCreate() 에서 처리한다고 보면 되겠습니다. 대표적으로 레이아웃 XML을 액티비티로 불러올 때 setContentView() 함수를 onCreate() 에서 호출합니다.onCreate() 메서드는 savedInstanceState 를 매개변수로 받는데 이는 Bundle 객체입니다. savedInstanceState 는 액티비티의 이전 상태 정보들을 가지고 있습니다. 액티비티가 어떤 이유로 화면을 재구성하게 된다면 기존에 존재하던 값들이 초기화되는 것을 방지할 필요가 있을 수도 있습니다. 그래서 따로 저장을 해두면 나중에 액티비티가 다시 생성될 때 savedInstanceState 를 이용하여 저장했던 값들을 불러올 수 있습니다.마지막으로 onCreate() 가 호출이 완료되면 시스템은 거기서 멈추지 않고 뒤이어 onStart() 와  onResume() 콜백 메서드를 호출합니다.override fun onCreate(savedInstanceState: Bundle?) {    super.onCreate(savedInstanceState)    binding = ActivityMainBinding.inflate(layoutInflater)    val view = binding.root    setContentView(view)}​onStart()액티비티가 사용자에게 표시되고 앱은 액티비티를 포그라운드에 보내서 상호작용을 준비합니다. 액티비티는 사용자에게 표시되지만 아직은 상호작용을 할 수 없는 단계입니다. 상호작용 준비를 위해서 이 단계에서 UI를 관리하는 코드를 초기화합니다.onStart() 는 매우 빠르게 완료되고 onCreate() 때와 마찬가지로 시스템은 여기서 머무르지 않고  onResume()  콜백 메서드를 호출하게 됩니다.​onResume()액티비티가 포그라운드에 표시되고 사용자와 상호작용을 시작합니다. 중간에 전화가 와서 포커스가 전화 알람으로 이동하거나 다른 액티비티로 화면 전환을 하여 포커스가 이동한 액티비티로 전환되거나 기기 화면이 꺼져서 포커스를 잃는 등의 현재 액티비티에 대한 포커스 소실이 발생하면 앱은  onResume() 에서 벗어나고 그렇지 않다면 onResume()  상태에서 머물게 됩니다.만약 현재 상태에서 방해 이벤트가 발생한다면 액티비티는 일시 중지 상태를 의미하는 onPause() 콜백 메서드를 호출해서 상태 변화를 합니다. 일시 중지 상태에서 다시 액티비티로 돌아온다면 시스템은 다시  onResume() 를 호출합니다.​onPause()사용자가 액티비티를 떠날 때 첫 번째로 호출되는 콜백 메서드입니다.  액티비티가 포그라운드에서 벗어나는 경우 일시중지 상태로 전환됩니다. 이 일시 중지는 onPasue() 를 의미합니다. onPause() 가 호출되는 경우는 onResume() 에서 설명한 예시들에 해당됩니다.액티비티가 포그라운드에 있지 않다면 일시 중지 상태가 되어 원래 사용됐던 기능들을 실행할 필요가 없어지게 됩니다. 그래서 이때는 필요에 따라 onPause() 메서드를 이용하여 시스템 리소스, GPS, 배터리 수명에 영향을 미칠 수 있는 리소스들을 해제할 수도 있습니다.하지만 주의할 점이 있습니다.  onPause() 는 잠깐동안 실행되므로 시간이 길어질 수 있는 애플리케이션 또는 사용자 데이터 저장, 네트워크 호출, 데이터베이스 트랜잭션 등의 작업은 onPause() 가 끝난 후에도 완료가 안될 수도 있습니다. 그래서 공식 문서에서는 이러한 작업들은 onPause() 에서 하지 말고 onStop() 상태일 때 처리하라고 추천합니다.액티비티가 다시 포그라운드에 복귀하면 시스템은 다시 onResume() 을 호출하게 됩니다. 일시 중지 상태에서 재개 상태로 돌아오면 그 과정에서 시스템은 액티비티의 인스턴스를 메모리에 보관했다가 onResume() 을 호출할 때 메모리에 머물고 있던 인스턴스를 호출합니다.​onStop()액티비티가 사용자에게 더 이상 표시되지 않으면 onStop() 을 호출합니다. 기존 액티비티에서 다른 액티비티로 완전히 전환되거나 액티비티의 실행이 완료되어 종료되는 시점에 해당 콜백을 호출합니다. 예를 들어서 앱 사용 중에 홈 화면으로 이동하면 액티비티가 포그라운드에서 벗어나 화면에서 사라지므로  onPause() 가 실행된 후에 onStop() 이 호출됩니다.onStop() 에서도 onPause() 와 마찬가지로 앱이 사용자에게 보이지 않는 동안 앱에서 필요하지 않은 리소스를 해제하거나 조정할 수 있습니다. onPause() 에서는 비교적 가벼운 작업을 처리했다면 여기서는 CPU를 비교적 많이 소모하는 종료 작업 실행을 추천합니다. 데이터베이스에 정보를 저장하는 작업 같은 것을 현재 상태일 때 처리할 수도 있습니다.또한 액티비티가 중단 상태에서 재개 상태로 바뀔 때 onPause() 와 마찬가지로 액티비티 객체가 메모리에 머물다가 다시 시작되면 액티비티 객체 정보가 호출됩니다.onStop() 상태에서는 두 가지 경우가 발생할 수 있습니다. 첫 번째는 액티비티를 다시 재개하는 것이고 두 번째는 액티비티를 종료하는 것입니다. 첫 번째 경우는 onRestart() 가 호출되어 다시 재개하는 과정을 거치고 두 번째는 onDestroy() 가 호출됩니다.​onDestroy()액티비티가 소멸되기 전에 호출되는데 해당 콜백이 호출되는 경우는 다음과 같습니다.  사용자가 액티비티를 완전히 닫거나 finish()  를 호출하여 액티비티가 종료되는 경우  기기 회전이나 멀티 윈도우 모드로 인해서 일시적으로 액티비티를 소멸시키는 경우onDestroy() 는 액티비티가 종료된다면 수명 주기에서 마지막으로 수신하는 콜백 메서드가 됩니다. 따라서 이전에 미처 해제하지 못했던 모든 리소스들을 여기서 처리하고 끝내야 합니다.​여러 상황에서 생명주기지금까지 생명주기의 각 콜백들의 역할과 특징들을 알아봤습니다. 이제는 직접 여러 상황들을 구현하여 생명주기가 어떻게 되는지 알아보겠습니다. 실습에 사용되는 액티비티는 총 두 개, 메인 액티비티와 서브 액티비티가 되겠습니다.앱 실행을 하면 시작 액티비티는 메인 액티비티가 되고 메인에는 서브 액티비티로 전환할 수 있는 버튼이 하나 있습니다. 서브 액티비티에는 메인 액티비티로 전환할 수 있는 버튼 하나와 숫자를 카운트할 수 있는 카운트 버튼이 존재합니다. 각 액티비티의 코드는 다음과 같습니다.MainActivity 코드class MainActivity : AppCompatActivity() {    private lateinit var binding: ActivityMainBinding    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        Log.d(\"MainActivity\", \"onCreate\")        binding = ActivityMainBinding.inflate(layoutInflater)        val view = binding.root        setContentView(view)        binding.btnMoveAnotherActivity.setOnClickListener {            startActivity(Intent(this, SubActivity::class.java))            finish()        }    }    override fun onStart() {        super.onStart()        Log.d(\"MainActivity\", \"onStart\")    }    override fun onResume() {        super.onResume()        Log.d(\"MainActivity\", \"onResume\")    }    override fun onPause() {        super.onPause()        Log.d(\"MainActivity\", \"onPause\")    }    override fun onStop() {        super.onStop()        Log.d(\"MainActivity\", \"onStop\")    }    override fun onDestroy() {        super.onDestroy()        Log.d(\"MainActivity\", \"onDestroy\")    }    override fun onRestart() {        super.onRestart()        Log.d(\"MainActivity\", \"onRestart\")    }}​SubActivity 코드class SubActivity : AppCompatActivity() {private lateinit var binding: ActivitySubBindingprivate var counter: Int = 0    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        Log.d(\"SubActivity\", \"onCreate\")        binding = ActivitySubBinding.inflate(layoutInflater)        val view = binding.root        setContentView(view)        binding.tvCounter.text = counter.toString()        binding.btnMoveMainActivity.setOnClickListener {            startActivity(Intent(this, MainActivity::class.java))            finish()        }        binding.btnAddCount.setOnClickListener {            counter += 1            binding.tvCounter.text = counter.toString()            Log.d(\"Counter 증가 요청\", \"${binding.tvCounter.text}\")        }    }    override fun onStart() {        super.onStart()        Log.d(\"SubActivity\", \"onStart\")    }    override fun onResume() {        super.onResume()        Log.d(\"SubActivity\", \"onResume\")    }    override fun onPause() {        super.onPause()        Log.d(\"SubActivity\", \"onPause\")    }    override fun onStop() {        super.onStop()        Log.d(\"SubActivity\", \"onStop\")    }    override fun onDestroy() {        super.onDestroy()        Log.d(\"SubActivity\", \"onDestroy\")    }    override fun onRestart() {        super.onRestart()        Log.d(\"SubActivity\", \"onRestart\")    }}​앱 실행홈 화면에서 앱을 실행합니다.초기 액티비티를 생성하므로 onCreate() 부터 호출이 됩니다.MainActivity onCreateMainActivity onStartMainActivity onResume​액티비티 전환메인 액티비티에서 서브 액티비티로 전환합니다.메인 액티비티의 소멸까지 기다렸다가 서브 액티비티가 생성되는 것이 아닙니다. 메인 액티비티를 일시 중지 시켜놓고 서브 액티비티를 onResume() 까지 진행시킨 다음, 그 뒤에 메인 액티비티를 종료시키는 겁니다. 액티비티의 전환은 이렇게 처리됩니다.  MainActivity의 onPause() 메서드가 실행된다.  SubActivity의 onCreate(), onStart(), onResume() 메서드가 순차적으로 실행된다.  MainActivity는 finish()  호출로 onDestroy() 까지 호출되어 소멸된다.MainActivity onPauseSubActivity onCreateSubActivity onStartSubActivity onResumeMainActivity onStopMainActivity onDestroy​세로 모드에서 가로 모드로 전환메인 액티비티에서 가로 모드로 전환했습니다.위의 콜백 메서드 설명 부분에서도 언급했지만 화면 구성이 변경될 경우(가로 모드로 전환) 시스템은 액티비티를 소멸시키고 다시 생성하여 가로 모드에 대한 구성을 진행합니다.MainActivity onPauseMainActivity onStopMainActivity onDestroyMainActivity onCreateMainActivity onStartMainActivity onResume​가로 모드로 전환될 때 데이터 상태서브 액티비티에서 카운터를 증가시킨 후 가로 모드로 전환했을 때 과연 카운터 데이터는 유지될까요? 유지되지 않습니다. 가로 모드로 전환하면 액티비티가 소멸되고 다시 생성되기 때문에 데이터도 초기화가 됩니다.​홈 화면으로 이동메인 액티비티에서 홈 화면으로 이동을 해봤습니다.액티비티 화면이 포그라운드에서 벗어나 사용자 시야에서 완전히 사라지므로 onStop() 까지 진행됐습니다.MainActivity onPauseMainActivity onStop​홈 화면에서 앱으로 다시 이동이제 다시 홈 화면에서 메인 액티비티로 돌아갑니다.중단 상태에서 액티비티가 재개하므로 onRestart() 를 시작으로 onResume() 까지 호출됩니다.MainActivity onRestartMainActivity onStartMainActivity onResume​앱 종료앱을 완전히 종료시킵니다.앱이 종료됨에 따라서 액티비티도 소멸하므로 onDestroy() 까지 호출되고 액티비티는 소멸합니다.MainActivity onPauseMainActivity onStopMainActivity onDestroy​마치면서…지금까지 생명주기의 뜻부터 예시까지 알아봤습니다. 이 글은 안드로이드 공식 문서를 참고하여 작성했으며 제 나름대로 해석을 하면서 작성한 거라 잘못된 부분이 있을 수도 있습니다. 혹시라도 잘못된 부분이 있어서 알려주신다면 바로 수정하겠습니다. 긴 글 읽어주셔서 감사합니다!​참조Android 공식 문서제이슨의 개발이야기Dev.Cho - Dev World"
  },
  
  {
    "title": "Chirpy 테마를 이용한 Github 블로그 만들기",
    "url": "/posts/Make-Github-blog/",
    "categories": "블로그, Github 블로그 만들기",
    "tags": "Github 블로그",
    "date": "2023-01-14 00:00:00 +0900",
    





    
    "snippet": "시작하기에 앞서 참고해주세요!jekyll의 Chirpy 테마를 기준으로 진행합니다. 현재 이 블로그의 테마가 Chirpy 테마이며 이 블로그의 테마 디자인이 마음에 들어서 해당 테마가 적용된 깃허브 블로그를 만들고 싶다면 이 글을 참고하시면 좋을 것 같습니다.저는 Chirpy 테마를 적용하기 위해서 해당 테마에 대한 여러 블로그 글과 제작자의 가이드를...",
    "content": "시작하기에 앞서 참고해주세요!jekyll의 Chirpy 테마를 기준으로 진행합니다. 현재 이 블로그의 테마가 Chirpy 테마이며 이 블로그의 테마 디자인이 마음에 들어서 해당 테마가 적용된 깃허브 블로그를 만들고 싶다면 이 글을 참고하시면 좋을 것 같습니다.저는 Chirpy 테마를 적용하기 위해서 해당 테마에 대한 여러 블로그 글과 제작자의 가이드를 참고해서 하라는 대로 따라 했는데 중간 과정들의 결과가 블로그의 글과 달라서 당황했던 기억이 있습니다. 아무래도 제작자분이 해당 테마의 적용 방식에 대한 업데이트를 여러 번 진행해서 적용 방법이 이전과 약간 달라진 것 같습니다.그래서 앞으로 Chirpy 테마를 적용하려는 분들에게 적용 방법과  제가 겪었던 문제점들을 공유하고자 합니다. 아마 이 글을 쓰는 와중에도 제가 적용한 방식이 최신이 아닌 이전 방식이 될 수도 있습니다. 이 점을 참고하고 읽어주시면 감사하겠습니다.​사전 준비다음 세 가지를 준비해 주세요. 테마 적용 과정과 에러 해결에 중점을 두기 때문에 다음 세 가지에 대한 자세한 설명은 생략하겠습니다.  구글에 자세하게 정리된 글이 많으므로 검색해서 참고하시길 바랍니다.      Git, Github        Ruby 를 설치해 주세요. 제가 사용하고 있는 루비 버전은 3.1.3p  입니다. 설치가 완료되면 다음 명령과 같이 루비 버전이 출력되는지 확인해 주세요.  Ruby -vruby 3.1.3p185 (2022-11-24 revision 1a6b16756e) [x86_64-darwin22]  jekyll을 설치해 주세요.gem install jekyll bundler​Github에서 저장소 생성하기모든 준비가 끝났다면 블로그 운영에 필요한 파일들을 저장할 저장소부터 생성합니다. 다음과 같이 본인의 깃허브 네임과 그 뒤에  github.io 을 붙여서 저장소 이름을 만들어주세요. 공개 범위는 public으로 설정합니다.저는 이미 블로그를 위한 저장소가 존재하므로 다음과 같이 이미 해당 이름의 저장소가 존재한다고 메시지가 나옵니다.​테마 파일들 가져오기포크 방식과 압축파일을 다운로드하는 방법이 있는데 저는 두 번째 방법인 압축파일 다운로드 방식을 기준으로 설명하겠습니다.두 가지 방법  테마 저장소 를  fork 해서 fork한 저장소 이름을 {본인의 깃허브 네임}.github.io로 변경해서 사용          포크 한 저장소를 git clone을 통해서 연결한다.        테마 저장소 Download zip을 통해서 가져오기          저장소를 직접 만들고 git clone으로 연결한 후에 다운로드한 폴더를 저장소와 연결된 로컬 폴더에 넣는다.      ​zip 다운로드​테마 파일 초기화현재 다운로드한 테마 파일들은 완전히 초기의 상태가 아니라 제작자에 의해서 계속해서 업데이트가 된 상태입니다. 따라서 본인만의 블로그를 세팅하려면 초기 상태로 만들어줘야 합니다. 초기화 코드는 다음과 같습니다. 해당 코드는 제작자의 시작 가이드에서 가져왔습니다.bash tools/init​그런데 문제가….테마 파일을 다운로드하면 그중에 tools  라는 이름의 폴더가 있는데 그 안에 init 이 존재합니다. 이 init 을 이용해서 초기화를 진행시키는 것입니다. 그런데 저는 아무리 시도해 봐도 tools 디렉터리가 인식이 안되는 건지 초기화가 안됐습니다. 폴더가 존재하는데 디렉터리가 없다고 계속 오류가 발생해서 결국 터미널을 통한 초기화를 할 수 없었습니다. 혹시라도 이유를 아시는 분은 알려주시면 감사하겠습니다…  bash 사용이 제한이 되거나 저처럼 초기화가 안되는 경우에는 직접 테마 폴더를 건드려서 초기화를 하면 됩니다.​직접 초기화?직접 초기화는 다운로드한 테마 폴더 내의 파일 혹은 폴더들을 수정하거나 삭제하는 방식입니다. 다른 블로그들의 글에서 삭제하라는 파일 혹은 폴더가 현재 다운로드한 폴더 내에 없을 수 있습니다. 아마 이 부분도 제작자가 업데이트하면서 일부는 없앤 것 같습니다. 그래서 있는 것들만 수정하거나 삭제하시면 됩니다.  테마 폴더 내 숨겨진 파일들도 수정 및 삭제하므로 초기화 전에 숨김 파일 표시를 해주세요.​수정 및 삭제 목록  .github 폴더 내에 workflows 폴더를 제외하고 모두 삭제  github/workflows 내에 commitlint.yml 과 page-deploy.yml.hook 제외하고 모두 삭제  page-deploy.yml.hook 파일의 .hook 부분을 없애서 page-deploy.yml 로 수정      _config.yml 에서 url: '' 부분에 본인의 깃허브 블로그 주소 넣기    .github/workflows/page-deploy.yml 에서 루비 버전을 로컬 버전이랑 맞춰주세요. jobs:  내의  build: 부분을 찾아보면 밑의 코드처럼 루비 설정에 관한 부분을 찾을 수 있습니다. 제가 사용하는 루비 버전은 3.1.3 이므로 ruby-version: \"\"  에 3.1.3  를 적었습니다.jobs:  build:      - name: Setup Ruby        uses: ruby/setup-ruby@v1        with:          ruby-version: \"3.1.3\" # reads from a '.ruby-version' or '.tools-version' file if 'ruby-version' is omitted          bundler-cache: true  .github/workflows/page-deploy.yml 에서 설정된 브랜치를 확인해 주세요. 2번 라인에 밑의 코드를 확인할 수 있습니다. 연결된 저장소에 저 둘 중에 해당되는 브랜치가 있으면 됩니다. 제 저장소는 main 브랜치를 사용했습니다.on:  push:    branches:      - main      - master    paths-ignore:      - .gitignore      - README.md      - LICENSE  page-deploy.yml 에 등록된 브랜치와 루비 정보를 토대로 build가 진행됩니다.​깃허브 저장소에 PUSH그 전에 로컬 주소로 테스트 해보기bundle exec jekyll serveServer address: http://127.0.0.1:4000/깃허브에 올리기 전에 위의 첫 번째 명령을 실행했다면 두 번째의 로컬 주소를 얻을 수 있습니다.  해당 주소로 이동해서 블로그 상태를 체크해 보세요. 아마 _posts 폴더에 있던 가이드 파일들을 그대로 뒀다면 블로그 글 목록에 가이드 글들이 나타날 것이고, 전부 삭제를 했다면 블로그 글이 하나도 없는 깨끗한 상태일 것입니다.저는 나중에 글 쓰면서 가이드를 참고하기 위해서 완전히 삭제하지 않고 따로 바탕화면에 옮겼습니다. 가이드 글은 제작자의 데모 사이트에도 있으니 그냥 삭제하셔도 됩니다.​Github Actions이제 커밋을 하고 푸시를 하면 저장소 상단 탭에 있는 Actions 에서 블로그 빌드가 진행됩니다. 빌드는 완료되는 데 약간 시간이 걸립니다. 빌드가 정상적으로 끝났다면 이제 본인의 깃허브 블로그 주소에 접속해 보세요. 테마가 적용된 모습을 볼 수 있습니다.하지만 저는 여기서 오류가 발생했었는데 루비와 관련된 에러였습니다. .github/workflows/page-deploy.yml 에서 분명 루비 버전도  3.1.3 으로 맞췄는데 이런 오류가 뜨니 당황스러웠습니다.Error: The process '/opt/hostedtoolcache/Ruby/3.1.3/x64/bin/bundle' failed with exit code 16해당 문제에 대해서 구글링을 한 결과,  스택 오버플로우의 도움을 받아서 다음 코드를 통해 해결할 수 있었습니다. 저와 같은 오류가 발생했다면 해당 글을 참고해 보시면 좋을 것 같습니다.bundle lock --add-platform x86_64-linux​해치웠나?해당 오류는 다행히 해결이 돼서 정상적으로 빌드가 됐습니다. 이제 블로그를 작성할 모든 준비가 됐습니다. 이제 _posts 내에 마크다운 파일을 만들어서 글을 적고 깃허브에 올리는 과정을 반복하여 블로그 글을 채워나가면 됩니다.​참조테마 적용 과정      제작자의 데모 사이트    하얀눈길님 블로그  Jaewoo님 블로그  Ju-ing님 블로그오류 참고  hashnsalt님 블로그"
  }
  
]

