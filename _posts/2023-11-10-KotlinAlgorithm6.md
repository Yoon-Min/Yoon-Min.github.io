---
title: (프로그래머스 | Kotlin) - 수식 최대화
author: yoonmin
date: 2023-11-14 21:00:00 +0900
categories: [CS, 알고리즘 문제]
tags: [Kotlin, Algorithm, 알고리즘, 프로그래머스]
render_with_liquid: false
---

## 해결 방법

뭔가 풀이 방법이 다양할 것 같은 문제인데 나는 재귀를 이용해서 해결했다. 연산 기호가 최대 세 개인데 연산 우선순위를 리스트로 표현했다. 예를 들어서 표현식에서 사용된 연산 기호가 `*` `-` , 2개라면 만들 수 있는 우선순위 조합은 2개, `[[*, -], [-, *]]`  이렇게 리스트로 표현이 가능하다. 인덱스가 클수록 연산 우선순위가 높다는 뜻이다.

이런 식으로 만들 수 있는 연산 우선순위를 모두 만들고 모든 경우에 대해 식을 계산하고 결과값을 비교해서 가장 큰 값을 리턴하면 문제 해결이 가능하다. 그런데 문제는 식을 계산하는 방법이다. 여기서 풀이 방법이 다양하게 갈릴 것 같은데 내가 푼 방법은 다음과 같다.

### 1. 나올 수 있는 연산 우선순위 조합 모두 구하기

`"100-200*300-500+20"` 예제를 예시로 생각해보자. 사용된 연산자는 `*` `-` `+` 총 세 개, 나올 수 있는 연산 우선순위 조합은 총 여섯 개다. 우선 이 여섯 개를 구하는 알고리즘을 짜야 한다. 이는 [**순열 알고리즘**](https://notepad96.tistory.com/108)을 이용해서 구하면 된다. 

제네릭 함수, 리스트 확장함수, 연산자 함수를 응용한 깔끔한 순열 알고리즘이다. 자세한 원리는 링크를 통해서 확인하면 된다. 개인적으로 가장 깔끔한 순열 알고리즘인 것 같다.

```kotlin
private fun <T> permutation(sub: List<T>, fin: List<T> = listOf()): List<List<T>> {
    return if(sub.isEmpty()) listOf(fin)
    else sub.flatMap { permutation(sub - it, fin + it) }
}
```

```kotlin
permutation(listOf('*', '-', '+'))
// [*, +, -]
// [*, -, +]
// [+, *, -]
// [+, -, *]
// [-, *, +]
// [-, +, *]
```

### 2. 재귀를 이용한 식 계산

```kotlin
permutation(existingOperator.toList()).forEach {
    answer = max(answer, abs(rec(expression, it.toList())))
}
```

`rec` : 식을 계산한 결과값을 반환하는 재귀 함수이고 계산할 식이 담긴 문자열과 연산 우선순위 정보를 인자로 넘긴다. 그리고 계산 결과의 절대값으로 비교를 해야 하므로 `abs` 로 감싸준다. 이렇게 메인 함수에서 틀을 잡는다.

다음은 `rec` 함수 구현 부분이다. 해당 함수로 넘기는 인자는 `"100-200*300-500+20"` , `[*, +, -]` 라고 가정해보자. 