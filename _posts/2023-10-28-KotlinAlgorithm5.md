---
title: (프로그래머스 | Kotlin) - 카드 짝 맞추기
author: yoonmin
date: 2023-10-28 22:00:00 +0900
categories: [CS, 알고리즘 문제]
tags: [Kotlin, Algorithm, 알고리즘, 프로그래머스]
render_with_liquid: false
---

## 해결 방법

이 문제의 핵심은 그냥 구현, 또 구현, 그리고 또 구현이다. 막 엄청 수준이 높은 알고리즘을 요구하는 것이 아닌 기본적인 알고리즘 여러 개를 가지고 복잡한 구현을 요구한다. 그래서 이 문제를 풀면서 굉장한 피로감을 느꼈다... 나같은 경우에는 백트래킹, 너비 우선 탐색, 그리디 이 세 가지를 중심으로 구현을 진행했다. 해당 알고리즘을 사용한 이유는 다음과 같다.

#### 1. 최소 탐색을 위해서는 가능한 뒤집는 순서 조합을 모두 구해서 계산해야 한다.

만약 보드판 위에 `1` `2` `3` 이렇게 세 종류의 카드가 존재한다면 가능한 뒤집는 순서의 갯수는 6가지다. 이 6가지 순서쌍에서 최소 탐색을 할 수 있는 순서쌍이 존재하기 때문에 모든 순서쌍을 계산해서 최소값을 찾는 방식으로 진행한다.

1. `1 -> 2 -> 3`
2. `1 -> 3 -> 2`
3. `2 -> 1 -> 3`
4. `2 -> 3 -> 1`
5. `3 -> 1 -> 2`
6. `3 -> 2 -> 1`

#### 2. 같은 종류의 카드가 2개씩 있는데 이 2개의 뒤집는 순서도 고려해야 한다.

카드가 `1` `2` `3` 이렇게 있으면 한 개씩 세 장을 의미하는 게 아니라 실제로는 각 종류별로 2개씩 총 6장의 카드가 보드판에 존재한다. 따라서 각 종류별로 2장을 어떤 순서로 뒤집을 건지도 고려해야 한다. 이 부분은 예를 들어서 특정  `n`번 카드 두 장을 각각 `a` `b` 라고 가정하자. 그럼 `a -> b` `b -> a` 이렇게 두 가지 경우에서 더 작은 이동값을 가지는 경우를 택한다.



#### 3. 보드판 위에서 특정 위치의 카드를 찾는 방법은 BFS를 이용한다.

카드를 뒤집기 위해서는 현재 위치에 있는 커서가 카드가 있는 곳으로 최소의 움직임으로 이동해야 한다. 따라서 이를 위해 BFS를 이용하여 구현했다. 대충 함수 헤더가 어떤지 설명하자면 `fun bfs(curr: Pair<Int,Int>, target: Pair<Int,Int>)` 이런 느낌이다.



 